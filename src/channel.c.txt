
#include <postgres.h>
#include <utils/elog.h>
#include <miscadmin.h>

#include "channel.h"
#include "shmem.h"

/*-------------------------------------------------------------------------
 * Static helpers
 *-------------------------------------------------------------------------
 */

/* 빈 슬롯 하나 할당하고 request_id 까지 세팅 */
static bool postfga_ch_slot_acquire(FgaChannel *channel, uint16 *out_slot_index);
static void postfga_ch_slot_release(FgaChannel *channel, uint16 slot_index);

void postfga_ch_write(FgaChannel *channel, const FgaRequest *request, uint16 *out_slot_index)
{
    uint16 slot_index;

    /* 슬롯 할당 */
    bool acquired = postfga_ch_slot_acquire(channel, &slot_index);
    if (!acquired)
    {
        /* 슬롯 풀이 가득 찼음 */
        *out_slot_index = UINT16_MAX;
        return;
    }

    /* 슬롯에 요청 복사 */
    FgaChannelSlot *slot = &channel->pool.slots[slot_index];
    slot->request_id = request->request_id;
    slot->backend_pid = MyProcPid;
    pg_atomic_write_u32(&slot->state, FGA_SLOT_PENDING);
    memcpy(&slot->request, request, sizeof(FgaRequest));

    /* 큐에 슬롯 인덱스 추가 */
    LWLockAcquire(channel->lock, LW_EXCLUSIVE);
    bool enqueued = postfga_enqueue_slot(channel->queue, slot_index);
    LWLockRelease(channel->lock);

    if (!enqueued)
    {
        /* 큐가 가득 찼음 - 슬롯 반환 */
        postfga_ch_slot_release(channel, slot_index);
        *out_slot_index = UINT16_MAX;
        return;
    }

    *out_slot_index = slot_index;
}

bool postfga_ch_slot_acquire(FgaChannel *channel, uint16 *out_slot_index)
{
    slist_node *node;
    FgaChannelSlot *slot;
    FgaChannelSlotPool *pool = &channel->pool;

    LWLockAcquire(channel->lock, LW_EXCLUSIVE);
    if (slist_is_empty(&pool->head))
    {
        LWLockRelease(channel->lock);
        return false;
    }

    node = slist_pop_head_node(&pool->head);
    slot = slist_container(FgaChannelSlot, node, node);
    *out_slot_index = slot - pool->slots;

    LWLockRelease(channel->lock);
    return true;
}

void postfga_ch_slot_release(FgaChannel *channel, uint16 slot_index)
{
    FgaChannelSlot *slot;

    if (slot_index == FGA_INVALID_SLOT)
        return;

    Assert(slot_index < channel->pool.size);

    slot = &channel->pool.slots[slot_index];

    pg_atomic_write_u32(&slot->state, FGA_SLOT_EMPTY);

    LWLockAcquire(channel->lock, LW_EXCLUSIVE);
    slist_push_head(&channel->pool.head, &slot->node);
    LWLockRelease(channel->lock);
}
