/* channel_slot.c */

#include <postgres.h>
#include <miscadmin.h>
#include <storage/latch.h>
#include <utils/elog.h>
#include <pgstat.h>

#include "channel_slot.h"
#include "shmem.h"

void postfga_slots_init(FgaChannelSlotPool *pool)
{
    slist_init(&pool->head);

    for (uint32 i = 0; i < pool->size; i++)
    {
        FgaChannelSlot *slot = &pool->slots[i];

        pg_atomic_init_u32(&slot->state, FGA_SLOT_EMPTY);
        slot->backend_pid = 0;
        slot->pad = 0;

        memset(&slot->request, 0, sizeof(FgaRequest));
        memset(&slot->stream, 0, sizeof(FgaChannelStream));

        slist_push_head(&pool->head, &slot->node);
    }
}

bool postfga_slots_is_empty(FgaChannelSlotPool *pool)
{
    return slist_is_empty(&pool->head);
}

/*
 * postfga_slots_pop_chunk
 *
 *  - out: 읽어온 chunk
 *  - eof: true 이면 스트림 종료 (더 이상 chunk 없음)
 *
 * 리턴값:
 *  - true  : chunk 하나를 out 에 채움
 *  - false : eof == true 인 경우에만 의미있음 (완전 EOF)
 *            eof == false 인 상태로 false 리턴하는 일은 없음
 */
bool postfga_slots_pop_chunk(FgaChannelSlot *slot,
                             FgaChannelStreamChunk *out_chunk)
{
    FgaChannelStream *stream = &slot->stream;
    for (;;)
    {
        uint32 stream_state = pg_atomic_read_u32(&stream->state);

        if (postfga_ch_stream_pop(stream, out_chunk))
        {
            return true;
        }

        if (stream_state == FGA_CHANNEL_STREAM_DONE)
        {
            return false;
        }

        if (stream_state == FGA_CHANNEL_STREAM_ERROR ||
            pg_atomic_read_u32(&slot->state) == FGA_SLOT_ERROR)
        {
            ereport(ERROR,
                    (errmsg("PostFGA stream error (req_id=" UINT64_FORMAT ")",
                            slot->request_id)));
        }

        WaitLatch(MyLatch,
                  WL_LATCH_SET | WL_TIMEOUT | WL_EXIT_ON_PM_DEATH,
                  100L,
                  PG_WAIT_EXTENSION);
        ResetLatch(MyLatch);

        CHECK_FOR_INTERRUPTS();
    }

    return true;
}
