#ifndef POSTFGA_REQUSET_QUEUE_H
#define POSTFGA_REQUSET_QUEUE_H

#include <stddef.h>  // size_t
#include <stdint.h>  // uint32_t
#include <stdbool.h> // bool
#include <assert.h>

#ifdef __cplusplus
extern "C"
{
#endif

/*
 * buffer_size 가 2의 거듭제곱인지 확인하는 매크로
 */
#define POSTFGA_IS_POWER_OF_TWO(sz) (((sz) & ((sz) - 1u)) == 0u)

    /*
     * FgaChannelQueue
     *
     * - RequestPayload 전용 링버퍼
     * - head_index: 다음 enqueue 위치
     * - tail_index: 다음 dequeue 위치
     * - buffer_mask: (capacity - 1), capacity는 반드시 2의 거듭제곱
     *
     * 한 칸 비워두는 패턴을 사용하므로,
     * 실제로 담을 수 있는 최대 요소 개수는 (capacity - 1).
     */
    typedef struct FgaChannelQueue
    {
        uint16_t mask;    /* capacity - 1 (2^n - 1) */
        uint16_t head;    /* enqueue 위치 */
        uint16_t tail;    /* dequeue 위치 */
        uint16_t slots[]; /* slot index 배열 - FAM */
    } FgaChannelQueue;

    /*
     * postfga_init_queue
     *
     * - buffer      : 사전에 할당된 RequestPayload 배열
     * - capacity    : 배열 길이(요소 개수). 반드시 2의 거듭제곱이어야 함.
     * - 실제로 저장 가능한 요소 최대 개수는 (capacity - 1).
     */
    static inline void
    postfga_init_queue(FgaChannelQueue *q, uint16_t capacity)
    {
        assert(q != NULL);
        assert(capacity > 1u);
        assert(POSTFGA_IS_POWER_OF_TWO(capacity));

        q->mask = capacity - 1u;
        q->head = 0u;
        q->tail = 0u;
    }

    static inline uint16_t
    postfga_queue_size(const FgaChannelQueue *q)
    {
        return (q->head - q->tail) & q->mask;
    }

    static inline bool
    postfga_queue_is_empty(const FgaChannelQueue *q)
    {
        return q->head == q->tail;
    }

    static inline bool
    postfga_queue_is_full(const FgaChannelQueue *q)
    {
        return postfga_queue_size(q) == q->mask;
    }

    /*
     * 남은 공간(더 넣을 수 있는 요소 개수) 반환
     * 최대값은 (capacity - 1)
     */
    static inline uint16_t
    postfga_queue_available(const FgaChannelQueue *q)
    {
        uint16_t capacity = q->mask + 1u;
        return (capacity - 1u) - postfga_queue_size(q);
    }

    /*
     * enqueue 하나
     *
     * - 성공 시 true, 큐가 가득 차 있으면 false
     * - 동시성 제어(LWLock 등)는 호출자가 담당
     */
    static inline bool
    postfga_enqueue_slot(FgaChannelQueue *q, uint16_t slot_index)
    {
        if (postfga_queue_is_full(q))
            return false;

        q->slots[q->head & q->mask] = slot_index;

        q->head++;

        return true;
    }

    /*
     * dequeue 하나
     *
     * - 성공 시 true, 큐가 비어 있으면 false
     * - 동시성 제어는 호출자가 담당
     */
    static inline bool
    postfga_dequeue_slot(FgaChannelQueue *q, uint16_t *out_slot)
    {
        if (postfga_queue_is_empty(q))
            return false;

        *out_slot = q->slots[q->tail & q->mask];
        q->tail++;

        return true;
    }

    /*
     * batch dequeue
     *
     * - 최대 max_count 개까지 꺼내서 out 배열에 채움
     * - 실제 꺼낸 개수 반환
     */
    static inline uint16_t
    postfga_dequeue_slots(FgaChannelQueue *q, uint16_t *out, uint16_t max_count)
    {
        uint16_t n = 0;
        while (n < max_count && !postfga_queue_is_empty(q))
        {
            out[n] = q->slots[q->tail & q->mask];
            q->tail++;
            n++;
        }

        return n;
    }

    /*
     * 맨 앞 요소를 제거 없이 조회 (index는 0이 가장 오래된 요소)
     *
     * - index 범위: 0 <= index < postfga_queue_size(q)
     * - 범위 밖이면 false 반환
     */
    static inline bool
    postfga_queue_peek(const FgaChannelQueue *q, uint16_t index, uint16_t *out_slot)
    {
        uint16_t size = postfga_queue_size(q);
        if (index >= size)
            return false;

        *out_slot = q->slots[(q->tail + index) & q->mask];
        return true;
    }

#ifdef __cplusplus
}
#endif

#endif /* POSTFGA_REQUSET_QUEUE_H */