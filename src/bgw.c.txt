/*
 * Background Worker implementation for PostFGA
 *
 * BGW lifecycle: Register -> Initialize -> Main Loop -> Shutdown
 */

#include <postgres.h>
#include <miscadmin.h>
#include <postmaster/bgworker.h>
#include <storage/ipc.h>
#include <storage/latch.h>
#include <storage/proc.h>
#include <utils/guc.h>
#include <pgstat.h>

#include "bgw.h"
#include "state.h"
#include "guc.h"
#include "queue.h"
#include "client.h"

static volatile sig_atomic_t shutdown_requested = false;
static volatile sig_atomic_t reload_requested = false;
static GrpcClient *grpc_client = NULL;

#define MAX_BATCH_SIZE 32

/*
 * grpc_check_callback - Callback invoked when async gRPC Check completes
 */
static void
grpc_check_callback(const CheckResponse *response, void *user_data)
{
    uint32 request_id = *(uint32 *)user_data;

    if (!response)
    {
        elog(WARNING, "PostFGA BGW: NULL response for request %u", request_id);
        set_grpc_result(request_id, false, 9999);  /* Internal error */
        return;
    }

    /* Set result in shared memory queue */
    set_grpc_result(request_id, response->allowed, response->error_code);

    if (response->error_code != 0)
    {
        elog(LOG, "PostFGA BGW: Request %u completed with error: %s",
             request_id, response->error_message);
    }
    else
    {
        elog(DEBUG2, "PostFGA BGW: Request %u completed: allowed=%d",
             request_id, response->allowed);
    }

    /* Free user_data */
    pfree(user_data);
}

/*
 * grpc_write_callback - Called when Write request completes
 */
static void
grpc_write_callback(const WriteResponse *response, void *user_data)
{
    uint32 request_id;

    if (!response || !user_data)
    {
        elog(WARNING, "PostFGA BGW: Invalid write callback arguments");
        return;
    }

    request_id = *(uint32 *)user_data;

    /* Set result in shared memory queue */
    set_grpc_result(request_id, response->success, response->error_code);

    if (response->error_code != 0)
    {
        elog(LOG, "PostFGA BGW: Write request %u completed with error: %s",
             request_id, response->error_message);
    }
    else
    {
        elog(DEBUG2, "PostFGA BGW: Write request %u completed successfully",
             request_id);
    }

    /* Free user_data */
    pfree(user_data);
}

/*
 * process_pending_requests - Dequeue and process gRPC requests
 */
static void
process_pending_requests(void)
{
    RequestPayload requests[MAX_BATCH_SIZE];
    uint32 count = MAX_BATCH_SIZE;
    uint32 i;

    /* Initialize gRPC client if not already done */
    if (!grpc_client)
    {
        const char *endpoint = GetConfigOption("postfga.endpoint", false, false);
        if (!endpoint || endpoint[0] == '\0')
        {
            elog(WARNING, "PostFGA BGW: No endpoint configured");
            return;
        }

        grpc_client = postfga_client_init(endpoint);
        if (!grpc_client)
        {
            elog(ERROR, "PostFGA BGW: Failed to initialize gRPC client");
            return;
        }

        elog(LOG, "PostFGA BGW: gRPC client initialized with endpoint: %s", endpoint);
    }

    /* Check if client is healthy */
    if (!postfga_client_is_healthy(grpc_client))
    {
        elog(WARNING, "PostFGA BGW: gRPC client is not healthy");
        /* Could attempt reconnection here */
        return;
    }

    /* Dequeue requests */
    if (!dequeue_requests(requests, &count))
    {
        /* No requests to process */
        return;
    }

    elog(DEBUG1, "PostFGA BGW: Processing %u requests", count);

    /* Get store ID and authorization model from GUC */
    const char *store_id = GetConfigOption("postfga.store_id", false, false);
    const char *auth_model_id = GetConfigOption("postfga.authorization_model_id", false, false);

    if (!store_id || store_id[0] == '\0')
    {
        elog(WARNING, "PostFGA BGW: No store_id configured");
        /* Mark all requests as failed */
        for (i = 0; i < count; i++)
        {
            set_grpc_result(requests[i].base.request_id, false, 8888);
        }
        return;
    }

    /* Process each request asynchronously based on type */
    for (i = 0; i < count; i++)
    {
        RequestPayload *payload = &requests[i];
        uint32 *request_id_ptr;

        /* Allocate request ID for callback */
        request_id_ptr = (uint32 *)palloc(sizeof(uint32));
        *request_id_ptr = payload->base.request_id;

        if (payload->base.type == REQ_TYPE_CHECK)
        {
            CheckRequest *req = &payload->check;
            GrpcCheckRequest check_req = {0};

            /* Build GrpcCheckRequest */
            check_req.store_id = store_id;
            check_req.authorization_model_id = auth_model_id;
            check_req.object_type = req->object_type;
            check_req.object_id = req->object_id;
            check_req.relation = req->relation;
            check_req.subject_type = req->subject_type;
            check_req.subject_id = req->subject_id;

            /* Submit async gRPC Check request */
            if (!postfga_client_check_async(grpc_client, &check_req,
                                         grpc_check_callback, request_id_ptr))
            {
                elog(WARNING, "PostFGA BGW: Failed to submit async check request %u",
                     payload->base.request_id);
                set_grpc_result(payload->base.request_id, false, 7777);
                pfree(request_id_ptr);
            }
        }
        else if (payload->base.type == REQ_TYPE_WRITE)
        {
            WriteRequest *req = &payload->write;
            GrpcWriteRequest write_req = {0};

            /* Build GrpcWriteRequest */
            write_req.store_id = store_id;
            write_req.authorization_model_id = auth_model_id;
            write_req.object_type = req->object_type;
            write_req.object_id = req->object_id;
            write_req.relation = req->relation;
            write_req.subject_type = req->subject_type;
            write_req.subject_id = req->subject_id;

            /* Submit async gRPC Write request */
            if (!postfga_client_write_async(grpc_client, &write_req,
                                         grpc_write_callback, request_id_ptr))
            {
                elog(WARNING, "PostFGA BGW: Failed to submit async write request %u",
                     payload->base.request_id);
                set_grpc_result(payload->base.request_id, false, 7777);
                pfree(request_id_ptr);
            }
        }
        else
        {
            elog(WARNING, "PostFGA BGW: Unsupported request type %d", payload->base.type);
            set_grpc_result(payload->base.request_id, false, 9999);
            pfree(request_id_ptr);
        }
    }

    /* Poll for completed async operations */
    postfga_client_poll(grpc_client, 0);  /* Non-blocking */
}

/*
 * bgw_sigterm_handler - Handle SIGTERM signal
 */
static void
bgw_sigterm_handler(SIGNAL_ARGS)
{
    int save_errno = errno;
    shutdown_requested = true;
    if (MyLatch)
        SetLatch(MyLatch);
    errno = save_errno;
}

/*
 * bgw_sighup_handler - Handle SIGHUP signal
 */
static void
bgw_sighup_handler(SIGNAL_ARGS)
{
    int save_errno = errno;
    reload_requested = true;
    if (MyLatch != NULL)
        SetLatch(MyLatch);
    errno = save_errno;
}

/*
 * postfga_bgw_init - Register background worker with PostgreSQL
 */
void
postfga_bgw_init(void)
{
    BackgroundWorker worker;
    memset(&worker, 0, sizeof(BackgroundWorker));

    /* Configuration */
    worker.bgw_flags = BGWORKER_SHMEM_ACCESS;
    worker.bgw_start_time = BgWorkerStart_RecoveryFinished;
    worker.bgw_restart_time = 10;
    worker.bgw_notify_pid = 0;
    worker.bgw_main_arg = (Datum) 0;

    /* Entry point */
    strlcpy(worker.bgw_library_name, "postfga", BGW_MAXLEN);
    strlcpy(worker.bgw_function_name, "postfga_bgw_main", BGW_MAXLEN);
    strlcpy(worker.bgw_name, "postfga_bgw", BGW_MAXLEN);
    strlcpy(worker.bgw_type, "postfga_worker", BGW_MAXLEN);

    RegisterBackgroundWorker(&worker);
    elog(DEBUG1, "PostFGA BGW: registered");
}

void
postfga_bgw_fini(void)
{
    // noop
}

/*
 * postfga_bgw_main - Background worker main loop
 */
void
postfga_bgw_main(Datum arg)
{
    (void) arg;

    ereport(DEBUG1, (errmsg("postfga background worker started")));

    /* Setup signal handlers */
    pqsignal(SIGTERM, bgw_sigterm_handler);
    pqsignal(SIGHUP, bgw_sighup_handler);
    BackgroundWorkerUnblockSignals();

    /* Connect to shared memory */
    // BackgroundWorkerInitializeConnection(NULL, NULL, 0);

    /* Register latch */
    PostfgaShmemState *state = get_shared_state();
    if (!state)
    {
        elog(LOG, "PostFGA BGW: no shared state found");
        proc_exit(1);
    }

    /* Register latch in shared state */
    LWLockAcquire(state->lock, LW_EXCLUSIVE);
    state->bgw_latch = MyLatch;
    LWLockRelease(state->lock);

    /* Main loop */
    while (!shutdown_requested)
    {
        int rc = WaitLatch(MyLatch,
            WL_LATCH_SET | WL_EXIT_ON_PM_DEATH,
            -1,
            PG_WAIT_EXTENSION
        );

        ResetLatch(MyLatch);

        /* Postmaster death */
        if (rc & WL_POSTMASTER_DEATH)
            proc_exit(1);

        /* Reload configuration if needed */
        if (reload_requested)
        {
            reload_requested = false;
            ProcessConfigFile(PGC_SIGHUP);
        }            

        /* Process pending gRPC requests */
        process_pending_requests();

        pgstat_report_activity(STATE_IDLE, NULL);
    }

    /* Cleanup */
    LWLockAcquire(state->lock, LW_EXCLUSIVE);
    state->bgw_latch = NULL;
    LWLockRelease(state->lock);

    /* Shutdown gRPC client */
    if (grpc_client)
    {
        postfga_client_fini(grpc_client);
        grpc_client = NULL;
        elog(LOG, "PostFGA BGW: gRPC client shut down");
    }

    proc_exit(0);
}
