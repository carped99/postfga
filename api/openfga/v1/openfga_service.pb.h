// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: openfga/v1/openfga_service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_openfga_2fv1_2fopenfga_5fservice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_openfga_2fv1_2fopenfga_5fservice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
#include "google/api/field_behavior.pb.h"
#include "google/api/visibility.pb.h"
#include <google/protobuf/struct.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/wrappers.pb.h>
#include "openfga/v1/authzmodel.pb.h"
#include "openfga/v1/errors_ignore.pb.h"
#include "openfga/v1/openfga.pb.h"
#include "openfga/v1/openfga_service_consistency.pb.h"
#include "protoc-gen-openapiv2/options/annotations.pb.h"
#include "validate/validate.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_openfga_2fv1_2fopenfga_5fservice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto;
namespace openfga {
namespace v1 {
class Assertion;
struct AssertionDefaultTypeInternal;
extern AssertionDefaultTypeInternal _Assertion_default_instance_;
class AssertionTupleKey;
struct AssertionTupleKeyDefaultTypeInternal;
extern AssertionTupleKeyDefaultTypeInternal _AssertionTupleKey_default_instance_;
class Assertions;
struct AssertionsDefaultTypeInternal;
extern AssertionsDefaultTypeInternal _Assertions_default_instance_;
class BatchCheckItem;
struct BatchCheckItemDefaultTypeInternal;
extern BatchCheckItemDefaultTypeInternal _BatchCheckItem_default_instance_;
class BatchCheckRequest;
struct BatchCheckRequestDefaultTypeInternal;
extern BatchCheckRequestDefaultTypeInternal _BatchCheckRequest_default_instance_;
class BatchCheckResponse;
struct BatchCheckResponseDefaultTypeInternal;
extern BatchCheckResponseDefaultTypeInternal _BatchCheckResponse_default_instance_;
class BatchCheckResponse_ResultEntry_DoNotUse;
struct BatchCheckResponse_ResultEntry_DoNotUseDefaultTypeInternal;
extern BatchCheckResponse_ResultEntry_DoNotUseDefaultTypeInternal _BatchCheckResponse_ResultEntry_DoNotUse_default_instance_;
class BatchCheckSingleResult;
struct BatchCheckSingleResultDefaultTypeInternal;
extern BatchCheckSingleResultDefaultTypeInternal _BatchCheckSingleResult_default_instance_;
class CheckError;
struct CheckErrorDefaultTypeInternal;
extern CheckErrorDefaultTypeInternal _CheckError_default_instance_;
class CheckRequest;
struct CheckRequestDefaultTypeInternal;
extern CheckRequestDefaultTypeInternal _CheckRequest_default_instance_;
class CheckRequestTupleKey;
struct CheckRequestTupleKeyDefaultTypeInternal;
extern CheckRequestTupleKeyDefaultTypeInternal _CheckRequestTupleKey_default_instance_;
class CheckResponse;
struct CheckResponseDefaultTypeInternal;
extern CheckResponseDefaultTypeInternal _CheckResponse_default_instance_;
class CreateStoreRequest;
struct CreateStoreRequestDefaultTypeInternal;
extern CreateStoreRequestDefaultTypeInternal _CreateStoreRequest_default_instance_;
class CreateStoreResponse;
struct CreateStoreResponseDefaultTypeInternal;
extern CreateStoreResponseDefaultTypeInternal _CreateStoreResponse_default_instance_;
class DeleteStoreRequest;
struct DeleteStoreRequestDefaultTypeInternal;
extern DeleteStoreRequestDefaultTypeInternal _DeleteStoreRequest_default_instance_;
class DeleteStoreResponse;
struct DeleteStoreResponseDefaultTypeInternal;
extern DeleteStoreResponseDefaultTypeInternal _DeleteStoreResponse_default_instance_;
class ExpandRequest;
struct ExpandRequestDefaultTypeInternal;
extern ExpandRequestDefaultTypeInternal _ExpandRequest_default_instance_;
class ExpandRequestTupleKey;
struct ExpandRequestTupleKeyDefaultTypeInternal;
extern ExpandRequestTupleKeyDefaultTypeInternal _ExpandRequestTupleKey_default_instance_;
class ExpandResponse;
struct ExpandResponseDefaultTypeInternal;
extern ExpandResponseDefaultTypeInternal _ExpandResponse_default_instance_;
class GetStoreRequest;
struct GetStoreRequestDefaultTypeInternal;
extern GetStoreRequestDefaultTypeInternal _GetStoreRequest_default_instance_;
class GetStoreResponse;
struct GetStoreResponseDefaultTypeInternal;
extern GetStoreResponseDefaultTypeInternal _GetStoreResponse_default_instance_;
class ListObjectsRequest;
struct ListObjectsRequestDefaultTypeInternal;
extern ListObjectsRequestDefaultTypeInternal _ListObjectsRequest_default_instance_;
class ListObjectsResponse;
struct ListObjectsResponseDefaultTypeInternal;
extern ListObjectsResponseDefaultTypeInternal _ListObjectsResponse_default_instance_;
class ListStoresRequest;
struct ListStoresRequestDefaultTypeInternal;
extern ListStoresRequestDefaultTypeInternal _ListStoresRequest_default_instance_;
class ListStoresResponse;
struct ListStoresResponseDefaultTypeInternal;
extern ListStoresResponseDefaultTypeInternal _ListStoresResponse_default_instance_;
class ListUsersRequest;
struct ListUsersRequestDefaultTypeInternal;
extern ListUsersRequestDefaultTypeInternal _ListUsersRequest_default_instance_;
class ListUsersResponse;
struct ListUsersResponseDefaultTypeInternal;
extern ListUsersResponseDefaultTypeInternal _ListUsersResponse_default_instance_;
class ReadAssertionsRequest;
struct ReadAssertionsRequestDefaultTypeInternal;
extern ReadAssertionsRequestDefaultTypeInternal _ReadAssertionsRequest_default_instance_;
class ReadAssertionsResponse;
struct ReadAssertionsResponseDefaultTypeInternal;
extern ReadAssertionsResponseDefaultTypeInternal _ReadAssertionsResponse_default_instance_;
class ReadAuthorizationModelRequest;
struct ReadAuthorizationModelRequestDefaultTypeInternal;
extern ReadAuthorizationModelRequestDefaultTypeInternal _ReadAuthorizationModelRequest_default_instance_;
class ReadAuthorizationModelResponse;
struct ReadAuthorizationModelResponseDefaultTypeInternal;
extern ReadAuthorizationModelResponseDefaultTypeInternal _ReadAuthorizationModelResponse_default_instance_;
class ReadAuthorizationModelsRequest;
struct ReadAuthorizationModelsRequestDefaultTypeInternal;
extern ReadAuthorizationModelsRequestDefaultTypeInternal _ReadAuthorizationModelsRequest_default_instance_;
class ReadAuthorizationModelsResponse;
struct ReadAuthorizationModelsResponseDefaultTypeInternal;
extern ReadAuthorizationModelsResponseDefaultTypeInternal _ReadAuthorizationModelsResponse_default_instance_;
class ReadChangesRequest;
struct ReadChangesRequestDefaultTypeInternal;
extern ReadChangesRequestDefaultTypeInternal _ReadChangesRequest_default_instance_;
class ReadChangesResponse;
struct ReadChangesResponseDefaultTypeInternal;
extern ReadChangesResponseDefaultTypeInternal _ReadChangesResponse_default_instance_;
class ReadRequest;
struct ReadRequestDefaultTypeInternal;
extern ReadRequestDefaultTypeInternal _ReadRequest_default_instance_;
class ReadRequestTupleKey;
struct ReadRequestTupleKeyDefaultTypeInternal;
extern ReadRequestTupleKeyDefaultTypeInternal _ReadRequestTupleKey_default_instance_;
class ReadResponse;
struct ReadResponseDefaultTypeInternal;
extern ReadResponseDefaultTypeInternal _ReadResponse_default_instance_;
class StreamedListObjectsRequest;
struct StreamedListObjectsRequestDefaultTypeInternal;
extern StreamedListObjectsRequestDefaultTypeInternal _StreamedListObjectsRequest_default_instance_;
class StreamedListObjectsResponse;
struct StreamedListObjectsResponseDefaultTypeInternal;
extern StreamedListObjectsResponseDefaultTypeInternal _StreamedListObjectsResponse_default_instance_;
class UpdateStoreRequest;
struct UpdateStoreRequestDefaultTypeInternal;
extern UpdateStoreRequestDefaultTypeInternal _UpdateStoreRequest_default_instance_;
class UpdateStoreResponse;
struct UpdateStoreResponseDefaultTypeInternal;
extern UpdateStoreResponseDefaultTypeInternal _UpdateStoreResponse_default_instance_;
class WriteAssertionsRequest;
struct WriteAssertionsRequestDefaultTypeInternal;
extern WriteAssertionsRequestDefaultTypeInternal _WriteAssertionsRequest_default_instance_;
class WriteAssertionsResponse;
struct WriteAssertionsResponseDefaultTypeInternal;
extern WriteAssertionsResponseDefaultTypeInternal _WriteAssertionsResponse_default_instance_;
class WriteAuthorizationModelRequest;
struct WriteAuthorizationModelRequestDefaultTypeInternal;
extern WriteAuthorizationModelRequestDefaultTypeInternal _WriteAuthorizationModelRequest_default_instance_;
class WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse;
struct WriteAuthorizationModelRequest_ConditionsEntry_DoNotUseDefaultTypeInternal;
extern WriteAuthorizationModelRequest_ConditionsEntry_DoNotUseDefaultTypeInternal _WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse_default_instance_;
class WriteAuthorizationModelResponse;
struct WriteAuthorizationModelResponseDefaultTypeInternal;
extern WriteAuthorizationModelResponseDefaultTypeInternal _WriteAuthorizationModelResponse_default_instance_;
class WriteRequest;
struct WriteRequestDefaultTypeInternal;
extern WriteRequestDefaultTypeInternal _WriteRequest_default_instance_;
class WriteRequestDeletes;
struct WriteRequestDeletesDefaultTypeInternal;
extern WriteRequestDeletesDefaultTypeInternal _WriteRequestDeletes_default_instance_;
class WriteRequestWrites;
struct WriteRequestWritesDefaultTypeInternal;
extern WriteRequestWritesDefaultTypeInternal _WriteRequestWrites_default_instance_;
class WriteResponse;
struct WriteResponseDefaultTypeInternal;
extern WriteResponseDefaultTypeInternal _WriteResponse_default_instance_;
}  // namespace v1
}  // namespace openfga
PROTOBUF_NAMESPACE_OPEN
template<> ::openfga::v1::Assertion* Arena::CreateMaybeMessage<::openfga::v1::Assertion>(Arena*);
template<> ::openfga::v1::AssertionTupleKey* Arena::CreateMaybeMessage<::openfga::v1::AssertionTupleKey>(Arena*);
template<> ::openfga::v1::Assertions* Arena::CreateMaybeMessage<::openfga::v1::Assertions>(Arena*);
template<> ::openfga::v1::BatchCheckItem* Arena::CreateMaybeMessage<::openfga::v1::BatchCheckItem>(Arena*);
template<> ::openfga::v1::BatchCheckRequest* Arena::CreateMaybeMessage<::openfga::v1::BatchCheckRequest>(Arena*);
template<> ::openfga::v1::BatchCheckResponse* Arena::CreateMaybeMessage<::openfga::v1::BatchCheckResponse>(Arena*);
template<> ::openfga::v1::BatchCheckResponse_ResultEntry_DoNotUse* Arena::CreateMaybeMessage<::openfga::v1::BatchCheckResponse_ResultEntry_DoNotUse>(Arena*);
template<> ::openfga::v1::BatchCheckSingleResult* Arena::CreateMaybeMessage<::openfga::v1::BatchCheckSingleResult>(Arena*);
template<> ::openfga::v1::CheckError* Arena::CreateMaybeMessage<::openfga::v1::CheckError>(Arena*);
template<> ::openfga::v1::CheckRequest* Arena::CreateMaybeMessage<::openfga::v1::CheckRequest>(Arena*);
template<> ::openfga::v1::CheckRequestTupleKey* Arena::CreateMaybeMessage<::openfga::v1::CheckRequestTupleKey>(Arena*);
template<> ::openfga::v1::CheckResponse* Arena::CreateMaybeMessage<::openfga::v1::CheckResponse>(Arena*);
template<> ::openfga::v1::CreateStoreRequest* Arena::CreateMaybeMessage<::openfga::v1::CreateStoreRequest>(Arena*);
template<> ::openfga::v1::CreateStoreResponse* Arena::CreateMaybeMessage<::openfga::v1::CreateStoreResponse>(Arena*);
template<> ::openfga::v1::DeleteStoreRequest* Arena::CreateMaybeMessage<::openfga::v1::DeleteStoreRequest>(Arena*);
template<> ::openfga::v1::DeleteStoreResponse* Arena::CreateMaybeMessage<::openfga::v1::DeleteStoreResponse>(Arena*);
template<> ::openfga::v1::ExpandRequest* Arena::CreateMaybeMessage<::openfga::v1::ExpandRequest>(Arena*);
template<> ::openfga::v1::ExpandRequestTupleKey* Arena::CreateMaybeMessage<::openfga::v1::ExpandRequestTupleKey>(Arena*);
template<> ::openfga::v1::ExpandResponse* Arena::CreateMaybeMessage<::openfga::v1::ExpandResponse>(Arena*);
template<> ::openfga::v1::GetStoreRequest* Arena::CreateMaybeMessage<::openfga::v1::GetStoreRequest>(Arena*);
template<> ::openfga::v1::GetStoreResponse* Arena::CreateMaybeMessage<::openfga::v1::GetStoreResponse>(Arena*);
template<> ::openfga::v1::ListObjectsRequest* Arena::CreateMaybeMessage<::openfga::v1::ListObjectsRequest>(Arena*);
template<> ::openfga::v1::ListObjectsResponse* Arena::CreateMaybeMessage<::openfga::v1::ListObjectsResponse>(Arena*);
template<> ::openfga::v1::ListStoresRequest* Arena::CreateMaybeMessage<::openfga::v1::ListStoresRequest>(Arena*);
template<> ::openfga::v1::ListStoresResponse* Arena::CreateMaybeMessage<::openfga::v1::ListStoresResponse>(Arena*);
template<> ::openfga::v1::ListUsersRequest* Arena::CreateMaybeMessage<::openfga::v1::ListUsersRequest>(Arena*);
template<> ::openfga::v1::ListUsersResponse* Arena::CreateMaybeMessage<::openfga::v1::ListUsersResponse>(Arena*);
template<> ::openfga::v1::ReadAssertionsRequest* Arena::CreateMaybeMessage<::openfga::v1::ReadAssertionsRequest>(Arena*);
template<> ::openfga::v1::ReadAssertionsResponse* Arena::CreateMaybeMessage<::openfga::v1::ReadAssertionsResponse>(Arena*);
template<> ::openfga::v1::ReadAuthorizationModelRequest* Arena::CreateMaybeMessage<::openfga::v1::ReadAuthorizationModelRequest>(Arena*);
template<> ::openfga::v1::ReadAuthorizationModelResponse* Arena::CreateMaybeMessage<::openfga::v1::ReadAuthorizationModelResponse>(Arena*);
template<> ::openfga::v1::ReadAuthorizationModelsRequest* Arena::CreateMaybeMessage<::openfga::v1::ReadAuthorizationModelsRequest>(Arena*);
template<> ::openfga::v1::ReadAuthorizationModelsResponse* Arena::CreateMaybeMessage<::openfga::v1::ReadAuthorizationModelsResponse>(Arena*);
template<> ::openfga::v1::ReadChangesRequest* Arena::CreateMaybeMessage<::openfga::v1::ReadChangesRequest>(Arena*);
template<> ::openfga::v1::ReadChangesResponse* Arena::CreateMaybeMessage<::openfga::v1::ReadChangesResponse>(Arena*);
template<> ::openfga::v1::ReadRequest* Arena::CreateMaybeMessage<::openfga::v1::ReadRequest>(Arena*);
template<> ::openfga::v1::ReadRequestTupleKey* Arena::CreateMaybeMessage<::openfga::v1::ReadRequestTupleKey>(Arena*);
template<> ::openfga::v1::ReadResponse* Arena::CreateMaybeMessage<::openfga::v1::ReadResponse>(Arena*);
template<> ::openfga::v1::StreamedListObjectsRequest* Arena::CreateMaybeMessage<::openfga::v1::StreamedListObjectsRequest>(Arena*);
template<> ::openfga::v1::StreamedListObjectsResponse* Arena::CreateMaybeMessage<::openfga::v1::StreamedListObjectsResponse>(Arena*);
template<> ::openfga::v1::UpdateStoreRequest* Arena::CreateMaybeMessage<::openfga::v1::UpdateStoreRequest>(Arena*);
template<> ::openfga::v1::UpdateStoreResponse* Arena::CreateMaybeMessage<::openfga::v1::UpdateStoreResponse>(Arena*);
template<> ::openfga::v1::WriteAssertionsRequest* Arena::CreateMaybeMessage<::openfga::v1::WriteAssertionsRequest>(Arena*);
template<> ::openfga::v1::WriteAssertionsResponse* Arena::CreateMaybeMessage<::openfga::v1::WriteAssertionsResponse>(Arena*);
template<> ::openfga::v1::WriteAuthorizationModelRequest* Arena::CreateMaybeMessage<::openfga::v1::WriteAuthorizationModelRequest>(Arena*);
template<> ::openfga::v1::WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse* Arena::CreateMaybeMessage<::openfga::v1::WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse>(Arena*);
template<> ::openfga::v1::WriteAuthorizationModelResponse* Arena::CreateMaybeMessage<::openfga::v1::WriteAuthorizationModelResponse>(Arena*);
template<> ::openfga::v1::WriteRequest* Arena::CreateMaybeMessage<::openfga::v1::WriteRequest>(Arena*);
template<> ::openfga::v1::WriteRequestDeletes* Arena::CreateMaybeMessage<::openfga::v1::WriteRequestDeletes>(Arena*);
template<> ::openfga::v1::WriteRequestWrites* Arena::CreateMaybeMessage<::openfga::v1::WriteRequestWrites>(Arena*);
template<> ::openfga::v1::WriteResponse* Arena::CreateMaybeMessage<::openfga::v1::WriteResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace openfga {
namespace v1 {

// ===================================================================

class ListObjectsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ListObjectsRequest) */ {
 public:
  inline ListObjectsRequest() : ListObjectsRequest(nullptr) {}
  ~ListObjectsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListObjectsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListObjectsRequest(const ListObjectsRequest& from);
  ListObjectsRequest(ListObjectsRequest&& from) noexcept
    : ListObjectsRequest() {
    *this = ::std::move(from);
  }

  inline ListObjectsRequest& operator=(const ListObjectsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListObjectsRequest& operator=(ListObjectsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListObjectsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListObjectsRequest* internal_default_instance() {
    return reinterpret_cast<const ListObjectsRequest*>(
               &_ListObjectsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ListObjectsRequest& a, ListObjectsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListObjectsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListObjectsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListObjectsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListObjectsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListObjectsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListObjectsRequest& from) {
    ListObjectsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListObjectsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ListObjectsRequest";
  }
  protected:
  explicit ListObjectsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoreIdFieldNumber = 1,
    kAuthorizationModelIdFieldNumber = 2,
    kTypeFieldNumber = 3,
    kRelationFieldNumber = 4,
    kUserFieldNumber = 5,
    kContextualTuplesFieldNumber = 6,
    kContextFieldNumber = 7,
    kConsistencyFieldNumber = 8,
  };
  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_store_id();
  const std::string& store_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_id();
  PROTOBUF_NODISCARD std::string* release_store_id();
  void set_allocated_store_id(std::string* store_id);
  private:
  const std::string& _internal_store_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_id(const std::string& value);
  std::string* _internal_mutable_store_id();
  public:

  // string authorization_model_id = 2 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_authorization_model_id();
  const std::string& authorization_model_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_authorization_model_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_authorization_model_id();
  PROTOBUF_NODISCARD std::string* release_authorization_model_id();
  void set_allocated_authorization_model_id(std::string* authorization_model_id);
  private:
  const std::string& _internal_authorization_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authorization_model_id(const std::string& value);
  std::string* _internal_mutable_authorization_model_id();
  public:

  // string type = 3 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string relation = 4 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_relation();
  const std::string& relation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_relation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_relation();
  PROTOBUF_NODISCARD std::string* release_relation();
  void set_allocated_relation(std::string* relation);
  private:
  const std::string& _internal_relation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relation(const std::string& value);
  std::string* _internal_mutable_relation();
  public:

  // string user = 5 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // .openfga.v1.ContextualTupleKeys contextual_tuples = 6 [json_name = "contextual_tuples"];
  bool has_contextual_tuples() const;
  private:
  bool _internal_has_contextual_tuples() const;
  public:
  void clear_contextual_tuples();
  const ::openfga::v1::ContextualTupleKeys& contextual_tuples() const;
  PROTOBUF_NODISCARD ::openfga::v1::ContextualTupleKeys* release_contextual_tuples();
  ::openfga::v1::ContextualTupleKeys* mutable_contextual_tuples();
  void set_allocated_contextual_tuples(::openfga::v1::ContextualTupleKeys* contextual_tuples);
  private:
  const ::openfga::v1::ContextualTupleKeys& _internal_contextual_tuples() const;
  ::openfga::v1::ContextualTupleKeys* _internal_mutable_contextual_tuples();
  public:
  void unsafe_arena_set_allocated_contextual_tuples(
      ::openfga::v1::ContextualTupleKeys* contextual_tuples);
  ::openfga::v1::ContextualTupleKeys* unsafe_arena_release_contextual_tuples();

  // .google.protobuf.Struct context = 7 [json_name = "context"];
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::PROTOBUF_NAMESPACE_ID::Struct& context() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_context();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_context();
  void set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_context() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::PROTOBUF_NAMESPACE_ID::Struct* context);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_context();

  // .openfga.v1.ConsistencyPreference consistency = 8 [json_name = "consistency", (.validate.rules) = {
  void clear_consistency();
  ::openfga::v1::ConsistencyPreference consistency() const;
  void set_consistency(::openfga::v1::ConsistencyPreference value);
  private:
  ::openfga::v1::ConsistencyPreference _internal_consistency() const;
  void _internal_set_consistency(::openfga::v1::ConsistencyPreference value);
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.ListObjectsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authorization_model_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    ::openfga::v1::ContextualTupleKeys* contextual_tuples_;
    ::PROTOBUF_NAMESPACE_ID::Struct* context_;
    int consistency_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ListObjectsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ListObjectsResponse) */ {
 public:
  inline ListObjectsResponse() : ListObjectsResponse(nullptr) {}
  ~ListObjectsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListObjectsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListObjectsResponse(const ListObjectsResponse& from);
  ListObjectsResponse(ListObjectsResponse&& from) noexcept
    : ListObjectsResponse() {
    *this = ::std::move(from);
  }

  inline ListObjectsResponse& operator=(const ListObjectsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListObjectsResponse& operator=(ListObjectsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListObjectsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListObjectsResponse* internal_default_instance() {
    return reinterpret_cast<const ListObjectsResponse*>(
               &_ListObjectsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ListObjectsResponse& a, ListObjectsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListObjectsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListObjectsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListObjectsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListObjectsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListObjectsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListObjectsResponse& from) {
    ListObjectsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListObjectsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ListObjectsResponse";
  }
  protected:
  explicit ListObjectsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectsFieldNumber = 1,
  };
  // repeated string objects = 1 [json_name = "objects", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int objects_size() const;
  private:
  int _internal_objects_size() const;
  public:
  void clear_objects();
  const std::string& objects(int index) const;
  std::string* mutable_objects(int index);
  void set_objects(int index, const std::string& value);
  void set_objects(int index, std::string&& value);
  void set_objects(int index, const char* value);
  void set_objects(int index, const char* value, size_t size);
  std::string* add_objects();
  void add_objects(const std::string& value);
  void add_objects(std::string&& value);
  void add_objects(const char* value);
  void add_objects(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& objects() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_objects();
  private:
  const std::string& _internal_objects(int index) const;
  std::string* _internal_add_objects();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.ListObjectsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> objects_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ListUsersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ListUsersRequest) */ {
 public:
  inline ListUsersRequest() : ListUsersRequest(nullptr) {}
  ~ListUsersRequest() override;
  explicit PROTOBUF_CONSTEXPR ListUsersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListUsersRequest(const ListUsersRequest& from);
  ListUsersRequest(ListUsersRequest&& from) noexcept
    : ListUsersRequest() {
    *this = ::std::move(from);
  }

  inline ListUsersRequest& operator=(const ListUsersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListUsersRequest& operator=(ListUsersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListUsersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListUsersRequest* internal_default_instance() {
    return reinterpret_cast<const ListUsersRequest*>(
               &_ListUsersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ListUsersRequest& a, ListUsersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListUsersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListUsersRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListUsersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListUsersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListUsersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListUsersRequest& from) {
    ListUsersRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListUsersRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ListUsersRequest";
  }
  protected:
  explicit ListUsersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFiltersFieldNumber = 5,
    kContextualTuplesFieldNumber = 6,
    kStoreIdFieldNumber = 1,
    kAuthorizationModelIdFieldNumber = 2,
    kRelationFieldNumber = 4,
    kObjectFieldNumber = 3,
    kContextFieldNumber = 7,
    kConsistencyFieldNumber = 8,
  };
  // repeated .openfga.v1.UserTypeFilter user_filters = 5 [json_name = "user_filters", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int user_filters_size() const;
  private:
  int _internal_user_filters_size() const;
  public:
  void clear_user_filters();
  ::openfga::v1::UserTypeFilter* mutable_user_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::UserTypeFilter >*
      mutable_user_filters();
  private:
  const ::openfga::v1::UserTypeFilter& _internal_user_filters(int index) const;
  ::openfga::v1::UserTypeFilter* _internal_add_user_filters();
  public:
  const ::openfga::v1::UserTypeFilter& user_filters(int index) const;
  ::openfga::v1::UserTypeFilter* add_user_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::UserTypeFilter >&
      user_filters() const;

  // repeated .openfga.v1.TupleKey contextual_tuples = 6 [json_name = "contextual_tuples", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int contextual_tuples_size() const;
  private:
  int _internal_contextual_tuples_size() const;
  public:
  void clear_contextual_tuples();
  ::openfga::v1::TupleKey* mutable_contextual_tuples(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKey >*
      mutable_contextual_tuples();
  private:
  const ::openfga::v1::TupleKey& _internal_contextual_tuples(int index) const;
  ::openfga::v1::TupleKey* _internal_add_contextual_tuples();
  public:
  const ::openfga::v1::TupleKey& contextual_tuples(int index) const;
  ::openfga::v1::TupleKey* add_contextual_tuples();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKey >&
      contextual_tuples() const;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_store_id();
  const std::string& store_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_id();
  PROTOBUF_NODISCARD std::string* release_store_id();
  void set_allocated_store_id(std::string* store_id);
  private:
  const std::string& _internal_store_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_id(const std::string& value);
  std::string* _internal_mutable_store_id();
  public:

  // string authorization_model_id = 2 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_authorization_model_id();
  const std::string& authorization_model_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_authorization_model_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_authorization_model_id();
  PROTOBUF_NODISCARD std::string* release_authorization_model_id();
  void set_allocated_authorization_model_id(std::string* authorization_model_id);
  private:
  const std::string& _internal_authorization_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authorization_model_id(const std::string& value);
  std::string* _internal_mutable_authorization_model_id();
  public:

  // string relation = 4 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_relation();
  const std::string& relation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_relation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_relation();
  PROTOBUF_NODISCARD std::string* release_relation();
  void set_allocated_relation(std::string* relation);
  private:
  const std::string& _internal_relation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relation(const std::string& value);
  std::string* _internal_mutable_relation();
  public:

  // .openfga.v1.Object object = 3 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::openfga::v1::Object& object() const;
  PROTOBUF_NODISCARD ::openfga::v1::Object* release_object();
  ::openfga::v1::Object* mutable_object();
  void set_allocated_object(::openfga::v1::Object* object);
  private:
  const ::openfga::v1::Object& _internal_object() const;
  ::openfga::v1::Object* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::openfga::v1::Object* object);
  ::openfga::v1::Object* unsafe_arena_release_object();

  // .google.protobuf.Struct context = 7 [json_name = "context"];
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::PROTOBUF_NAMESPACE_ID::Struct& context() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_context();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_context();
  void set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_context() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::PROTOBUF_NAMESPACE_ID::Struct* context);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_context();

  // .openfga.v1.ConsistencyPreference consistency = 8 [json_name = "consistency", (.validate.rules) = {
  void clear_consistency();
  ::openfga::v1::ConsistencyPreference consistency() const;
  void set_consistency(::openfga::v1::ConsistencyPreference value);
  private:
  ::openfga::v1::ConsistencyPreference _internal_consistency() const;
  void _internal_set_consistency(::openfga::v1::ConsistencyPreference value);
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.ListUsersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::UserTypeFilter > user_filters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKey > contextual_tuples_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authorization_model_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relation_;
    ::openfga::v1::Object* object_;
    ::PROTOBUF_NAMESPACE_ID::Struct* context_;
    int consistency_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ListUsersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ListUsersResponse) */ {
 public:
  inline ListUsersResponse() : ListUsersResponse(nullptr) {}
  ~ListUsersResponse() override;
  explicit PROTOBUF_CONSTEXPR ListUsersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListUsersResponse(const ListUsersResponse& from);
  ListUsersResponse(ListUsersResponse&& from) noexcept
    : ListUsersResponse() {
    *this = ::std::move(from);
  }

  inline ListUsersResponse& operator=(const ListUsersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListUsersResponse& operator=(ListUsersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListUsersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListUsersResponse* internal_default_instance() {
    return reinterpret_cast<const ListUsersResponse*>(
               &_ListUsersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ListUsersResponse& a, ListUsersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListUsersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListUsersResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListUsersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListUsersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListUsersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListUsersResponse& from) {
    ListUsersResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListUsersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ListUsersResponse";
  }
  protected:
  explicit ListUsersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsersFieldNumber = 1,
  };
  // repeated .openfga.v1.User users = 1 [json_name = "users", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int users_size() const;
  private:
  int _internal_users_size() const;
  public:
  void clear_users();
  ::openfga::v1::User* mutable_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::User >*
      mutable_users();
  private:
  const ::openfga::v1::User& _internal_users(int index) const;
  ::openfga::v1::User* _internal_add_users();
  public:
  const ::openfga::v1::User& users(int index) const;
  ::openfga::v1::User* add_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::User >&
      users() const;

  // @@protoc_insertion_point(class_scope:openfga.v1.ListUsersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::User > users_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class StreamedListObjectsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.StreamedListObjectsRequest) */ {
 public:
  inline StreamedListObjectsRequest() : StreamedListObjectsRequest(nullptr) {}
  ~StreamedListObjectsRequest() override;
  explicit PROTOBUF_CONSTEXPR StreamedListObjectsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamedListObjectsRequest(const StreamedListObjectsRequest& from);
  StreamedListObjectsRequest(StreamedListObjectsRequest&& from) noexcept
    : StreamedListObjectsRequest() {
    *this = ::std::move(from);
  }

  inline StreamedListObjectsRequest& operator=(const StreamedListObjectsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamedListObjectsRequest& operator=(StreamedListObjectsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamedListObjectsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamedListObjectsRequest* internal_default_instance() {
    return reinterpret_cast<const StreamedListObjectsRequest*>(
               &_StreamedListObjectsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StreamedListObjectsRequest& a, StreamedListObjectsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamedListObjectsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamedListObjectsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamedListObjectsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamedListObjectsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamedListObjectsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamedListObjectsRequest& from) {
    StreamedListObjectsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamedListObjectsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.StreamedListObjectsRequest";
  }
  protected:
  explicit StreamedListObjectsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoreIdFieldNumber = 1,
    kAuthorizationModelIdFieldNumber = 2,
    kTypeFieldNumber = 3,
    kRelationFieldNumber = 4,
    kUserFieldNumber = 5,
    kContextualTuplesFieldNumber = 6,
    kContextFieldNumber = 7,
    kConsistencyFieldNumber = 8,
  };
  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_store_id();
  const std::string& store_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_id();
  PROTOBUF_NODISCARD std::string* release_store_id();
  void set_allocated_store_id(std::string* store_id);
  private:
  const std::string& _internal_store_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_id(const std::string& value);
  std::string* _internal_mutable_store_id();
  public:

  // string authorization_model_id = 2 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_authorization_model_id();
  const std::string& authorization_model_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_authorization_model_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_authorization_model_id();
  PROTOBUF_NODISCARD std::string* release_authorization_model_id();
  void set_allocated_authorization_model_id(std::string* authorization_model_id);
  private:
  const std::string& _internal_authorization_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authorization_model_id(const std::string& value);
  std::string* _internal_mutable_authorization_model_id();
  public:

  // string type = 3 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string relation = 4 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_relation();
  const std::string& relation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_relation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_relation();
  PROTOBUF_NODISCARD std::string* release_relation();
  void set_allocated_relation(std::string* relation);
  private:
  const std::string& _internal_relation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relation(const std::string& value);
  std::string* _internal_mutable_relation();
  public:

  // string user = 5 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // .openfga.v1.ContextualTupleKeys contextual_tuples = 6 [json_name = "contextual_tuples"];
  bool has_contextual_tuples() const;
  private:
  bool _internal_has_contextual_tuples() const;
  public:
  void clear_contextual_tuples();
  const ::openfga::v1::ContextualTupleKeys& contextual_tuples() const;
  PROTOBUF_NODISCARD ::openfga::v1::ContextualTupleKeys* release_contextual_tuples();
  ::openfga::v1::ContextualTupleKeys* mutable_contextual_tuples();
  void set_allocated_contextual_tuples(::openfga::v1::ContextualTupleKeys* contextual_tuples);
  private:
  const ::openfga::v1::ContextualTupleKeys& _internal_contextual_tuples() const;
  ::openfga::v1::ContextualTupleKeys* _internal_mutable_contextual_tuples();
  public:
  void unsafe_arena_set_allocated_contextual_tuples(
      ::openfga::v1::ContextualTupleKeys* contextual_tuples);
  ::openfga::v1::ContextualTupleKeys* unsafe_arena_release_contextual_tuples();

  // .google.protobuf.Struct context = 7 [json_name = "context"];
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::PROTOBUF_NAMESPACE_ID::Struct& context() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_context();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_context();
  void set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_context() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::PROTOBUF_NAMESPACE_ID::Struct* context);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_context();

  // .openfga.v1.ConsistencyPreference consistency = 8 [json_name = "consistency", (.validate.rules) = {
  void clear_consistency();
  ::openfga::v1::ConsistencyPreference consistency() const;
  void set_consistency(::openfga::v1::ConsistencyPreference value);
  private:
  ::openfga::v1::ConsistencyPreference _internal_consistency() const;
  void _internal_set_consistency(::openfga::v1::ConsistencyPreference value);
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.StreamedListObjectsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authorization_model_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    ::openfga::v1::ContextualTupleKeys* contextual_tuples_;
    ::PROTOBUF_NAMESPACE_ID::Struct* context_;
    int consistency_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class StreamedListObjectsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.StreamedListObjectsResponse) */ {
 public:
  inline StreamedListObjectsResponse() : StreamedListObjectsResponse(nullptr) {}
  ~StreamedListObjectsResponse() override;
  explicit PROTOBUF_CONSTEXPR StreamedListObjectsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamedListObjectsResponse(const StreamedListObjectsResponse& from);
  StreamedListObjectsResponse(StreamedListObjectsResponse&& from) noexcept
    : StreamedListObjectsResponse() {
    *this = ::std::move(from);
  }

  inline StreamedListObjectsResponse& operator=(const StreamedListObjectsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamedListObjectsResponse& operator=(StreamedListObjectsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamedListObjectsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamedListObjectsResponse* internal_default_instance() {
    return reinterpret_cast<const StreamedListObjectsResponse*>(
               &_StreamedListObjectsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StreamedListObjectsResponse& a, StreamedListObjectsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamedListObjectsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamedListObjectsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamedListObjectsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamedListObjectsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamedListObjectsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamedListObjectsResponse& from) {
    StreamedListObjectsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamedListObjectsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.StreamedListObjectsResponse";
  }
  protected:
  explicit StreamedListObjectsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
  };
  // string object = 1 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_object();
  const std::string& object() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_object(ArgT0&& arg0, ArgT... args);
  std::string* mutable_object();
  PROTOBUF_NODISCARD std::string* release_object();
  void set_allocated_object(std::string* object);
  private:
  const std::string& _internal_object() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object(const std::string& value);
  std::string* _internal_mutable_object();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.StreamedListObjectsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr object_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ReadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ReadRequest) */ {
 public:
  inline ReadRequest() : ReadRequest(nullptr) {}
  ~ReadRequest() override;
  explicit PROTOBUF_CONSTEXPR ReadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadRequest(const ReadRequest& from);
  ReadRequest(ReadRequest&& from) noexcept
    : ReadRequest() {
    *this = ::std::move(from);
  }

  inline ReadRequest& operator=(const ReadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadRequest& operator=(ReadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadRequest* internal_default_instance() {
    return reinterpret_cast<const ReadRequest*>(
               &_ReadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ReadRequest& a, ReadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadRequest& from) {
    ReadRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ReadRequest";
  }
  protected:
  explicit ReadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoreIdFieldNumber = 1,
    kContinuationTokenFieldNumber = 4,
    kTupleKeyFieldNumber = 2,
    kPageSizeFieldNumber = 3,
    kConsistencyFieldNumber = 5,
  };
  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_store_id();
  const std::string& store_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_id();
  PROTOBUF_NODISCARD std::string* release_store_id();
  void set_allocated_store_id(std::string* store_id);
  private:
  const std::string& _internal_store_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_id(const std::string& value);
  std::string* _internal_mutable_store_id();
  public:

  // string continuation_token = 4 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_continuation_token();
  const std::string& continuation_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_continuation_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_continuation_token();
  PROTOBUF_NODISCARD std::string* release_continuation_token();
  void set_allocated_continuation_token(std::string* continuation_token);
  private:
  const std::string& _internal_continuation_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_continuation_token(const std::string& value);
  std::string* _internal_mutable_continuation_token();
  public:

  // .openfga.v1.ReadRequestTupleKey tuple_key = 2 [json_name = "tuple_key"];
  bool has_tuple_key() const;
  private:
  bool _internal_has_tuple_key() const;
  public:
  void clear_tuple_key();
  const ::openfga::v1::ReadRequestTupleKey& tuple_key() const;
  PROTOBUF_NODISCARD ::openfga::v1::ReadRequestTupleKey* release_tuple_key();
  ::openfga::v1::ReadRequestTupleKey* mutable_tuple_key();
  void set_allocated_tuple_key(::openfga::v1::ReadRequestTupleKey* tuple_key);
  private:
  const ::openfga::v1::ReadRequestTupleKey& _internal_tuple_key() const;
  ::openfga::v1::ReadRequestTupleKey* _internal_mutable_tuple_key();
  public:
  void unsafe_arena_set_allocated_tuple_key(
      ::openfga::v1::ReadRequestTupleKey* tuple_key);
  ::openfga::v1::ReadRequestTupleKey* unsafe_arena_release_tuple_key();

  // .google.protobuf.Int32Value page_size = 3 [json_name = "page_size", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  bool has_page_size() const;
  private:
  bool _internal_has_page_size() const;
  public:
  void clear_page_size();
  const ::PROTOBUF_NAMESPACE_ID::Int32Value& page_size() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Int32Value* release_page_size();
  ::PROTOBUF_NAMESPACE_ID::Int32Value* mutable_page_size();
  void set_allocated_page_size(::PROTOBUF_NAMESPACE_ID::Int32Value* page_size);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Int32Value& _internal_page_size() const;
  ::PROTOBUF_NAMESPACE_ID::Int32Value* _internal_mutable_page_size();
  public:
  void unsafe_arena_set_allocated_page_size(
      ::PROTOBUF_NAMESPACE_ID::Int32Value* page_size);
  ::PROTOBUF_NAMESPACE_ID::Int32Value* unsafe_arena_release_page_size();

  // .openfga.v1.ConsistencyPreference consistency = 5 [json_name = "consistency", (.validate.rules) = {
  void clear_consistency();
  ::openfga::v1::ConsistencyPreference consistency() const;
  void set_consistency(::openfga::v1::ConsistencyPreference value);
  private:
  ::openfga::v1::ConsistencyPreference _internal_consistency() const;
  void _internal_set_consistency(::openfga::v1::ConsistencyPreference value);
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.ReadRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr continuation_token_;
    ::openfga::v1::ReadRequestTupleKey* tuple_key_;
    ::PROTOBUF_NAMESPACE_ID::Int32Value* page_size_;
    int consistency_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ReadRequestTupleKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ReadRequestTupleKey) */ {
 public:
  inline ReadRequestTupleKey() : ReadRequestTupleKey(nullptr) {}
  ~ReadRequestTupleKey() override;
  explicit PROTOBUF_CONSTEXPR ReadRequestTupleKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadRequestTupleKey(const ReadRequestTupleKey& from);
  ReadRequestTupleKey(ReadRequestTupleKey&& from) noexcept
    : ReadRequestTupleKey() {
    *this = ::std::move(from);
  }

  inline ReadRequestTupleKey& operator=(const ReadRequestTupleKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadRequestTupleKey& operator=(ReadRequestTupleKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadRequestTupleKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadRequestTupleKey* internal_default_instance() {
    return reinterpret_cast<const ReadRequestTupleKey*>(
               &_ReadRequestTupleKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ReadRequestTupleKey& a, ReadRequestTupleKey& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadRequestTupleKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadRequestTupleKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadRequestTupleKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadRequestTupleKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadRequestTupleKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadRequestTupleKey& from) {
    ReadRequestTupleKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadRequestTupleKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ReadRequestTupleKey";
  }
  protected:
  explicit ReadRequestTupleKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kRelationFieldNumber = 2,
    kObjectFieldNumber = 3,
  };
  // string user = 1 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_relation();
  const std::string& relation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_relation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_relation();
  PROTOBUF_NODISCARD std::string* release_relation();
  void set_allocated_relation(std::string* relation);
  private:
  const std::string& _internal_relation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relation(const std::string& value);
  std::string* _internal_mutable_relation();
  public:

  // string object = 3 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_object();
  const std::string& object() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_object(ArgT0&& arg0, ArgT... args);
  std::string* mutable_object();
  PROTOBUF_NODISCARD std::string* release_object();
  void set_allocated_object(std::string* object);
  private:
  const std::string& _internal_object() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object(const std::string& value);
  std::string* _internal_mutable_object();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.ReadRequestTupleKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr object_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ReadResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ReadResponse) */ {
 public:
  inline ReadResponse() : ReadResponse(nullptr) {}
  ~ReadResponse() override;
  explicit PROTOBUF_CONSTEXPR ReadResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadResponse(const ReadResponse& from);
  ReadResponse(ReadResponse&& from) noexcept
    : ReadResponse() {
    *this = ::std::move(from);
  }

  inline ReadResponse& operator=(const ReadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadResponse& operator=(ReadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadResponse* internal_default_instance() {
    return reinterpret_cast<const ReadResponse*>(
               &_ReadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ReadResponse& a, ReadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadResponse& from) {
    ReadResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ReadResponse";
  }
  protected:
  explicit ReadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTuplesFieldNumber = 1,
    kContinuationTokenFieldNumber = 2,
  };
  // repeated .openfga.v1.Tuple tuples = 1 [json_name = "tuples", (.google.api.field_behavior) = REQUIRED];
  int tuples_size() const;
  private:
  int _internal_tuples_size() const;
  public:
  void clear_tuples();
  ::openfga::v1::Tuple* mutable_tuples(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Tuple >*
      mutable_tuples();
  private:
  const ::openfga::v1::Tuple& _internal_tuples(int index) const;
  ::openfga::v1::Tuple* _internal_add_tuples();
  public:
  const ::openfga::v1::Tuple& tuples(int index) const;
  ::openfga::v1::Tuple* add_tuples();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Tuple >&
      tuples() const;

  // string continuation_token = 2 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_continuation_token();
  const std::string& continuation_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_continuation_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_continuation_token();
  PROTOBUF_NODISCARD std::string* release_continuation_token();
  void set_allocated_continuation_token(std::string* continuation_token);
  private:
  const std::string& _internal_continuation_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_continuation_token(const std::string& value);
  std::string* _internal_mutable_continuation_token();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.ReadResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Tuple > tuples_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr continuation_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class WriteRequestWrites final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.WriteRequestWrites) */ {
 public:
  inline WriteRequestWrites() : WriteRequestWrites(nullptr) {}
  ~WriteRequestWrites() override;
  explicit PROTOBUF_CONSTEXPR WriteRequestWrites(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteRequestWrites(const WriteRequestWrites& from);
  WriteRequestWrites(WriteRequestWrites&& from) noexcept
    : WriteRequestWrites() {
    *this = ::std::move(from);
  }

  inline WriteRequestWrites& operator=(const WriteRequestWrites& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteRequestWrites& operator=(WriteRequestWrites&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteRequestWrites& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteRequestWrites* internal_default_instance() {
    return reinterpret_cast<const WriteRequestWrites*>(
               &_WriteRequestWrites_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(WriteRequestWrites& a, WriteRequestWrites& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteRequestWrites* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteRequestWrites* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteRequestWrites* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteRequestWrites>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteRequestWrites& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WriteRequestWrites& from) {
    WriteRequestWrites::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteRequestWrites* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.WriteRequestWrites";
  }
  protected:
  explicit WriteRequestWrites(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTupleKeysFieldNumber = 1,
    kOnDuplicateFieldNumber = 2,
  };
  // repeated .openfga.v1.TupleKey tuple_keys = 1 [json_name = "tuple_keys", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int tuple_keys_size() const;
  private:
  int _internal_tuple_keys_size() const;
  public:
  void clear_tuple_keys();
  ::openfga::v1::TupleKey* mutable_tuple_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKey >*
      mutable_tuple_keys();
  private:
  const ::openfga::v1::TupleKey& _internal_tuple_keys(int index) const;
  ::openfga::v1::TupleKey* _internal_add_tuple_keys();
  public:
  const ::openfga::v1::TupleKey& tuple_keys(int index) const;
  ::openfga::v1::TupleKey* add_tuple_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKey >&
      tuple_keys() const;

  // string on_duplicate = 2 [json_name = "on_duplicate", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_on_duplicate();
  const std::string& on_duplicate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_on_duplicate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_on_duplicate();
  PROTOBUF_NODISCARD std::string* release_on_duplicate();
  void set_allocated_on_duplicate(std::string* on_duplicate);
  private:
  const std::string& _internal_on_duplicate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_on_duplicate(const std::string& value);
  std::string* _internal_mutable_on_duplicate();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.WriteRequestWrites)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKey > tuple_keys_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr on_duplicate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class WriteRequestDeletes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.WriteRequestDeletes) */ {
 public:
  inline WriteRequestDeletes() : WriteRequestDeletes(nullptr) {}
  ~WriteRequestDeletes() override;
  explicit PROTOBUF_CONSTEXPR WriteRequestDeletes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteRequestDeletes(const WriteRequestDeletes& from);
  WriteRequestDeletes(WriteRequestDeletes&& from) noexcept
    : WriteRequestDeletes() {
    *this = ::std::move(from);
  }

  inline WriteRequestDeletes& operator=(const WriteRequestDeletes& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteRequestDeletes& operator=(WriteRequestDeletes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteRequestDeletes& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteRequestDeletes* internal_default_instance() {
    return reinterpret_cast<const WriteRequestDeletes*>(
               &_WriteRequestDeletes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(WriteRequestDeletes& a, WriteRequestDeletes& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteRequestDeletes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteRequestDeletes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteRequestDeletes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteRequestDeletes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteRequestDeletes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WriteRequestDeletes& from) {
    WriteRequestDeletes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteRequestDeletes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.WriteRequestDeletes";
  }
  protected:
  explicit WriteRequestDeletes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTupleKeysFieldNumber = 1,
    kOnMissingFieldNumber = 2,
  };
  // repeated .openfga.v1.TupleKeyWithoutCondition tuple_keys = 1 [json_name = "tuple_keys", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int tuple_keys_size() const;
  private:
  int _internal_tuple_keys_size() const;
  public:
  void clear_tuple_keys();
  ::openfga::v1::TupleKeyWithoutCondition* mutable_tuple_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKeyWithoutCondition >*
      mutable_tuple_keys();
  private:
  const ::openfga::v1::TupleKeyWithoutCondition& _internal_tuple_keys(int index) const;
  ::openfga::v1::TupleKeyWithoutCondition* _internal_add_tuple_keys();
  public:
  const ::openfga::v1::TupleKeyWithoutCondition& tuple_keys(int index) const;
  ::openfga::v1::TupleKeyWithoutCondition* add_tuple_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKeyWithoutCondition >&
      tuple_keys() const;

  // string on_missing = 2 [json_name = "on_missing", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_on_missing();
  const std::string& on_missing() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_on_missing(ArgT0&& arg0, ArgT... args);
  std::string* mutable_on_missing();
  PROTOBUF_NODISCARD std::string* release_on_missing();
  void set_allocated_on_missing(std::string* on_missing);
  private:
  const std::string& _internal_on_missing() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_on_missing(const std::string& value);
  std::string* _internal_mutable_on_missing();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.WriteRequestDeletes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKeyWithoutCondition > tuple_keys_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr on_missing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class WriteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.WriteRequest) */ {
 public:
  inline WriteRequest() : WriteRequest(nullptr) {}
  ~WriteRequest() override;
  explicit PROTOBUF_CONSTEXPR WriteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteRequest(const WriteRequest& from);
  WriteRequest(WriteRequest&& from) noexcept
    : WriteRequest() {
    *this = ::std::move(from);
  }

  inline WriteRequest& operator=(const WriteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteRequest& operator=(WriteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteRequest* internal_default_instance() {
    return reinterpret_cast<const WriteRequest*>(
               &_WriteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(WriteRequest& a, WriteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WriteRequest& from) {
    WriteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.WriteRequest";
  }
  protected:
  explicit WriteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoreIdFieldNumber = 1,
    kAuthorizationModelIdFieldNumber = 4,
    kWritesFieldNumber = 2,
    kDeletesFieldNumber = 3,
  };
  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_store_id();
  const std::string& store_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_id();
  PROTOBUF_NODISCARD std::string* release_store_id();
  void set_allocated_store_id(std::string* store_id);
  private:
  const std::string& _internal_store_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_id(const std::string& value);
  std::string* _internal_mutable_store_id();
  public:

  // string authorization_model_id = 4 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_authorization_model_id();
  const std::string& authorization_model_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_authorization_model_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_authorization_model_id();
  PROTOBUF_NODISCARD std::string* release_authorization_model_id();
  void set_allocated_authorization_model_id(std::string* authorization_model_id);
  private:
  const std::string& _internal_authorization_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authorization_model_id(const std::string& value);
  std::string* _internal_mutable_authorization_model_id();
  public:

  // .openfga.v1.WriteRequestWrites writes = 2 [json_name = "writes"];
  bool has_writes() const;
  private:
  bool _internal_has_writes() const;
  public:
  void clear_writes();
  const ::openfga::v1::WriteRequestWrites& writes() const;
  PROTOBUF_NODISCARD ::openfga::v1::WriteRequestWrites* release_writes();
  ::openfga::v1::WriteRequestWrites* mutable_writes();
  void set_allocated_writes(::openfga::v1::WriteRequestWrites* writes);
  private:
  const ::openfga::v1::WriteRequestWrites& _internal_writes() const;
  ::openfga::v1::WriteRequestWrites* _internal_mutable_writes();
  public:
  void unsafe_arena_set_allocated_writes(
      ::openfga::v1::WriteRequestWrites* writes);
  ::openfga::v1::WriteRequestWrites* unsafe_arena_release_writes();

  // .openfga.v1.WriteRequestDeletes deletes = 3 [json_name = "deletes"];
  bool has_deletes() const;
  private:
  bool _internal_has_deletes() const;
  public:
  void clear_deletes();
  const ::openfga::v1::WriteRequestDeletes& deletes() const;
  PROTOBUF_NODISCARD ::openfga::v1::WriteRequestDeletes* release_deletes();
  ::openfga::v1::WriteRequestDeletes* mutable_deletes();
  void set_allocated_deletes(::openfga::v1::WriteRequestDeletes* deletes);
  private:
  const ::openfga::v1::WriteRequestDeletes& _internal_deletes() const;
  ::openfga::v1::WriteRequestDeletes* _internal_mutable_deletes();
  public:
  void unsafe_arena_set_allocated_deletes(
      ::openfga::v1::WriteRequestDeletes* deletes);
  ::openfga::v1::WriteRequestDeletes* unsafe_arena_release_deletes();

  // @@protoc_insertion_point(class_scope:openfga.v1.WriteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authorization_model_id_;
    ::openfga::v1::WriteRequestWrites* writes_;
    ::openfga::v1::WriteRequestDeletes* deletes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class WriteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:openfga.v1.WriteResponse) */ {
 public:
  inline WriteResponse() : WriteResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR WriteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteResponse(const WriteResponse& from);
  WriteResponse(WriteResponse&& from) noexcept
    : WriteResponse() {
    *this = ::std::move(from);
  }

  inline WriteResponse& operator=(const WriteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteResponse& operator=(WriteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteResponse* internal_default_instance() {
    return reinterpret_cast<const WriteResponse*>(
               &_WriteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(WriteResponse& a, WriteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const WriteResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const WriteResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.WriteResponse";
  }
  protected:
  explicit WriteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:openfga.v1.WriteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CheckRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.CheckRequest) */ {
 public:
  inline CheckRequest() : CheckRequest(nullptr) {}
  ~CheckRequest() override;
  explicit PROTOBUF_CONSTEXPR CheckRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckRequest(const CheckRequest& from);
  CheckRequest(CheckRequest&& from) noexcept
    : CheckRequest() {
    *this = ::std::move(from);
  }

  inline CheckRequest& operator=(const CheckRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckRequest& operator=(CheckRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckRequest* internal_default_instance() {
    return reinterpret_cast<const CheckRequest*>(
               &_CheckRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CheckRequest& a, CheckRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CheckRequest& from) {
    CheckRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.CheckRequest";
  }
  protected:
  explicit CheckRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoreIdFieldNumber = 1,
    kAuthorizationModelIdFieldNumber = 4,
    kTupleKeyFieldNumber = 2,
    kContextualTuplesFieldNumber = 3,
    kContextFieldNumber = 6,
    kTraceFieldNumber = 5,
    kConsistencyFieldNumber = 7,
  };
  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_store_id();
  const std::string& store_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_id();
  PROTOBUF_NODISCARD std::string* release_store_id();
  void set_allocated_store_id(std::string* store_id);
  private:
  const std::string& _internal_store_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_id(const std::string& value);
  std::string* _internal_mutable_store_id();
  public:

  // string authorization_model_id = 4 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_authorization_model_id();
  const std::string& authorization_model_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_authorization_model_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_authorization_model_id();
  PROTOBUF_NODISCARD std::string* release_authorization_model_id();
  void set_allocated_authorization_model_id(std::string* authorization_model_id);
  private:
  const std::string& _internal_authorization_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authorization_model_id(const std::string& value);
  std::string* _internal_mutable_authorization_model_id();
  public:

  // .openfga.v1.CheckRequestTupleKey tuple_key = 2 [json_name = "tuple_key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_tuple_key() const;
  private:
  bool _internal_has_tuple_key() const;
  public:
  void clear_tuple_key();
  const ::openfga::v1::CheckRequestTupleKey& tuple_key() const;
  PROTOBUF_NODISCARD ::openfga::v1::CheckRequestTupleKey* release_tuple_key();
  ::openfga::v1::CheckRequestTupleKey* mutable_tuple_key();
  void set_allocated_tuple_key(::openfga::v1::CheckRequestTupleKey* tuple_key);
  private:
  const ::openfga::v1::CheckRequestTupleKey& _internal_tuple_key() const;
  ::openfga::v1::CheckRequestTupleKey* _internal_mutable_tuple_key();
  public:
  void unsafe_arena_set_allocated_tuple_key(
      ::openfga::v1::CheckRequestTupleKey* tuple_key);
  ::openfga::v1::CheckRequestTupleKey* unsafe_arena_release_tuple_key();

  // .openfga.v1.ContextualTupleKeys contextual_tuples = 3 [json_name = "contextual_tuples"];
  bool has_contextual_tuples() const;
  private:
  bool _internal_has_contextual_tuples() const;
  public:
  void clear_contextual_tuples();
  const ::openfga::v1::ContextualTupleKeys& contextual_tuples() const;
  PROTOBUF_NODISCARD ::openfga::v1::ContextualTupleKeys* release_contextual_tuples();
  ::openfga::v1::ContextualTupleKeys* mutable_contextual_tuples();
  void set_allocated_contextual_tuples(::openfga::v1::ContextualTupleKeys* contextual_tuples);
  private:
  const ::openfga::v1::ContextualTupleKeys& _internal_contextual_tuples() const;
  ::openfga::v1::ContextualTupleKeys* _internal_mutable_contextual_tuples();
  public:
  void unsafe_arena_set_allocated_contextual_tuples(
      ::openfga::v1::ContextualTupleKeys* contextual_tuples);
  ::openfga::v1::ContextualTupleKeys* unsafe_arena_release_contextual_tuples();

  // .google.protobuf.Struct context = 6 [json_name = "context"];
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::PROTOBUF_NAMESPACE_ID::Struct& context() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_context();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_context();
  void set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_context() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::PROTOBUF_NAMESPACE_ID::Struct* context);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_context();

  // bool trace = 5 [json_name = "trace", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_trace();
  bool trace() const;
  void set_trace(bool value);
  private:
  bool _internal_trace() const;
  void _internal_set_trace(bool value);
  public:

  // .openfga.v1.ConsistencyPreference consistency = 7 [json_name = "consistency", (.validate.rules) = {
  void clear_consistency();
  ::openfga::v1::ConsistencyPreference consistency() const;
  void set_consistency(::openfga::v1::ConsistencyPreference value);
  private:
  ::openfga::v1::ConsistencyPreference _internal_consistency() const;
  void _internal_set_consistency(::openfga::v1::ConsistencyPreference value);
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.CheckRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authorization_model_id_;
    ::openfga::v1::CheckRequestTupleKey* tuple_key_;
    ::openfga::v1::ContextualTupleKeys* contextual_tuples_;
    ::PROTOBUF_NAMESPACE_ID::Struct* context_;
    bool trace_;
    int consistency_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CheckRequestTupleKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.CheckRequestTupleKey) */ {
 public:
  inline CheckRequestTupleKey() : CheckRequestTupleKey(nullptr) {}
  ~CheckRequestTupleKey() override;
  explicit PROTOBUF_CONSTEXPR CheckRequestTupleKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckRequestTupleKey(const CheckRequestTupleKey& from);
  CheckRequestTupleKey(CheckRequestTupleKey&& from) noexcept
    : CheckRequestTupleKey() {
    *this = ::std::move(from);
  }

  inline CheckRequestTupleKey& operator=(const CheckRequestTupleKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckRequestTupleKey& operator=(CheckRequestTupleKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckRequestTupleKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckRequestTupleKey* internal_default_instance() {
    return reinterpret_cast<const CheckRequestTupleKey*>(
               &_CheckRequestTupleKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CheckRequestTupleKey& a, CheckRequestTupleKey& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckRequestTupleKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckRequestTupleKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckRequestTupleKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckRequestTupleKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckRequestTupleKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CheckRequestTupleKey& from) {
    CheckRequestTupleKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckRequestTupleKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.CheckRequestTupleKey";
  }
  protected:
  explicit CheckRequestTupleKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kRelationFieldNumber = 2,
    kObjectFieldNumber = 3,
  };
  // string user = 1 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_relation();
  const std::string& relation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_relation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_relation();
  PROTOBUF_NODISCARD std::string* release_relation();
  void set_allocated_relation(std::string* relation);
  private:
  const std::string& _internal_relation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relation(const std::string& value);
  std::string* _internal_mutable_relation();
  public:

  // string object = 3 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_object();
  const std::string& object() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_object(ArgT0&& arg0, ArgT... args);
  std::string* mutable_object();
  PROTOBUF_NODISCARD std::string* release_object();
  void set_allocated_object(std::string* object);
  private:
  const std::string& _internal_object() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object(const std::string& value);
  std::string* _internal_mutable_object();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.CheckRequestTupleKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr object_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CheckResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.CheckResponse) */ {
 public:
  inline CheckResponse() : CheckResponse(nullptr) {}
  ~CheckResponse() override;
  explicit PROTOBUF_CONSTEXPR CheckResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckResponse(const CheckResponse& from);
  CheckResponse(CheckResponse&& from) noexcept
    : CheckResponse() {
    *this = ::std::move(from);
  }

  inline CheckResponse& operator=(const CheckResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckResponse& operator=(CheckResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckResponse* internal_default_instance() {
    return reinterpret_cast<const CheckResponse*>(
               &_CheckResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CheckResponse& a, CheckResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CheckResponse& from) {
    CheckResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.CheckResponse";
  }
  protected:
  explicit CheckResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResolutionFieldNumber = 2,
    kAllowedFieldNumber = 1,
  };
  // string resolution = 2 [json_name = "resolution"];
  void clear_resolution();
  const std::string& resolution() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resolution(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resolution();
  PROTOBUF_NODISCARD std::string* release_resolution();
  void set_allocated_resolution(std::string* resolution);
  private:
  const std::string& _internal_resolution() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resolution(const std::string& value);
  std::string* _internal_mutable_resolution();
  public:

  // bool allowed = 1 [json_name = "allowed", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_allowed();
  bool allowed() const;
  void set_allowed(bool value);
  private:
  bool _internal_allowed() const;
  void _internal_set_allowed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.CheckResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resolution_;
    bool allowed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class BatchCheckRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.BatchCheckRequest) */ {
 public:
  inline BatchCheckRequest() : BatchCheckRequest(nullptr) {}
  ~BatchCheckRequest() override;
  explicit PROTOBUF_CONSTEXPR BatchCheckRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchCheckRequest(const BatchCheckRequest& from);
  BatchCheckRequest(BatchCheckRequest&& from) noexcept
    : BatchCheckRequest() {
    *this = ::std::move(from);
  }

  inline BatchCheckRequest& operator=(const BatchCheckRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchCheckRequest& operator=(BatchCheckRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchCheckRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchCheckRequest* internal_default_instance() {
    return reinterpret_cast<const BatchCheckRequest*>(
               &_BatchCheckRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(BatchCheckRequest& a, BatchCheckRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchCheckRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchCheckRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchCheckRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchCheckRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchCheckRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchCheckRequest& from) {
    BatchCheckRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchCheckRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.BatchCheckRequest";
  }
  protected:
  explicit BatchCheckRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChecksFieldNumber = 2,
    kStoreIdFieldNumber = 1,
    kAuthorizationModelIdFieldNumber = 3,
    kConsistencyFieldNumber = 4,
  };
  // repeated .openfga.v1.BatchCheckItem checks = 2 [json_name = "checks", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int checks_size() const;
  private:
  int _internal_checks_size() const;
  public:
  void clear_checks();
  ::openfga::v1::BatchCheckItem* mutable_checks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::BatchCheckItem >*
      mutable_checks();
  private:
  const ::openfga::v1::BatchCheckItem& _internal_checks(int index) const;
  ::openfga::v1::BatchCheckItem* _internal_add_checks();
  public:
  const ::openfga::v1::BatchCheckItem& checks(int index) const;
  ::openfga::v1::BatchCheckItem* add_checks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::BatchCheckItem >&
      checks() const;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_store_id();
  const std::string& store_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_id();
  PROTOBUF_NODISCARD std::string* release_store_id();
  void set_allocated_store_id(std::string* store_id);
  private:
  const std::string& _internal_store_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_id(const std::string& value);
  std::string* _internal_mutable_store_id();
  public:

  // string authorization_model_id = 3 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_authorization_model_id();
  const std::string& authorization_model_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_authorization_model_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_authorization_model_id();
  PROTOBUF_NODISCARD std::string* release_authorization_model_id();
  void set_allocated_authorization_model_id(std::string* authorization_model_id);
  private:
  const std::string& _internal_authorization_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authorization_model_id(const std::string& value);
  std::string* _internal_mutable_authorization_model_id();
  public:

  // .openfga.v1.ConsistencyPreference consistency = 4 [json_name = "consistency", (.validate.rules) = {
  void clear_consistency();
  ::openfga::v1::ConsistencyPreference consistency() const;
  void set_consistency(::openfga::v1::ConsistencyPreference value);
  private:
  ::openfga::v1::ConsistencyPreference _internal_consistency() const;
  void _internal_set_consistency(::openfga::v1::ConsistencyPreference value);
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.BatchCheckRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::BatchCheckItem > checks_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authorization_model_id_;
    int consistency_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class BatchCheckItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.BatchCheckItem) */ {
 public:
  inline BatchCheckItem() : BatchCheckItem(nullptr) {}
  ~BatchCheckItem() override;
  explicit PROTOBUF_CONSTEXPR BatchCheckItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchCheckItem(const BatchCheckItem& from);
  BatchCheckItem(BatchCheckItem&& from) noexcept
    : BatchCheckItem() {
    *this = ::std::move(from);
  }

  inline BatchCheckItem& operator=(const BatchCheckItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchCheckItem& operator=(BatchCheckItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchCheckItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchCheckItem* internal_default_instance() {
    return reinterpret_cast<const BatchCheckItem*>(
               &_BatchCheckItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(BatchCheckItem& a, BatchCheckItem& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchCheckItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchCheckItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchCheckItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchCheckItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchCheckItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchCheckItem& from) {
    BatchCheckItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchCheckItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.BatchCheckItem";
  }
  protected:
  explicit BatchCheckItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCorrelationIdFieldNumber = 4,
    kTupleKeyFieldNumber = 1,
    kContextualTuplesFieldNumber = 2,
    kContextFieldNumber = 3,
  };
  // string correlation_id = 4 [json_name = "correlation_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_correlation_id();
  const std::string& correlation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_correlation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_correlation_id();
  PROTOBUF_NODISCARD std::string* release_correlation_id();
  void set_allocated_correlation_id(std::string* correlation_id);
  private:
  const std::string& _internal_correlation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_correlation_id(const std::string& value);
  std::string* _internal_mutable_correlation_id();
  public:

  // .openfga.v1.CheckRequestTupleKey tuple_key = 1 [json_name = "tuple_key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_tuple_key() const;
  private:
  bool _internal_has_tuple_key() const;
  public:
  void clear_tuple_key();
  const ::openfga::v1::CheckRequestTupleKey& tuple_key() const;
  PROTOBUF_NODISCARD ::openfga::v1::CheckRequestTupleKey* release_tuple_key();
  ::openfga::v1::CheckRequestTupleKey* mutable_tuple_key();
  void set_allocated_tuple_key(::openfga::v1::CheckRequestTupleKey* tuple_key);
  private:
  const ::openfga::v1::CheckRequestTupleKey& _internal_tuple_key() const;
  ::openfga::v1::CheckRequestTupleKey* _internal_mutable_tuple_key();
  public:
  void unsafe_arena_set_allocated_tuple_key(
      ::openfga::v1::CheckRequestTupleKey* tuple_key);
  ::openfga::v1::CheckRequestTupleKey* unsafe_arena_release_tuple_key();

  // .openfga.v1.ContextualTupleKeys contextual_tuples = 2 [json_name = "contextual_tuples"];
  bool has_contextual_tuples() const;
  private:
  bool _internal_has_contextual_tuples() const;
  public:
  void clear_contextual_tuples();
  const ::openfga::v1::ContextualTupleKeys& contextual_tuples() const;
  PROTOBUF_NODISCARD ::openfga::v1::ContextualTupleKeys* release_contextual_tuples();
  ::openfga::v1::ContextualTupleKeys* mutable_contextual_tuples();
  void set_allocated_contextual_tuples(::openfga::v1::ContextualTupleKeys* contextual_tuples);
  private:
  const ::openfga::v1::ContextualTupleKeys& _internal_contextual_tuples() const;
  ::openfga::v1::ContextualTupleKeys* _internal_mutable_contextual_tuples();
  public:
  void unsafe_arena_set_allocated_contextual_tuples(
      ::openfga::v1::ContextualTupleKeys* contextual_tuples);
  ::openfga::v1::ContextualTupleKeys* unsafe_arena_release_contextual_tuples();

  // .google.protobuf.Struct context = 3 [json_name = "context"];
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::PROTOBUF_NAMESPACE_ID::Struct& context() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_context();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_context();
  void set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_context() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::PROTOBUF_NAMESPACE_ID::Struct* context);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_context();

  // @@protoc_insertion_point(class_scope:openfga.v1.BatchCheckItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr correlation_id_;
    ::openfga::v1::CheckRequestTupleKey* tuple_key_;
    ::openfga::v1::ContextualTupleKeys* contextual_tuples_;
    ::PROTOBUF_NAMESPACE_ID::Struct* context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class BatchCheckResponse_ResultEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BatchCheckResponse_ResultEntry_DoNotUse, 
    std::string, ::openfga::v1::BatchCheckSingleResult,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BatchCheckResponse_ResultEntry_DoNotUse, 
    std::string, ::openfga::v1::BatchCheckSingleResult,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  BatchCheckResponse_ResultEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR BatchCheckResponse_ResultEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit BatchCheckResponse_ResultEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const BatchCheckResponse_ResultEntry_DoNotUse& other);
  static const BatchCheckResponse_ResultEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const BatchCheckResponse_ResultEntry_DoNotUse*>(&_BatchCheckResponse_ResultEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "openfga.v1.BatchCheckResponse.ResultEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};

// -------------------------------------------------------------------

class BatchCheckResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.BatchCheckResponse) */ {
 public:
  inline BatchCheckResponse() : BatchCheckResponse(nullptr) {}
  ~BatchCheckResponse() override;
  explicit PROTOBUF_CONSTEXPR BatchCheckResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchCheckResponse(const BatchCheckResponse& from);
  BatchCheckResponse(BatchCheckResponse&& from) noexcept
    : BatchCheckResponse() {
    *this = ::std::move(from);
  }

  inline BatchCheckResponse& operator=(const BatchCheckResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchCheckResponse& operator=(BatchCheckResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchCheckResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchCheckResponse* internal_default_instance() {
    return reinterpret_cast<const BatchCheckResponse*>(
               &_BatchCheckResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(BatchCheckResponse& a, BatchCheckResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchCheckResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchCheckResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchCheckResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchCheckResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchCheckResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchCheckResponse& from) {
    BatchCheckResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchCheckResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.BatchCheckResponse";
  }
  protected:
  explicit BatchCheckResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // map<string, .openfga.v1.BatchCheckSingleResult> result = 1 [json_name = "result", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int result_size() const;
  private:
  int _internal_result_size() const;
  public:
  void clear_result();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::BatchCheckSingleResult >&
      _internal_result() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::BatchCheckSingleResult >*
      _internal_mutable_result();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::BatchCheckSingleResult >&
      result() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::BatchCheckSingleResult >*
      mutable_result();

  // @@protoc_insertion_point(class_scope:openfga.v1.BatchCheckResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        BatchCheckResponse_ResultEntry_DoNotUse,
        std::string, ::openfga::v1::BatchCheckSingleResult,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class BatchCheckSingleResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.BatchCheckSingleResult) */ {
 public:
  inline BatchCheckSingleResult() : BatchCheckSingleResult(nullptr) {}
  ~BatchCheckSingleResult() override;
  explicit PROTOBUF_CONSTEXPR BatchCheckSingleResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchCheckSingleResult(const BatchCheckSingleResult& from);
  BatchCheckSingleResult(BatchCheckSingleResult&& from) noexcept
    : BatchCheckSingleResult() {
    *this = ::std::move(from);
  }

  inline BatchCheckSingleResult& operator=(const BatchCheckSingleResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchCheckSingleResult& operator=(BatchCheckSingleResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchCheckSingleResult& default_instance() {
    return *internal_default_instance();
  }
  enum CheckResultCase {
    kAllowed = 1,
    kError = 2,
    CHECK_RESULT_NOT_SET = 0,
  };

  static inline const BatchCheckSingleResult* internal_default_instance() {
    return reinterpret_cast<const BatchCheckSingleResult*>(
               &_BatchCheckSingleResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(BatchCheckSingleResult& a, BatchCheckSingleResult& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchCheckSingleResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchCheckSingleResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchCheckSingleResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchCheckSingleResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchCheckSingleResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchCheckSingleResult& from) {
    BatchCheckSingleResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchCheckSingleResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.BatchCheckSingleResult";
  }
  protected:
  explicit BatchCheckSingleResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowedFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // bool allowed = 1 [json_name = "allowed"];
  bool has_allowed() const;
  private:
  bool _internal_has_allowed() const;
  public:
  void clear_allowed();
  bool allowed() const;
  void set_allowed(bool value);
  private:
  bool _internal_allowed() const;
  void _internal_set_allowed(bool value);
  public:

  // .openfga.v1.CheckError error = 2 [json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::openfga::v1::CheckError& error() const;
  PROTOBUF_NODISCARD ::openfga::v1::CheckError* release_error();
  ::openfga::v1::CheckError* mutable_error();
  void set_allocated_error(::openfga::v1::CheckError* error);
  private:
  const ::openfga::v1::CheckError& _internal_error() const;
  ::openfga::v1::CheckError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::openfga::v1::CheckError* error);
  ::openfga::v1::CheckError* unsafe_arena_release_error();

  void clear_check_result();
  CheckResultCase check_result_case() const;
  // @@protoc_insertion_point(class_scope:openfga.v1.BatchCheckSingleResult)
 private:
  class _Internal;
  void set_has_allowed();
  void set_has_error();

  inline bool has_check_result() const;
  inline void clear_has_check_result();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union CheckResultUnion {
      constexpr CheckResultUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool allowed_;
      ::openfga::v1::CheckError* error_;
    } check_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CheckError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.CheckError) */ {
 public:
  inline CheckError() : CheckError(nullptr) {}
  ~CheckError() override;
  explicit PROTOBUF_CONSTEXPR CheckError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckError(const CheckError& from);
  CheckError(CheckError&& from) noexcept
    : CheckError() {
    *this = ::std::move(from);
  }

  inline CheckError& operator=(const CheckError& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckError& operator=(CheckError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckError& default_instance() {
    return *internal_default_instance();
  }
  enum CodeCase {
    kInputError = 1,
    kInternalError = 2,
    CODE_NOT_SET = 0,
  };

  static inline const CheckError* internal_default_instance() {
    return reinterpret_cast<const CheckError*>(
               &_CheckError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CheckError& a, CheckError& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CheckError& from) {
    CheckError::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.CheckError";
  }
  protected:
  explicit CheckError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kInputErrorFieldNumber = 1,
    kInternalErrorFieldNumber = 2,
  };
  // string message = 3 [json_name = "message"];
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .openfga.v1.ErrorCode input_error = 1 [json_name = "input_error"];
  bool has_input_error() const;
  private:
  bool _internal_has_input_error() const;
  public:
  void clear_input_error();
  ::openfga::v1::ErrorCode input_error() const;
  void set_input_error(::openfga::v1::ErrorCode value);
  private:
  ::openfga::v1::ErrorCode _internal_input_error() const;
  void _internal_set_input_error(::openfga::v1::ErrorCode value);
  public:

  // .openfga.v1.InternalErrorCode internal_error = 2 [json_name = "internal_error"];
  bool has_internal_error() const;
  private:
  bool _internal_has_internal_error() const;
  public:
  void clear_internal_error();
  ::openfga::v1::InternalErrorCode internal_error() const;
  void set_internal_error(::openfga::v1::InternalErrorCode value);
  private:
  ::openfga::v1::InternalErrorCode _internal_internal_error() const;
  void _internal_set_internal_error(::openfga::v1::InternalErrorCode value);
  public:

  void clear_code();
  CodeCase code_case() const;
  // @@protoc_insertion_point(class_scope:openfga.v1.CheckError)
 private:
  class _Internal;
  void set_has_input_error();
  void set_has_internal_error();

  inline bool has_code() const;
  inline void clear_has_code();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    union CodeUnion {
      constexpr CodeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int input_error_;
      int internal_error_;
    } code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ExpandRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ExpandRequest) */ {
 public:
  inline ExpandRequest() : ExpandRequest(nullptr) {}
  ~ExpandRequest() override;
  explicit PROTOBUF_CONSTEXPR ExpandRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExpandRequest(const ExpandRequest& from);
  ExpandRequest(ExpandRequest&& from) noexcept
    : ExpandRequest() {
    *this = ::std::move(from);
  }

  inline ExpandRequest& operator=(const ExpandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpandRequest& operator=(ExpandRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpandRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExpandRequest* internal_default_instance() {
    return reinterpret_cast<const ExpandRequest*>(
               &_ExpandRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ExpandRequest& a, ExpandRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExpandRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpandRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpandRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExpandRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExpandRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExpandRequest& from) {
    ExpandRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExpandRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ExpandRequest";
  }
  protected:
  explicit ExpandRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoreIdFieldNumber = 1,
    kAuthorizationModelIdFieldNumber = 3,
    kTupleKeyFieldNumber = 2,
    kContextualTuplesFieldNumber = 5,
    kConsistencyFieldNumber = 4,
  };
  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_store_id();
  const std::string& store_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_id();
  PROTOBUF_NODISCARD std::string* release_store_id();
  void set_allocated_store_id(std::string* store_id);
  private:
  const std::string& _internal_store_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_id(const std::string& value);
  std::string* _internal_mutable_store_id();
  public:

  // string authorization_model_id = 3 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_authorization_model_id();
  const std::string& authorization_model_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_authorization_model_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_authorization_model_id();
  PROTOBUF_NODISCARD std::string* release_authorization_model_id();
  void set_allocated_authorization_model_id(std::string* authorization_model_id);
  private:
  const std::string& _internal_authorization_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authorization_model_id(const std::string& value);
  std::string* _internal_mutable_authorization_model_id();
  public:

  // .openfga.v1.ExpandRequestTupleKey tuple_key = 2 [json_name = "tuple_key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_tuple_key() const;
  private:
  bool _internal_has_tuple_key() const;
  public:
  void clear_tuple_key();
  const ::openfga::v1::ExpandRequestTupleKey& tuple_key() const;
  PROTOBUF_NODISCARD ::openfga::v1::ExpandRequestTupleKey* release_tuple_key();
  ::openfga::v1::ExpandRequestTupleKey* mutable_tuple_key();
  void set_allocated_tuple_key(::openfga::v1::ExpandRequestTupleKey* tuple_key);
  private:
  const ::openfga::v1::ExpandRequestTupleKey& _internal_tuple_key() const;
  ::openfga::v1::ExpandRequestTupleKey* _internal_mutable_tuple_key();
  public:
  void unsafe_arena_set_allocated_tuple_key(
      ::openfga::v1::ExpandRequestTupleKey* tuple_key);
  ::openfga::v1::ExpandRequestTupleKey* unsafe_arena_release_tuple_key();

  // .openfga.v1.ContextualTupleKeys contextual_tuples = 5 [json_name = "contextual_tuples"];
  bool has_contextual_tuples() const;
  private:
  bool _internal_has_contextual_tuples() const;
  public:
  void clear_contextual_tuples();
  const ::openfga::v1::ContextualTupleKeys& contextual_tuples() const;
  PROTOBUF_NODISCARD ::openfga::v1::ContextualTupleKeys* release_contextual_tuples();
  ::openfga::v1::ContextualTupleKeys* mutable_contextual_tuples();
  void set_allocated_contextual_tuples(::openfga::v1::ContextualTupleKeys* contextual_tuples);
  private:
  const ::openfga::v1::ContextualTupleKeys& _internal_contextual_tuples() const;
  ::openfga::v1::ContextualTupleKeys* _internal_mutable_contextual_tuples();
  public:
  void unsafe_arena_set_allocated_contextual_tuples(
      ::openfga::v1::ContextualTupleKeys* contextual_tuples);
  ::openfga::v1::ContextualTupleKeys* unsafe_arena_release_contextual_tuples();

  // .openfga.v1.ConsistencyPreference consistency = 4 [json_name = "consistency", (.validate.rules) = {
  void clear_consistency();
  ::openfga::v1::ConsistencyPreference consistency() const;
  void set_consistency(::openfga::v1::ConsistencyPreference value);
  private:
  ::openfga::v1::ConsistencyPreference _internal_consistency() const;
  void _internal_set_consistency(::openfga::v1::ConsistencyPreference value);
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.ExpandRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authorization_model_id_;
    ::openfga::v1::ExpandRequestTupleKey* tuple_key_;
    ::openfga::v1::ContextualTupleKeys* contextual_tuples_;
    int consistency_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ExpandRequestTupleKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ExpandRequestTupleKey) */ {
 public:
  inline ExpandRequestTupleKey() : ExpandRequestTupleKey(nullptr) {}
  ~ExpandRequestTupleKey() override;
  explicit PROTOBUF_CONSTEXPR ExpandRequestTupleKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExpandRequestTupleKey(const ExpandRequestTupleKey& from);
  ExpandRequestTupleKey(ExpandRequestTupleKey&& from) noexcept
    : ExpandRequestTupleKey() {
    *this = ::std::move(from);
  }

  inline ExpandRequestTupleKey& operator=(const ExpandRequestTupleKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpandRequestTupleKey& operator=(ExpandRequestTupleKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpandRequestTupleKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExpandRequestTupleKey* internal_default_instance() {
    return reinterpret_cast<const ExpandRequestTupleKey*>(
               &_ExpandRequestTupleKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ExpandRequestTupleKey& a, ExpandRequestTupleKey& b) {
    a.Swap(&b);
  }
  inline void Swap(ExpandRequestTupleKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpandRequestTupleKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpandRequestTupleKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExpandRequestTupleKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExpandRequestTupleKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExpandRequestTupleKey& from) {
    ExpandRequestTupleKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExpandRequestTupleKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ExpandRequestTupleKey";
  }
  protected:
  explicit ExpandRequestTupleKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRelationFieldNumber = 1,
    kObjectFieldNumber = 2,
  };
  // string relation = 1 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_relation();
  const std::string& relation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_relation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_relation();
  PROTOBUF_NODISCARD std::string* release_relation();
  void set_allocated_relation(std::string* relation);
  private:
  const std::string& _internal_relation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relation(const std::string& value);
  std::string* _internal_mutable_relation();
  public:

  // string object = 2 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_object();
  const std::string& object() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_object(ArgT0&& arg0, ArgT... args);
  std::string* mutable_object();
  PROTOBUF_NODISCARD std::string* release_object();
  void set_allocated_object(std::string* object);
  private:
  const std::string& _internal_object() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object(const std::string& value);
  std::string* _internal_mutable_object();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.ExpandRequestTupleKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr object_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ExpandResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ExpandResponse) */ {
 public:
  inline ExpandResponse() : ExpandResponse(nullptr) {}
  ~ExpandResponse() override;
  explicit PROTOBUF_CONSTEXPR ExpandResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExpandResponse(const ExpandResponse& from);
  ExpandResponse(ExpandResponse&& from) noexcept
    : ExpandResponse() {
    *this = ::std::move(from);
  }

  inline ExpandResponse& operator=(const ExpandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpandResponse& operator=(ExpandResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpandResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExpandResponse* internal_default_instance() {
    return reinterpret_cast<const ExpandResponse*>(
               &_ExpandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ExpandResponse& a, ExpandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExpandResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpandResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpandResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExpandResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExpandResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExpandResponse& from) {
    ExpandResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExpandResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ExpandResponse";
  }
  protected:
  explicit ExpandResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTreeFieldNumber = 1,
  };
  // .openfga.v1.UsersetTree tree = 1 [json_name = "tree"];
  bool has_tree() const;
  private:
  bool _internal_has_tree() const;
  public:
  void clear_tree();
  const ::openfga::v1::UsersetTree& tree() const;
  PROTOBUF_NODISCARD ::openfga::v1::UsersetTree* release_tree();
  ::openfga::v1::UsersetTree* mutable_tree();
  void set_allocated_tree(::openfga::v1::UsersetTree* tree);
  private:
  const ::openfga::v1::UsersetTree& _internal_tree() const;
  ::openfga::v1::UsersetTree* _internal_mutable_tree();
  public:
  void unsafe_arena_set_allocated_tree(
      ::openfga::v1::UsersetTree* tree);
  ::openfga::v1::UsersetTree* unsafe_arena_release_tree();

  // @@protoc_insertion_point(class_scope:openfga.v1.ExpandResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::openfga::v1::UsersetTree* tree_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ReadAuthorizationModelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ReadAuthorizationModelRequest) */ {
 public:
  inline ReadAuthorizationModelRequest() : ReadAuthorizationModelRequest(nullptr) {}
  ~ReadAuthorizationModelRequest() override;
  explicit PROTOBUF_CONSTEXPR ReadAuthorizationModelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadAuthorizationModelRequest(const ReadAuthorizationModelRequest& from);
  ReadAuthorizationModelRequest(ReadAuthorizationModelRequest&& from) noexcept
    : ReadAuthorizationModelRequest() {
    *this = ::std::move(from);
  }

  inline ReadAuthorizationModelRequest& operator=(const ReadAuthorizationModelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadAuthorizationModelRequest& operator=(ReadAuthorizationModelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadAuthorizationModelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadAuthorizationModelRequest* internal_default_instance() {
    return reinterpret_cast<const ReadAuthorizationModelRequest*>(
               &_ReadAuthorizationModelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ReadAuthorizationModelRequest& a, ReadAuthorizationModelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadAuthorizationModelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadAuthorizationModelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadAuthorizationModelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadAuthorizationModelRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadAuthorizationModelRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadAuthorizationModelRequest& from) {
    ReadAuthorizationModelRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadAuthorizationModelRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ReadAuthorizationModelRequest";
  }
  protected:
  explicit ReadAuthorizationModelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoreIdFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_store_id();
  const std::string& store_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_id();
  PROTOBUF_NODISCARD std::string* release_store_id();
  void set_allocated_store_id(std::string* store_id);
  private:
  const std::string& _internal_store_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_id(const std::string& value);
  std::string* _internal_mutable_store_id();
  public:

  // string id = 2 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.ReadAuthorizationModelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ReadAuthorizationModelResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ReadAuthorizationModelResponse) */ {
 public:
  inline ReadAuthorizationModelResponse() : ReadAuthorizationModelResponse(nullptr) {}
  ~ReadAuthorizationModelResponse() override;
  explicit PROTOBUF_CONSTEXPR ReadAuthorizationModelResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadAuthorizationModelResponse(const ReadAuthorizationModelResponse& from);
  ReadAuthorizationModelResponse(ReadAuthorizationModelResponse&& from) noexcept
    : ReadAuthorizationModelResponse() {
    *this = ::std::move(from);
  }

  inline ReadAuthorizationModelResponse& operator=(const ReadAuthorizationModelResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadAuthorizationModelResponse& operator=(ReadAuthorizationModelResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadAuthorizationModelResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadAuthorizationModelResponse* internal_default_instance() {
    return reinterpret_cast<const ReadAuthorizationModelResponse*>(
               &_ReadAuthorizationModelResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ReadAuthorizationModelResponse& a, ReadAuthorizationModelResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadAuthorizationModelResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadAuthorizationModelResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadAuthorizationModelResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadAuthorizationModelResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadAuthorizationModelResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadAuthorizationModelResponse& from) {
    ReadAuthorizationModelResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadAuthorizationModelResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ReadAuthorizationModelResponse";
  }
  protected:
  explicit ReadAuthorizationModelResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorizationModelFieldNumber = 1,
  };
  // .openfga.v1.AuthorizationModel authorization_model = 1 [json_name = "authorization_model"];
  bool has_authorization_model() const;
  private:
  bool _internal_has_authorization_model() const;
  public:
  void clear_authorization_model();
  const ::openfga::v1::AuthorizationModel& authorization_model() const;
  PROTOBUF_NODISCARD ::openfga::v1::AuthorizationModel* release_authorization_model();
  ::openfga::v1::AuthorizationModel* mutable_authorization_model();
  void set_allocated_authorization_model(::openfga::v1::AuthorizationModel* authorization_model);
  private:
  const ::openfga::v1::AuthorizationModel& _internal_authorization_model() const;
  ::openfga::v1::AuthorizationModel* _internal_mutable_authorization_model();
  public:
  void unsafe_arena_set_allocated_authorization_model(
      ::openfga::v1::AuthorizationModel* authorization_model);
  ::openfga::v1::AuthorizationModel* unsafe_arena_release_authorization_model();

  // @@protoc_insertion_point(class_scope:openfga.v1.ReadAuthorizationModelResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::openfga::v1::AuthorizationModel* authorization_model_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse, 
    std::string, ::openfga::v1::Condition,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse, 
    std::string, ::openfga::v1::Condition,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse& other);
  static const WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse*>(&_WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "openfga.v1.WriteAuthorizationModelRequest.ConditionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};

// -------------------------------------------------------------------

class WriteAuthorizationModelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.WriteAuthorizationModelRequest) */ {
 public:
  inline WriteAuthorizationModelRequest() : WriteAuthorizationModelRequest(nullptr) {}
  ~WriteAuthorizationModelRequest() override;
  explicit PROTOBUF_CONSTEXPR WriteAuthorizationModelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteAuthorizationModelRequest(const WriteAuthorizationModelRequest& from);
  WriteAuthorizationModelRequest(WriteAuthorizationModelRequest&& from) noexcept
    : WriteAuthorizationModelRequest() {
    *this = ::std::move(from);
  }

  inline WriteAuthorizationModelRequest& operator=(const WriteAuthorizationModelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteAuthorizationModelRequest& operator=(WriteAuthorizationModelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteAuthorizationModelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteAuthorizationModelRequest* internal_default_instance() {
    return reinterpret_cast<const WriteAuthorizationModelRequest*>(
               &_WriteAuthorizationModelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(WriteAuthorizationModelRequest& a, WriteAuthorizationModelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteAuthorizationModelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteAuthorizationModelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteAuthorizationModelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteAuthorizationModelRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteAuthorizationModelRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WriteAuthorizationModelRequest& from) {
    WriteAuthorizationModelRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteAuthorizationModelRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.WriteAuthorizationModelRequest";
  }
  protected:
  explicit WriteAuthorizationModelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTypeDefinitionsFieldNumber = 2,
    kConditionsFieldNumber = 4,
    kStoreIdFieldNumber = 1,
    kSchemaVersionFieldNumber = 3,
  };
  // repeated .openfga.v1.TypeDefinition type_definitions = 2 [json_name = "type_definitions", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int type_definitions_size() const;
  private:
  int _internal_type_definitions_size() const;
  public:
  void clear_type_definitions();
  ::openfga::v1::TypeDefinition* mutable_type_definitions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TypeDefinition >*
      mutable_type_definitions();
  private:
  const ::openfga::v1::TypeDefinition& _internal_type_definitions(int index) const;
  ::openfga::v1::TypeDefinition* _internal_add_type_definitions();
  public:
  const ::openfga::v1::TypeDefinition& type_definitions(int index) const;
  ::openfga::v1::TypeDefinition* add_type_definitions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TypeDefinition >&
      type_definitions() const;

  // map<string, .openfga.v1.Condition> conditions = 4 [json_name = "conditions", (.validate.rules) = {
  int conditions_size() const;
  private:
  int _internal_conditions_size() const;
  public:
  void clear_conditions();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::Condition >&
      _internal_conditions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::Condition >*
      _internal_mutable_conditions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::Condition >&
      conditions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::Condition >*
      mutable_conditions();

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_store_id();
  const std::string& store_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_id();
  PROTOBUF_NODISCARD std::string* release_store_id();
  void set_allocated_store_id(std::string* store_id);
  private:
  const std::string& _internal_store_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_id(const std::string& value);
  std::string* _internal_mutable_store_id();
  public:

  // string schema_version = 3 [json_name = "schema_version", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_schema_version();
  const std::string& schema_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_version();
  PROTOBUF_NODISCARD std::string* release_schema_version();
  void set_allocated_schema_version(std::string* schema_version);
  private:
  const std::string& _internal_schema_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_version(const std::string& value);
  std::string* _internal_mutable_schema_version();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.WriteAuthorizationModelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TypeDefinition > type_definitions_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse,
        std::string, ::openfga::v1::Condition,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> conditions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class WriteAuthorizationModelResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.WriteAuthorizationModelResponse) */ {
 public:
  inline WriteAuthorizationModelResponse() : WriteAuthorizationModelResponse(nullptr) {}
  ~WriteAuthorizationModelResponse() override;
  explicit PROTOBUF_CONSTEXPR WriteAuthorizationModelResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteAuthorizationModelResponse(const WriteAuthorizationModelResponse& from);
  WriteAuthorizationModelResponse(WriteAuthorizationModelResponse&& from) noexcept
    : WriteAuthorizationModelResponse() {
    *this = ::std::move(from);
  }

  inline WriteAuthorizationModelResponse& operator=(const WriteAuthorizationModelResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteAuthorizationModelResponse& operator=(WriteAuthorizationModelResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteAuthorizationModelResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteAuthorizationModelResponse* internal_default_instance() {
    return reinterpret_cast<const WriteAuthorizationModelResponse*>(
               &_WriteAuthorizationModelResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(WriteAuthorizationModelResponse& a, WriteAuthorizationModelResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteAuthorizationModelResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteAuthorizationModelResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteAuthorizationModelResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteAuthorizationModelResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteAuthorizationModelResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WriteAuthorizationModelResponse& from) {
    WriteAuthorizationModelResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteAuthorizationModelResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.WriteAuthorizationModelResponse";
  }
  protected:
  explicit WriteAuthorizationModelResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorizationModelIdFieldNumber = 1,
  };
  // string authorization_model_id = 1 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_authorization_model_id();
  const std::string& authorization_model_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_authorization_model_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_authorization_model_id();
  PROTOBUF_NODISCARD std::string* release_authorization_model_id();
  void set_allocated_authorization_model_id(std::string* authorization_model_id);
  private:
  const std::string& _internal_authorization_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authorization_model_id(const std::string& value);
  std::string* _internal_mutable_authorization_model_id();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.WriteAuthorizationModelResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authorization_model_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ReadAuthorizationModelsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ReadAuthorizationModelsRequest) */ {
 public:
  inline ReadAuthorizationModelsRequest() : ReadAuthorizationModelsRequest(nullptr) {}
  ~ReadAuthorizationModelsRequest() override;
  explicit PROTOBUF_CONSTEXPR ReadAuthorizationModelsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadAuthorizationModelsRequest(const ReadAuthorizationModelsRequest& from);
  ReadAuthorizationModelsRequest(ReadAuthorizationModelsRequest&& from) noexcept
    : ReadAuthorizationModelsRequest() {
    *this = ::std::move(from);
  }

  inline ReadAuthorizationModelsRequest& operator=(const ReadAuthorizationModelsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadAuthorizationModelsRequest& operator=(ReadAuthorizationModelsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadAuthorizationModelsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadAuthorizationModelsRequest* internal_default_instance() {
    return reinterpret_cast<const ReadAuthorizationModelsRequest*>(
               &_ReadAuthorizationModelsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ReadAuthorizationModelsRequest& a, ReadAuthorizationModelsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadAuthorizationModelsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadAuthorizationModelsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadAuthorizationModelsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadAuthorizationModelsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadAuthorizationModelsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadAuthorizationModelsRequest& from) {
    ReadAuthorizationModelsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadAuthorizationModelsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ReadAuthorizationModelsRequest";
  }
  protected:
  explicit ReadAuthorizationModelsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoreIdFieldNumber = 1,
    kContinuationTokenFieldNumber = 3,
    kPageSizeFieldNumber = 2,
  };
  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_store_id();
  const std::string& store_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_id();
  PROTOBUF_NODISCARD std::string* release_store_id();
  void set_allocated_store_id(std::string* store_id);
  private:
  const std::string& _internal_store_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_id(const std::string& value);
  std::string* _internal_mutable_store_id();
  public:

  // string continuation_token = 3 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_continuation_token();
  const std::string& continuation_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_continuation_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_continuation_token();
  PROTOBUF_NODISCARD std::string* release_continuation_token();
  void set_allocated_continuation_token(std::string* continuation_token);
  private:
  const std::string& _internal_continuation_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_continuation_token(const std::string& value);
  std::string* _internal_mutable_continuation_token();
  public:

  // .google.protobuf.Int32Value page_size = 2 [json_name = "page_size", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  bool has_page_size() const;
  private:
  bool _internal_has_page_size() const;
  public:
  void clear_page_size();
  const ::PROTOBUF_NAMESPACE_ID::Int32Value& page_size() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Int32Value* release_page_size();
  ::PROTOBUF_NAMESPACE_ID::Int32Value* mutable_page_size();
  void set_allocated_page_size(::PROTOBUF_NAMESPACE_ID::Int32Value* page_size);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Int32Value& _internal_page_size() const;
  ::PROTOBUF_NAMESPACE_ID::Int32Value* _internal_mutable_page_size();
  public:
  void unsafe_arena_set_allocated_page_size(
      ::PROTOBUF_NAMESPACE_ID::Int32Value* page_size);
  ::PROTOBUF_NAMESPACE_ID::Int32Value* unsafe_arena_release_page_size();

  // @@protoc_insertion_point(class_scope:openfga.v1.ReadAuthorizationModelsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr continuation_token_;
    ::PROTOBUF_NAMESPACE_ID::Int32Value* page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ReadAuthorizationModelsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ReadAuthorizationModelsResponse) */ {
 public:
  inline ReadAuthorizationModelsResponse() : ReadAuthorizationModelsResponse(nullptr) {}
  ~ReadAuthorizationModelsResponse() override;
  explicit PROTOBUF_CONSTEXPR ReadAuthorizationModelsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadAuthorizationModelsResponse(const ReadAuthorizationModelsResponse& from);
  ReadAuthorizationModelsResponse(ReadAuthorizationModelsResponse&& from) noexcept
    : ReadAuthorizationModelsResponse() {
    *this = ::std::move(from);
  }

  inline ReadAuthorizationModelsResponse& operator=(const ReadAuthorizationModelsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadAuthorizationModelsResponse& operator=(ReadAuthorizationModelsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadAuthorizationModelsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadAuthorizationModelsResponse* internal_default_instance() {
    return reinterpret_cast<const ReadAuthorizationModelsResponse*>(
               &_ReadAuthorizationModelsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ReadAuthorizationModelsResponse& a, ReadAuthorizationModelsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadAuthorizationModelsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadAuthorizationModelsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadAuthorizationModelsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadAuthorizationModelsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadAuthorizationModelsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadAuthorizationModelsResponse& from) {
    ReadAuthorizationModelsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadAuthorizationModelsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ReadAuthorizationModelsResponse";
  }
  protected:
  explicit ReadAuthorizationModelsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorizationModelsFieldNumber = 1,
    kContinuationTokenFieldNumber = 2,
  };
  // repeated .openfga.v1.AuthorizationModel authorization_models = 1 [json_name = "authorization_models", (.google.api.field_behavior) = REQUIRED];
  int authorization_models_size() const;
  private:
  int _internal_authorization_models_size() const;
  public:
  void clear_authorization_models();
  ::openfga::v1::AuthorizationModel* mutable_authorization_models(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::AuthorizationModel >*
      mutable_authorization_models();
  private:
  const ::openfga::v1::AuthorizationModel& _internal_authorization_models(int index) const;
  ::openfga::v1::AuthorizationModel* _internal_add_authorization_models();
  public:
  const ::openfga::v1::AuthorizationModel& authorization_models(int index) const;
  ::openfga::v1::AuthorizationModel* add_authorization_models();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::AuthorizationModel >&
      authorization_models() const;

  // string continuation_token = 2 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_continuation_token();
  const std::string& continuation_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_continuation_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_continuation_token();
  PROTOBUF_NODISCARD std::string* release_continuation_token();
  void set_allocated_continuation_token(std::string* continuation_token);
  private:
  const std::string& _internal_continuation_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_continuation_token(const std::string& value);
  std::string* _internal_mutable_continuation_token();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.ReadAuthorizationModelsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::AuthorizationModel > authorization_models_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr continuation_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class WriteAssertionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.WriteAssertionsRequest) */ {
 public:
  inline WriteAssertionsRequest() : WriteAssertionsRequest(nullptr) {}
  ~WriteAssertionsRequest() override;
  explicit PROTOBUF_CONSTEXPR WriteAssertionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteAssertionsRequest(const WriteAssertionsRequest& from);
  WriteAssertionsRequest(WriteAssertionsRequest&& from) noexcept
    : WriteAssertionsRequest() {
    *this = ::std::move(from);
  }

  inline WriteAssertionsRequest& operator=(const WriteAssertionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteAssertionsRequest& operator=(WriteAssertionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteAssertionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteAssertionsRequest* internal_default_instance() {
    return reinterpret_cast<const WriteAssertionsRequest*>(
               &_WriteAssertionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(WriteAssertionsRequest& a, WriteAssertionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteAssertionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteAssertionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteAssertionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteAssertionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteAssertionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WriteAssertionsRequest& from) {
    WriteAssertionsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteAssertionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.WriteAssertionsRequest";
  }
  protected:
  explicit WriteAssertionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssertionsFieldNumber = 3,
    kStoreIdFieldNumber = 1,
    kAuthorizationModelIdFieldNumber = 2,
  };
  // repeated .openfga.v1.Assertion assertions = 3 [json_name = "assertions", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int assertions_size() const;
  private:
  int _internal_assertions_size() const;
  public:
  void clear_assertions();
  ::openfga::v1::Assertion* mutable_assertions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Assertion >*
      mutable_assertions();
  private:
  const ::openfga::v1::Assertion& _internal_assertions(int index) const;
  ::openfga::v1::Assertion* _internal_add_assertions();
  public:
  const ::openfga::v1::Assertion& assertions(int index) const;
  ::openfga::v1::Assertion* add_assertions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Assertion >&
      assertions() const;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_store_id();
  const std::string& store_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_id();
  PROTOBUF_NODISCARD std::string* release_store_id();
  void set_allocated_store_id(std::string* store_id);
  private:
  const std::string& _internal_store_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_id(const std::string& value);
  std::string* _internal_mutable_store_id();
  public:

  // string authorization_model_id = 2 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_authorization_model_id();
  const std::string& authorization_model_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_authorization_model_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_authorization_model_id();
  PROTOBUF_NODISCARD std::string* release_authorization_model_id();
  void set_allocated_authorization_model_id(std::string* authorization_model_id);
  private:
  const std::string& _internal_authorization_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authorization_model_id(const std::string& value);
  std::string* _internal_mutable_authorization_model_id();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.WriteAssertionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Assertion > assertions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authorization_model_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class WriteAssertionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:openfga.v1.WriteAssertionsResponse) */ {
 public:
  inline WriteAssertionsResponse() : WriteAssertionsResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR WriteAssertionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteAssertionsResponse(const WriteAssertionsResponse& from);
  WriteAssertionsResponse(WriteAssertionsResponse&& from) noexcept
    : WriteAssertionsResponse() {
    *this = ::std::move(from);
  }

  inline WriteAssertionsResponse& operator=(const WriteAssertionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteAssertionsResponse& operator=(WriteAssertionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteAssertionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteAssertionsResponse* internal_default_instance() {
    return reinterpret_cast<const WriteAssertionsResponse*>(
               &_WriteAssertionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(WriteAssertionsResponse& a, WriteAssertionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteAssertionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteAssertionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteAssertionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteAssertionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const WriteAssertionsResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const WriteAssertionsResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.WriteAssertionsResponse";
  }
  protected:
  explicit WriteAssertionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:openfga.v1.WriteAssertionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ReadAssertionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ReadAssertionsRequest) */ {
 public:
  inline ReadAssertionsRequest() : ReadAssertionsRequest(nullptr) {}
  ~ReadAssertionsRequest() override;
  explicit PROTOBUF_CONSTEXPR ReadAssertionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadAssertionsRequest(const ReadAssertionsRequest& from);
  ReadAssertionsRequest(ReadAssertionsRequest&& from) noexcept
    : ReadAssertionsRequest() {
    *this = ::std::move(from);
  }

  inline ReadAssertionsRequest& operator=(const ReadAssertionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadAssertionsRequest& operator=(ReadAssertionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadAssertionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadAssertionsRequest* internal_default_instance() {
    return reinterpret_cast<const ReadAssertionsRequest*>(
               &_ReadAssertionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ReadAssertionsRequest& a, ReadAssertionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadAssertionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadAssertionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadAssertionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadAssertionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadAssertionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadAssertionsRequest& from) {
    ReadAssertionsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadAssertionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ReadAssertionsRequest";
  }
  protected:
  explicit ReadAssertionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoreIdFieldNumber = 1,
    kAuthorizationModelIdFieldNumber = 2,
  };
  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_store_id();
  const std::string& store_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_id();
  PROTOBUF_NODISCARD std::string* release_store_id();
  void set_allocated_store_id(std::string* store_id);
  private:
  const std::string& _internal_store_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_id(const std::string& value);
  std::string* _internal_mutable_store_id();
  public:

  // string authorization_model_id = 2 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_authorization_model_id();
  const std::string& authorization_model_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_authorization_model_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_authorization_model_id();
  PROTOBUF_NODISCARD std::string* release_authorization_model_id();
  void set_allocated_authorization_model_id(std::string* authorization_model_id);
  private:
  const std::string& _internal_authorization_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authorization_model_id(const std::string& value);
  std::string* _internal_mutable_authorization_model_id();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.ReadAssertionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authorization_model_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ReadAssertionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ReadAssertionsResponse) */ {
 public:
  inline ReadAssertionsResponse() : ReadAssertionsResponse(nullptr) {}
  ~ReadAssertionsResponse() override;
  explicit PROTOBUF_CONSTEXPR ReadAssertionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadAssertionsResponse(const ReadAssertionsResponse& from);
  ReadAssertionsResponse(ReadAssertionsResponse&& from) noexcept
    : ReadAssertionsResponse() {
    *this = ::std::move(from);
  }

  inline ReadAssertionsResponse& operator=(const ReadAssertionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadAssertionsResponse& operator=(ReadAssertionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadAssertionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadAssertionsResponse* internal_default_instance() {
    return reinterpret_cast<const ReadAssertionsResponse*>(
               &_ReadAssertionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ReadAssertionsResponse& a, ReadAssertionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadAssertionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadAssertionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadAssertionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadAssertionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadAssertionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadAssertionsResponse& from) {
    ReadAssertionsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadAssertionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ReadAssertionsResponse";
  }
  protected:
  explicit ReadAssertionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssertionsFieldNumber = 2,
    kAuthorizationModelIdFieldNumber = 1,
  };
  // repeated .openfga.v1.Assertion assertions = 2 [json_name = "assertions"];
  int assertions_size() const;
  private:
  int _internal_assertions_size() const;
  public:
  void clear_assertions();
  ::openfga::v1::Assertion* mutable_assertions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Assertion >*
      mutable_assertions();
  private:
  const ::openfga::v1::Assertion& _internal_assertions(int index) const;
  ::openfga::v1::Assertion* _internal_add_assertions();
  public:
  const ::openfga::v1::Assertion& assertions(int index) const;
  ::openfga::v1::Assertion* add_assertions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Assertion >&
      assertions() const;

  // string authorization_model_id = 1 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_authorization_model_id();
  const std::string& authorization_model_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_authorization_model_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_authorization_model_id();
  PROTOBUF_NODISCARD std::string* release_authorization_model_id();
  void set_allocated_authorization_model_id(std::string* authorization_model_id);
  private:
  const std::string& _internal_authorization_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authorization_model_id(const std::string& value);
  std::string* _internal_mutable_authorization_model_id();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.ReadAssertionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Assertion > assertions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authorization_model_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ReadChangesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ReadChangesRequest) */ {
 public:
  inline ReadChangesRequest() : ReadChangesRequest(nullptr) {}
  ~ReadChangesRequest() override;
  explicit PROTOBUF_CONSTEXPR ReadChangesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadChangesRequest(const ReadChangesRequest& from);
  ReadChangesRequest(ReadChangesRequest&& from) noexcept
    : ReadChangesRequest() {
    *this = ::std::move(from);
  }

  inline ReadChangesRequest& operator=(const ReadChangesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadChangesRequest& operator=(ReadChangesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadChangesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadChangesRequest* internal_default_instance() {
    return reinterpret_cast<const ReadChangesRequest*>(
               &_ReadChangesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(ReadChangesRequest& a, ReadChangesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadChangesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadChangesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadChangesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadChangesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadChangesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadChangesRequest& from) {
    ReadChangesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadChangesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ReadChangesRequest";
  }
  protected:
  explicit ReadChangesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoreIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kContinuationTokenFieldNumber = 4,
    kPageSizeFieldNumber = 3,
    kStartTimeFieldNumber = 5,
  };
  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_store_id();
  const std::string& store_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_id();
  PROTOBUF_NODISCARD std::string* release_store_id();
  void set_allocated_store_id(std::string* store_id);
  private:
  const std::string& _internal_store_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_id(const std::string& value);
  std::string* _internal_mutable_store_id();
  public:

  // string type = 2 [json_name = "type", (.validate.rules) = {
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string continuation_token = 4 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_continuation_token();
  const std::string& continuation_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_continuation_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_continuation_token();
  PROTOBUF_NODISCARD std::string* release_continuation_token();
  void set_allocated_continuation_token(std::string* continuation_token);
  private:
  const std::string& _internal_continuation_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_continuation_token(const std::string& value);
  std::string* _internal_mutable_continuation_token();
  public:

  // .google.protobuf.Int32Value page_size = 3 [json_name = "page_size", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  bool has_page_size() const;
  private:
  bool _internal_has_page_size() const;
  public:
  void clear_page_size();
  const ::PROTOBUF_NAMESPACE_ID::Int32Value& page_size() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Int32Value* release_page_size();
  ::PROTOBUF_NAMESPACE_ID::Int32Value* mutable_page_size();
  void set_allocated_page_size(::PROTOBUF_NAMESPACE_ID::Int32Value* page_size);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Int32Value& _internal_page_size() const;
  ::PROTOBUF_NAMESPACE_ID::Int32Value* _internal_mutable_page_size();
  public:
  void unsafe_arena_set_allocated_page_size(
      ::PROTOBUF_NAMESPACE_ID::Int32Value* page_size);
  ::PROTOBUF_NAMESPACE_ID::Int32Value* unsafe_arena_release_page_size();

  // .google.protobuf.Timestamp start_time = 5 [json_name = "start_time", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // @@protoc_insertion_point(class_scope:openfga.v1.ReadChangesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr continuation_token_;
    ::PROTOBUF_NAMESPACE_ID::Int32Value* page_size_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ReadChangesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ReadChangesResponse) */ {
 public:
  inline ReadChangesResponse() : ReadChangesResponse(nullptr) {}
  ~ReadChangesResponse() override;
  explicit PROTOBUF_CONSTEXPR ReadChangesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadChangesResponse(const ReadChangesResponse& from);
  ReadChangesResponse(ReadChangesResponse&& from) noexcept
    : ReadChangesResponse() {
    *this = ::std::move(from);
  }

  inline ReadChangesResponse& operator=(const ReadChangesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadChangesResponse& operator=(ReadChangesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadChangesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadChangesResponse* internal_default_instance() {
    return reinterpret_cast<const ReadChangesResponse*>(
               &_ReadChangesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(ReadChangesResponse& a, ReadChangesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadChangesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadChangesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadChangesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadChangesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadChangesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadChangesResponse& from) {
    ReadChangesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadChangesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ReadChangesResponse";
  }
  protected:
  explicit ReadChangesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChangesFieldNumber = 1,
    kContinuationTokenFieldNumber = 2,
  };
  // repeated .openfga.v1.TupleChange changes = 1 [json_name = "changes", (.google.api.field_behavior) = REQUIRED];
  int changes_size() const;
  private:
  int _internal_changes_size() const;
  public:
  void clear_changes();
  ::openfga::v1::TupleChange* mutable_changes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleChange >*
      mutable_changes();
  private:
  const ::openfga::v1::TupleChange& _internal_changes(int index) const;
  ::openfga::v1::TupleChange* _internal_add_changes();
  public:
  const ::openfga::v1::TupleChange& changes(int index) const;
  ::openfga::v1::TupleChange* add_changes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleChange >&
      changes() const;

  // string continuation_token = 2 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_continuation_token();
  const std::string& continuation_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_continuation_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_continuation_token();
  PROTOBUF_NODISCARD std::string* release_continuation_token();
  void set_allocated_continuation_token(std::string* continuation_token);
  private:
  const std::string& _internal_continuation_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_continuation_token(const std::string& value);
  std::string* _internal_mutable_continuation_token();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.ReadChangesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleChange > changes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr continuation_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CreateStoreRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.CreateStoreRequest) */ {
 public:
  inline CreateStoreRequest() : CreateStoreRequest(nullptr) {}
  ~CreateStoreRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateStoreRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateStoreRequest(const CreateStoreRequest& from);
  CreateStoreRequest(CreateStoreRequest&& from) noexcept
    : CreateStoreRequest() {
    *this = ::std::move(from);
  }

  inline CreateStoreRequest& operator=(const CreateStoreRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateStoreRequest& operator=(CreateStoreRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateStoreRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateStoreRequest* internal_default_instance() {
    return reinterpret_cast<const CreateStoreRequest*>(
               &_CreateStoreRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(CreateStoreRequest& a, CreateStoreRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateStoreRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateStoreRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateStoreRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateStoreRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateStoreRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateStoreRequest& from) {
    CreateStoreRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateStoreRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.CreateStoreRequest";
  }
  protected:
  explicit CreateStoreRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [json_name = "name", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.CreateStoreRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CreateStoreResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.CreateStoreResponse) */ {
 public:
  inline CreateStoreResponse() : CreateStoreResponse(nullptr) {}
  ~CreateStoreResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateStoreResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateStoreResponse(const CreateStoreResponse& from);
  CreateStoreResponse(CreateStoreResponse&& from) noexcept
    : CreateStoreResponse() {
    *this = ::std::move(from);
  }

  inline CreateStoreResponse& operator=(const CreateStoreResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateStoreResponse& operator=(CreateStoreResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateStoreResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateStoreResponse* internal_default_instance() {
    return reinterpret_cast<const CreateStoreResponse*>(
               &_CreateStoreResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(CreateStoreResponse& a, CreateStoreResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateStoreResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateStoreResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateStoreResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateStoreResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateStoreResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateStoreResponse& from) {
    CreateStoreResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateStoreResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.CreateStoreResponse";
  }
  protected:
  explicit CreateStoreResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kCreatedAtFieldNumber = 3,
    kUpdatedAtFieldNumber = 4,
  };
  // string id = 1 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name", (.google.api.field_behavior) = REQUIRED];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Timestamp created_at = 3 [json_name = "created_at", (.google.api.field_behavior) = REQUIRED];
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp updated_at = 4 [json_name = "updated_at", (.google.api.field_behavior) = REQUIRED];
  bool has_updated_at() const;
  private:
  bool _internal_has_updated_at() const;
  public:
  void clear_updated_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_updated_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_updated_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_updated_at();
  public:
  void unsafe_arena_set_allocated_updated_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_updated_at();

  // @@protoc_insertion_point(class_scope:openfga.v1.CreateStoreResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class UpdateStoreRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.UpdateStoreRequest) */ {
 public:
  inline UpdateStoreRequest() : UpdateStoreRequest(nullptr) {}
  ~UpdateStoreRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateStoreRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateStoreRequest(const UpdateStoreRequest& from);
  UpdateStoreRequest(UpdateStoreRequest&& from) noexcept
    : UpdateStoreRequest() {
    *this = ::std::move(from);
  }

  inline UpdateStoreRequest& operator=(const UpdateStoreRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateStoreRequest& operator=(UpdateStoreRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateStoreRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateStoreRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateStoreRequest*>(
               &_UpdateStoreRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(UpdateStoreRequest& a, UpdateStoreRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateStoreRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateStoreRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateStoreRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateStoreRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateStoreRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateStoreRequest& from) {
    UpdateStoreRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateStoreRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.UpdateStoreRequest";
  }
  protected:
  explicit UpdateStoreRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoreIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_store_id();
  const std::string& store_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_id();
  PROTOBUF_NODISCARD std::string* release_store_id();
  void set_allocated_store_id(std::string* store_id);
  private:
  const std::string& _internal_store_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_id(const std::string& value);
  std::string* _internal_mutable_store_id();
  public:

  // string name = 2 [json_name = "name", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.UpdateStoreRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class UpdateStoreResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.UpdateStoreResponse) */ {
 public:
  inline UpdateStoreResponse() : UpdateStoreResponse(nullptr) {}
  ~UpdateStoreResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateStoreResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateStoreResponse(const UpdateStoreResponse& from);
  UpdateStoreResponse(UpdateStoreResponse&& from) noexcept
    : UpdateStoreResponse() {
    *this = ::std::move(from);
  }

  inline UpdateStoreResponse& operator=(const UpdateStoreResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateStoreResponse& operator=(UpdateStoreResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateStoreResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateStoreResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateStoreResponse*>(
               &_UpdateStoreResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(UpdateStoreResponse& a, UpdateStoreResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateStoreResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateStoreResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateStoreResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateStoreResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateStoreResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateStoreResponse& from) {
    UpdateStoreResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateStoreResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.UpdateStoreResponse";
  }
  protected:
  explicit UpdateStoreResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kCreatedAtFieldNumber = 3,
    kUpdatedAtFieldNumber = 4,
  };
  // string id = 1 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name", (.google.api.field_behavior) = REQUIRED];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Timestamp created_at = 3 [json_name = "created_at", (.google.api.field_behavior) = REQUIRED];
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp updated_at = 4 [json_name = "updated_at", (.google.api.field_behavior) = REQUIRED];
  bool has_updated_at() const;
  private:
  bool _internal_has_updated_at() const;
  public:
  void clear_updated_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_updated_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_updated_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_updated_at();
  public:
  void unsafe_arena_set_allocated_updated_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_updated_at();

  // @@protoc_insertion_point(class_scope:openfga.v1.UpdateStoreResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class DeleteStoreRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.DeleteStoreRequest) */ {
 public:
  inline DeleteStoreRequest() : DeleteStoreRequest(nullptr) {}
  ~DeleteStoreRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteStoreRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteStoreRequest(const DeleteStoreRequest& from);
  DeleteStoreRequest(DeleteStoreRequest&& from) noexcept
    : DeleteStoreRequest() {
    *this = ::std::move(from);
  }

  inline DeleteStoreRequest& operator=(const DeleteStoreRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteStoreRequest& operator=(DeleteStoreRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteStoreRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteStoreRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteStoreRequest*>(
               &_DeleteStoreRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(DeleteStoreRequest& a, DeleteStoreRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteStoreRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteStoreRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteStoreRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteStoreRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteStoreRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteStoreRequest& from) {
    DeleteStoreRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteStoreRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.DeleteStoreRequest";
  }
  protected:
  explicit DeleteStoreRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoreIdFieldNumber = 1,
  };
  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_store_id();
  const std::string& store_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_id();
  PROTOBUF_NODISCARD std::string* release_store_id();
  void set_allocated_store_id(std::string* store_id);
  private:
  const std::string& _internal_store_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_id(const std::string& value);
  std::string* _internal_mutable_store_id();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.DeleteStoreRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class DeleteStoreResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:openfga.v1.DeleteStoreResponse) */ {
 public:
  inline DeleteStoreResponse() : DeleteStoreResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteStoreResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteStoreResponse(const DeleteStoreResponse& from);
  DeleteStoreResponse(DeleteStoreResponse&& from) noexcept
    : DeleteStoreResponse() {
    *this = ::std::move(from);
  }

  inline DeleteStoreResponse& operator=(const DeleteStoreResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteStoreResponse& operator=(DeleteStoreResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteStoreResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteStoreResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteStoreResponse*>(
               &_DeleteStoreResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(DeleteStoreResponse& a, DeleteStoreResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteStoreResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteStoreResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteStoreResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteStoreResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteStoreResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteStoreResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.DeleteStoreResponse";
  }
  protected:
  explicit DeleteStoreResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:openfga.v1.DeleteStoreResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetStoreRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.GetStoreRequest) */ {
 public:
  inline GetStoreRequest() : GetStoreRequest(nullptr) {}
  ~GetStoreRequest() override;
  explicit PROTOBUF_CONSTEXPR GetStoreRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStoreRequest(const GetStoreRequest& from);
  GetStoreRequest(GetStoreRequest&& from) noexcept
    : GetStoreRequest() {
    *this = ::std::move(from);
  }

  inline GetStoreRequest& operator=(const GetStoreRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStoreRequest& operator=(GetStoreRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStoreRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStoreRequest* internal_default_instance() {
    return reinterpret_cast<const GetStoreRequest*>(
               &_GetStoreRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(GetStoreRequest& a, GetStoreRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStoreRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStoreRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStoreRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetStoreRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetStoreRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetStoreRequest& from) {
    GetStoreRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStoreRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.GetStoreRequest";
  }
  protected:
  explicit GetStoreRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoreIdFieldNumber = 1,
  };
  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_store_id();
  const std::string& store_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_id();
  PROTOBUF_NODISCARD std::string* release_store_id();
  void set_allocated_store_id(std::string* store_id);
  private:
  const std::string& _internal_store_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_id(const std::string& value);
  std::string* _internal_mutable_store_id();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.GetStoreRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetStoreResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.GetStoreResponse) */ {
 public:
  inline GetStoreResponse() : GetStoreResponse(nullptr) {}
  ~GetStoreResponse() override;
  explicit PROTOBUF_CONSTEXPR GetStoreResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStoreResponse(const GetStoreResponse& from);
  GetStoreResponse(GetStoreResponse&& from) noexcept
    : GetStoreResponse() {
    *this = ::std::move(from);
  }

  inline GetStoreResponse& operator=(const GetStoreResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStoreResponse& operator=(GetStoreResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStoreResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStoreResponse* internal_default_instance() {
    return reinterpret_cast<const GetStoreResponse*>(
               &_GetStoreResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(GetStoreResponse& a, GetStoreResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStoreResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStoreResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStoreResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetStoreResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetStoreResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetStoreResponse& from) {
    GetStoreResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStoreResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.GetStoreResponse";
  }
  protected:
  explicit GetStoreResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kCreatedAtFieldNumber = 3,
    kUpdatedAtFieldNumber = 4,
    kDeletedAtFieldNumber = 5,
  };
  // string id = 1 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name", (.google.api.field_behavior) = REQUIRED];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Timestamp created_at = 3 [json_name = "created_at", (.google.api.field_behavior) = REQUIRED];
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp updated_at = 4 [json_name = "updated_at", (.google.api.field_behavior) = REQUIRED];
  bool has_updated_at() const;
  private:
  bool _internal_has_updated_at() const;
  public:
  void clear_updated_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_updated_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_updated_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_updated_at();
  public:
  void unsafe_arena_set_allocated_updated_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_updated_at();

  // .google.protobuf.Timestamp deleted_at = 5 [json_name = "deleted_at"];
  bool has_deleted_at() const;
  private:
  bool _internal_has_deleted_at() const;
  public:
  void clear_deleted_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& deleted_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_deleted_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_deleted_at();
  void set_allocated_deleted_at(::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_deleted_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_deleted_at();
  public:
  void unsafe_arena_set_allocated_deleted_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_deleted_at();

  // @@protoc_insertion_point(class_scope:openfga.v1.GetStoreResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ListStoresRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ListStoresRequest) */ {
 public:
  inline ListStoresRequest() : ListStoresRequest(nullptr) {}
  ~ListStoresRequest() override;
  explicit PROTOBUF_CONSTEXPR ListStoresRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListStoresRequest(const ListStoresRequest& from);
  ListStoresRequest(ListStoresRequest&& from) noexcept
    : ListStoresRequest() {
    *this = ::std::move(from);
  }

  inline ListStoresRequest& operator=(const ListStoresRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListStoresRequest& operator=(ListStoresRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListStoresRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListStoresRequest* internal_default_instance() {
    return reinterpret_cast<const ListStoresRequest*>(
               &_ListStoresRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(ListStoresRequest& a, ListStoresRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListStoresRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListStoresRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListStoresRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListStoresRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListStoresRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListStoresRequest& from) {
    ListStoresRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListStoresRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ListStoresRequest";
  }
  protected:
  explicit ListStoresRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContinuationTokenFieldNumber = 2,
    kNameFieldNumber = 3,
    kPageSizeFieldNumber = 1,
  };
  // string continuation_token = 2 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_continuation_token();
  const std::string& continuation_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_continuation_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_continuation_token();
  PROTOBUF_NODISCARD std::string* release_continuation_token();
  void set_allocated_continuation_token(std::string* continuation_token);
  private:
  const std::string& _internal_continuation_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_continuation_token(const std::string& value);
  std::string* _internal_mutable_continuation_token();
  public:

  // string name = 3 [json_name = "name", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Int32Value page_size = 1 [json_name = "page_size", (.validate.rules) = {
  bool has_page_size() const;
  private:
  bool _internal_has_page_size() const;
  public:
  void clear_page_size();
  const ::PROTOBUF_NAMESPACE_ID::Int32Value& page_size() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Int32Value* release_page_size();
  ::PROTOBUF_NAMESPACE_ID::Int32Value* mutable_page_size();
  void set_allocated_page_size(::PROTOBUF_NAMESPACE_ID::Int32Value* page_size);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Int32Value& _internal_page_size() const;
  ::PROTOBUF_NAMESPACE_ID::Int32Value* _internal_mutable_page_size();
  public:
  void unsafe_arena_set_allocated_page_size(
      ::PROTOBUF_NAMESPACE_ID::Int32Value* page_size);
  ::PROTOBUF_NAMESPACE_ID::Int32Value* unsafe_arena_release_page_size();

  // @@protoc_insertion_point(class_scope:openfga.v1.ListStoresRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr continuation_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::Int32Value* page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ListStoresResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ListStoresResponse) */ {
 public:
  inline ListStoresResponse() : ListStoresResponse(nullptr) {}
  ~ListStoresResponse() override;
  explicit PROTOBUF_CONSTEXPR ListStoresResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListStoresResponse(const ListStoresResponse& from);
  ListStoresResponse(ListStoresResponse&& from) noexcept
    : ListStoresResponse() {
    *this = ::std::move(from);
  }

  inline ListStoresResponse& operator=(const ListStoresResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListStoresResponse& operator=(ListStoresResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListStoresResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListStoresResponse* internal_default_instance() {
    return reinterpret_cast<const ListStoresResponse*>(
               &_ListStoresResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(ListStoresResponse& a, ListStoresResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListStoresResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListStoresResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListStoresResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListStoresResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListStoresResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListStoresResponse& from) {
    ListStoresResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListStoresResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ListStoresResponse";
  }
  protected:
  explicit ListStoresResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoresFieldNumber = 1,
    kContinuationTokenFieldNumber = 2,
  };
  // repeated .openfga.v1.Store stores = 1 [json_name = "stores", (.google.api.field_behavior) = REQUIRED];
  int stores_size() const;
  private:
  int _internal_stores_size() const;
  public:
  void clear_stores();
  ::openfga::v1::Store* mutable_stores(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Store >*
      mutable_stores();
  private:
  const ::openfga::v1::Store& _internal_stores(int index) const;
  ::openfga::v1::Store* _internal_add_stores();
  public:
  const ::openfga::v1::Store& stores(int index) const;
  ::openfga::v1::Store* add_stores();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Store >&
      stores() const;

  // string continuation_token = 2 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_continuation_token();
  const std::string& continuation_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_continuation_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_continuation_token();
  PROTOBUF_NODISCARD std::string* release_continuation_token();
  void set_allocated_continuation_token(std::string* continuation_token);
  private:
  const std::string& _internal_continuation_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_continuation_token(const std::string& value);
  std::string* _internal_mutable_continuation_token();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.ListStoresResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Store > stores_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr continuation_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class AssertionTupleKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.AssertionTupleKey) */ {
 public:
  inline AssertionTupleKey() : AssertionTupleKey(nullptr) {}
  ~AssertionTupleKey() override;
  explicit PROTOBUF_CONSTEXPR AssertionTupleKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssertionTupleKey(const AssertionTupleKey& from);
  AssertionTupleKey(AssertionTupleKey&& from) noexcept
    : AssertionTupleKey() {
    *this = ::std::move(from);
  }

  inline AssertionTupleKey& operator=(const AssertionTupleKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssertionTupleKey& operator=(AssertionTupleKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssertionTupleKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssertionTupleKey* internal_default_instance() {
    return reinterpret_cast<const AssertionTupleKey*>(
               &_AssertionTupleKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(AssertionTupleKey& a, AssertionTupleKey& b) {
    a.Swap(&b);
  }
  inline void Swap(AssertionTupleKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssertionTupleKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssertionTupleKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AssertionTupleKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AssertionTupleKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AssertionTupleKey& from) {
    AssertionTupleKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssertionTupleKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.AssertionTupleKey";
  }
  protected:
  explicit AssertionTupleKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
    kRelationFieldNumber = 2,
    kUserFieldNumber = 3,
  };
  // string object = 1 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_object();
  const std::string& object() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_object(ArgT0&& arg0, ArgT... args);
  std::string* mutable_object();
  PROTOBUF_NODISCARD std::string* release_object();
  void set_allocated_object(std::string* object);
  private:
  const std::string& _internal_object() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object(const std::string& value);
  std::string* _internal_mutable_object();
  public:

  // string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_relation();
  const std::string& relation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_relation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_relation();
  PROTOBUF_NODISCARD std::string* release_relation();
  void set_allocated_relation(std::string* relation);
  private:
  const std::string& _internal_relation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relation(const std::string& value);
  std::string* _internal_mutable_relation();
  public:

  // string user = 3 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.AssertionTupleKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr object_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class Assertion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.Assertion) */ {
 public:
  inline Assertion() : Assertion(nullptr) {}
  ~Assertion() override;
  explicit PROTOBUF_CONSTEXPR Assertion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Assertion(const Assertion& from);
  Assertion(Assertion&& from) noexcept
    : Assertion() {
    *this = ::std::move(from);
  }

  inline Assertion& operator=(const Assertion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Assertion& operator=(Assertion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Assertion& default_instance() {
    return *internal_default_instance();
  }
  static inline const Assertion* internal_default_instance() {
    return reinterpret_cast<const Assertion*>(
               &_Assertion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(Assertion& a, Assertion& b) {
    a.Swap(&b);
  }
  inline void Swap(Assertion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Assertion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Assertion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Assertion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Assertion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Assertion& from) {
    Assertion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Assertion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.Assertion";
  }
  protected:
  explicit Assertion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContextualTuplesFieldNumber = 3,
    kTupleKeyFieldNumber = 1,
    kContextFieldNumber = 4,
    kExpectationFieldNumber = 2,
  };
  // repeated .openfga.v1.TupleKey contextual_tuples = 3 [json_name = "contextual_tuples", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int contextual_tuples_size() const;
  private:
  int _internal_contextual_tuples_size() const;
  public:
  void clear_contextual_tuples();
  ::openfga::v1::TupleKey* mutable_contextual_tuples(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKey >*
      mutable_contextual_tuples();
  private:
  const ::openfga::v1::TupleKey& _internal_contextual_tuples(int index) const;
  ::openfga::v1::TupleKey* _internal_add_contextual_tuples();
  public:
  const ::openfga::v1::TupleKey& contextual_tuples(int index) const;
  ::openfga::v1::TupleKey* add_contextual_tuples();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKey >&
      contextual_tuples() const;

  // .openfga.v1.AssertionTupleKey tuple_key = 1 [json_name = "tuple_key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_tuple_key() const;
  private:
  bool _internal_has_tuple_key() const;
  public:
  void clear_tuple_key();
  const ::openfga::v1::AssertionTupleKey& tuple_key() const;
  PROTOBUF_NODISCARD ::openfga::v1::AssertionTupleKey* release_tuple_key();
  ::openfga::v1::AssertionTupleKey* mutable_tuple_key();
  void set_allocated_tuple_key(::openfga::v1::AssertionTupleKey* tuple_key);
  private:
  const ::openfga::v1::AssertionTupleKey& _internal_tuple_key() const;
  ::openfga::v1::AssertionTupleKey* _internal_mutable_tuple_key();
  public:
  void unsafe_arena_set_allocated_tuple_key(
      ::openfga::v1::AssertionTupleKey* tuple_key);
  ::openfga::v1::AssertionTupleKey* unsafe_arena_release_tuple_key();

  // .google.protobuf.Struct context = 4 [json_name = "context", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::PROTOBUF_NAMESPACE_ID::Struct& context() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_context();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_context();
  void set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_context() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::PROTOBUF_NAMESPACE_ID::Struct* context);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_context();

  // bool expectation = 2 [json_name = "expectation", (.google.api.field_behavior) = REQUIRED];
  void clear_expectation();
  bool expectation() const;
  void set_expectation(bool value);
  private:
  bool _internal_expectation() const;
  void _internal_set_expectation(bool value);
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.Assertion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKey > contextual_tuples_;
    ::openfga::v1::AssertionTupleKey* tuple_key_;
    ::PROTOBUF_NAMESPACE_ID::Struct* context_;
    bool expectation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// -------------------------------------------------------------------

class Assertions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.Assertions) */ {
 public:
  inline Assertions() : Assertions(nullptr) {}
  ~Assertions() override;
  explicit PROTOBUF_CONSTEXPR Assertions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Assertions(const Assertions& from);
  Assertions(Assertions&& from) noexcept
    : Assertions() {
    *this = ::std::move(from);
  }

  inline Assertions& operator=(const Assertions& from) {
    CopyFrom(from);
    return *this;
  }
  inline Assertions& operator=(Assertions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Assertions& default_instance() {
    return *internal_default_instance();
  }
  static inline const Assertions* internal_default_instance() {
    return reinterpret_cast<const Assertions*>(
               &_Assertions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(Assertions& a, Assertions& b) {
    a.Swap(&b);
  }
  inline void Swap(Assertions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Assertions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Assertions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Assertions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Assertions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Assertions& from) {
    Assertions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Assertions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.Assertions";
  }
  protected:
  explicit Assertions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssertionsFieldNumber = 1,
  };
  // repeated .openfga.v1.Assertion assertions = 1 [json_name = "assertions", (.google.api.field_behavior) = REQUIRED];
  int assertions_size() const;
  private:
  int _internal_assertions_size() const;
  public:
  void clear_assertions();
  ::openfga::v1::Assertion* mutable_assertions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Assertion >*
      mutable_assertions();
  private:
  const ::openfga::v1::Assertion& _internal_assertions(int index) const;
  ::openfga::v1::Assertion* _internal_add_assertions();
  public:
  const ::openfga::v1::Assertion& assertions(int index) const;
  ::openfga::v1::Assertion* add_assertions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Assertion >&
      assertions() const;

  // @@protoc_insertion_point(class_scope:openfga.v1.Assertions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Assertion > assertions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ListObjectsRequest

// string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ListObjectsRequest::clear_store_id() {
  _impl_.store_id_.ClearToEmpty();
}
inline const std::string& ListObjectsRequest::store_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ListObjectsRequest.store_id)
  return _internal_store_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListObjectsRequest::set_store_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.store_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ListObjectsRequest.store_id)
}
inline std::string* ListObjectsRequest::mutable_store_id() {
  std::string* _s = _internal_mutable_store_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ListObjectsRequest.store_id)
  return _s;
}
inline const std::string& ListObjectsRequest::_internal_store_id() const {
  return _impl_.store_id_.Get();
}
inline void ListObjectsRequest::_internal_set_store_id(const std::string& value) {
  
  _impl_.store_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListObjectsRequest::_internal_mutable_store_id() {
  
  return _impl_.store_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListObjectsRequest::release_store_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.ListObjectsRequest.store_id)
  return _impl_.store_id_.Release();
}
inline void ListObjectsRequest::set_allocated_store_id(std::string* store_id) {
  if (store_id != nullptr) {
    
  } else {
    
  }
  _impl_.store_id_.SetAllocated(store_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.store_id_.IsDefault()) {
    _impl_.store_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ListObjectsRequest.store_id)
}

// string authorization_model_id = 2 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ListObjectsRequest::clear_authorization_model_id() {
  _impl_.authorization_model_id_.ClearToEmpty();
}
inline const std::string& ListObjectsRequest::authorization_model_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ListObjectsRequest.authorization_model_id)
  return _internal_authorization_model_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListObjectsRequest::set_authorization_model_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.authorization_model_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ListObjectsRequest.authorization_model_id)
}
inline std::string* ListObjectsRequest::mutable_authorization_model_id() {
  std::string* _s = _internal_mutable_authorization_model_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ListObjectsRequest.authorization_model_id)
  return _s;
}
inline const std::string& ListObjectsRequest::_internal_authorization_model_id() const {
  return _impl_.authorization_model_id_.Get();
}
inline void ListObjectsRequest::_internal_set_authorization_model_id(const std::string& value) {
  
  _impl_.authorization_model_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListObjectsRequest::_internal_mutable_authorization_model_id() {
  
  return _impl_.authorization_model_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListObjectsRequest::release_authorization_model_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.ListObjectsRequest.authorization_model_id)
  return _impl_.authorization_model_id_.Release();
}
inline void ListObjectsRequest::set_allocated_authorization_model_id(std::string* authorization_model_id) {
  if (authorization_model_id != nullptr) {
    
  } else {
    
  }
  _impl_.authorization_model_id_.SetAllocated(authorization_model_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.authorization_model_id_.IsDefault()) {
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ListObjectsRequest.authorization_model_id)
}

// string type = 3 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ListObjectsRequest::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& ListObjectsRequest::type() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ListObjectsRequest.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListObjectsRequest::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ListObjectsRequest.type)
}
inline std::string* ListObjectsRequest::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ListObjectsRequest.type)
  return _s;
}
inline const std::string& ListObjectsRequest::_internal_type() const {
  return _impl_.type_.Get();
}
inline void ListObjectsRequest::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* ListObjectsRequest::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* ListObjectsRequest::release_type() {
  // @@protoc_insertion_point(field_release:openfga.v1.ListObjectsRequest.type)
  return _impl_.type_.Release();
}
inline void ListObjectsRequest::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ListObjectsRequest.type)
}

// string relation = 4 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ListObjectsRequest::clear_relation() {
  _impl_.relation_.ClearToEmpty();
}
inline const std::string& ListObjectsRequest::relation() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ListObjectsRequest.relation)
  return _internal_relation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListObjectsRequest::set_relation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.relation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ListObjectsRequest.relation)
}
inline std::string* ListObjectsRequest::mutable_relation() {
  std::string* _s = _internal_mutable_relation();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ListObjectsRequest.relation)
  return _s;
}
inline const std::string& ListObjectsRequest::_internal_relation() const {
  return _impl_.relation_.Get();
}
inline void ListObjectsRequest::_internal_set_relation(const std::string& value) {
  
  _impl_.relation_.Set(value, GetArenaForAllocation());
}
inline std::string* ListObjectsRequest::_internal_mutable_relation() {
  
  return _impl_.relation_.Mutable(GetArenaForAllocation());
}
inline std::string* ListObjectsRequest::release_relation() {
  // @@protoc_insertion_point(field_release:openfga.v1.ListObjectsRequest.relation)
  return _impl_.relation_.Release();
}
inline void ListObjectsRequest::set_allocated_relation(std::string* relation) {
  if (relation != nullptr) {
    
  } else {
    
  }
  _impl_.relation_.SetAllocated(relation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.relation_.IsDefault()) {
    _impl_.relation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ListObjectsRequest.relation)
}

// string user = 5 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ListObjectsRequest::clear_user() {
  _impl_.user_.ClearToEmpty();
}
inline const std::string& ListObjectsRequest::user() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ListObjectsRequest.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListObjectsRequest::set_user(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ListObjectsRequest.user)
}
inline std::string* ListObjectsRequest::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ListObjectsRequest.user)
  return _s;
}
inline const std::string& ListObjectsRequest::_internal_user() const {
  return _impl_.user_.Get();
}
inline void ListObjectsRequest::_internal_set_user(const std::string& value) {
  
  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* ListObjectsRequest::_internal_mutable_user() {
  
  return _impl_.user_.Mutable(GetArenaForAllocation());
}
inline std::string* ListObjectsRequest::release_user() {
  // @@protoc_insertion_point(field_release:openfga.v1.ListObjectsRequest.user)
  return _impl_.user_.Release();
}
inline void ListObjectsRequest::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  _impl_.user_.SetAllocated(user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ListObjectsRequest.user)
}

// .openfga.v1.ContextualTupleKeys contextual_tuples = 6 [json_name = "contextual_tuples"];
inline bool ListObjectsRequest::_internal_has_contextual_tuples() const {
  return this != internal_default_instance() && _impl_.contextual_tuples_ != nullptr;
}
inline bool ListObjectsRequest::has_contextual_tuples() const {
  return _internal_has_contextual_tuples();
}
inline const ::openfga::v1::ContextualTupleKeys& ListObjectsRequest::_internal_contextual_tuples() const {
  const ::openfga::v1::ContextualTupleKeys* p = _impl_.contextual_tuples_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::ContextualTupleKeys&>(
      ::openfga::v1::_ContextualTupleKeys_default_instance_);
}
inline const ::openfga::v1::ContextualTupleKeys& ListObjectsRequest::contextual_tuples() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ListObjectsRequest.contextual_tuples)
  return _internal_contextual_tuples();
}
inline void ListObjectsRequest::unsafe_arena_set_allocated_contextual_tuples(
    ::openfga::v1::ContextualTupleKeys* contextual_tuples) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextual_tuples_);
  }
  _impl_.contextual_tuples_ = contextual_tuples;
  if (contextual_tuples) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.ListObjectsRequest.contextual_tuples)
}
inline ::openfga::v1::ContextualTupleKeys* ListObjectsRequest::release_contextual_tuples() {
  
  ::openfga::v1::ContextualTupleKeys* temp = _impl_.contextual_tuples_;
  _impl_.contextual_tuples_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::ContextualTupleKeys* ListObjectsRequest::unsafe_arena_release_contextual_tuples() {
  // @@protoc_insertion_point(field_release:openfga.v1.ListObjectsRequest.contextual_tuples)
  
  ::openfga::v1::ContextualTupleKeys* temp = _impl_.contextual_tuples_;
  _impl_.contextual_tuples_ = nullptr;
  return temp;
}
inline ::openfga::v1::ContextualTupleKeys* ListObjectsRequest::_internal_mutable_contextual_tuples() {
  
  if (_impl_.contextual_tuples_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::ContextualTupleKeys>(GetArenaForAllocation());
    _impl_.contextual_tuples_ = p;
  }
  return _impl_.contextual_tuples_;
}
inline ::openfga::v1::ContextualTupleKeys* ListObjectsRequest::mutable_contextual_tuples() {
  ::openfga::v1::ContextualTupleKeys* _msg = _internal_mutable_contextual_tuples();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ListObjectsRequest.contextual_tuples)
  return _msg;
}
inline void ListObjectsRequest::set_allocated_contextual_tuples(::openfga::v1::ContextualTupleKeys* contextual_tuples) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextual_tuples_);
  }
  if (contextual_tuples) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(contextual_tuples));
    if (message_arena != submessage_arena) {
      contextual_tuples = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contextual_tuples, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.contextual_tuples_ = contextual_tuples;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ListObjectsRequest.contextual_tuples)
}

// .google.protobuf.Struct context = 7 [json_name = "context"];
inline bool ListObjectsRequest::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool ListObjectsRequest::has_context() const {
  return _internal_has_context();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ListObjectsRequest::_internal_context() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ListObjectsRequest::context() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ListObjectsRequest.context)
  return _internal_context();
}
inline void ListObjectsRequest::unsafe_arena_set_allocated_context(
    ::PROTOBUF_NAMESPACE_ID::Struct* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.ListObjectsRequest.context)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ListObjectsRequest::release_context() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ListObjectsRequest::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:openfga.v1.ListObjectsRequest.context)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ListObjectsRequest::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ListObjectsRequest::mutable_context() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ListObjectsRequest.context)
  return _msg;
}
inline void ListObjectsRequest::set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(context));
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ListObjectsRequest.context)
}

// .openfga.v1.ConsistencyPreference consistency = 8 [json_name = "consistency", (.validate.rules) = {
inline void ListObjectsRequest::clear_consistency() {
  _impl_.consistency_ = 0;
}
inline ::openfga::v1::ConsistencyPreference ListObjectsRequest::_internal_consistency() const {
  return static_cast< ::openfga::v1::ConsistencyPreference >(_impl_.consistency_);
}
inline ::openfga::v1::ConsistencyPreference ListObjectsRequest::consistency() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ListObjectsRequest.consistency)
  return _internal_consistency();
}
inline void ListObjectsRequest::_internal_set_consistency(::openfga::v1::ConsistencyPreference value) {
  
  _impl_.consistency_ = value;
}
inline void ListObjectsRequest::set_consistency(::openfga::v1::ConsistencyPreference value) {
  _internal_set_consistency(value);
  // @@protoc_insertion_point(field_set:openfga.v1.ListObjectsRequest.consistency)
}

// -------------------------------------------------------------------

// ListObjectsResponse

// repeated string objects = 1 [json_name = "objects", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int ListObjectsResponse::_internal_objects_size() const {
  return _impl_.objects_.size();
}
inline int ListObjectsResponse::objects_size() const {
  return _internal_objects_size();
}
inline void ListObjectsResponse::clear_objects() {
  _impl_.objects_.Clear();
}
inline std::string* ListObjectsResponse::add_objects() {
  std::string* _s = _internal_add_objects();
  // @@protoc_insertion_point(field_add_mutable:openfga.v1.ListObjectsResponse.objects)
  return _s;
}
inline const std::string& ListObjectsResponse::_internal_objects(int index) const {
  return _impl_.objects_.Get(index);
}
inline const std::string& ListObjectsResponse::objects(int index) const {
  // @@protoc_insertion_point(field_get:openfga.v1.ListObjectsResponse.objects)
  return _internal_objects(index);
}
inline std::string* ListObjectsResponse::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:openfga.v1.ListObjectsResponse.objects)
  return _impl_.objects_.Mutable(index);
}
inline void ListObjectsResponse::set_objects(int index, const std::string& value) {
  _impl_.objects_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:openfga.v1.ListObjectsResponse.objects)
}
inline void ListObjectsResponse::set_objects(int index, std::string&& value) {
  _impl_.objects_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:openfga.v1.ListObjectsResponse.objects)
}
inline void ListObjectsResponse::set_objects(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.objects_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:openfga.v1.ListObjectsResponse.objects)
}
inline void ListObjectsResponse::set_objects(int index, const char* value, size_t size) {
  _impl_.objects_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:openfga.v1.ListObjectsResponse.objects)
}
inline std::string* ListObjectsResponse::_internal_add_objects() {
  return _impl_.objects_.Add();
}
inline void ListObjectsResponse::add_objects(const std::string& value) {
  _impl_.objects_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:openfga.v1.ListObjectsResponse.objects)
}
inline void ListObjectsResponse::add_objects(std::string&& value) {
  _impl_.objects_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:openfga.v1.ListObjectsResponse.objects)
}
inline void ListObjectsResponse::add_objects(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.objects_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:openfga.v1.ListObjectsResponse.objects)
}
inline void ListObjectsResponse::add_objects(const char* value, size_t size) {
  _impl_.objects_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:openfga.v1.ListObjectsResponse.objects)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListObjectsResponse::objects() const {
  // @@protoc_insertion_point(field_list:openfga.v1.ListObjectsResponse.objects)
  return _impl_.objects_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListObjectsResponse::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:openfga.v1.ListObjectsResponse.objects)
  return &_impl_.objects_;
}

// -------------------------------------------------------------------

// ListUsersRequest

// string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ListUsersRequest::clear_store_id() {
  _impl_.store_id_.ClearToEmpty();
}
inline const std::string& ListUsersRequest::store_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ListUsersRequest.store_id)
  return _internal_store_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListUsersRequest::set_store_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.store_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ListUsersRequest.store_id)
}
inline std::string* ListUsersRequest::mutable_store_id() {
  std::string* _s = _internal_mutable_store_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ListUsersRequest.store_id)
  return _s;
}
inline const std::string& ListUsersRequest::_internal_store_id() const {
  return _impl_.store_id_.Get();
}
inline void ListUsersRequest::_internal_set_store_id(const std::string& value) {
  
  _impl_.store_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListUsersRequest::_internal_mutable_store_id() {
  
  return _impl_.store_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListUsersRequest::release_store_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.ListUsersRequest.store_id)
  return _impl_.store_id_.Release();
}
inline void ListUsersRequest::set_allocated_store_id(std::string* store_id) {
  if (store_id != nullptr) {
    
  } else {
    
  }
  _impl_.store_id_.SetAllocated(store_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.store_id_.IsDefault()) {
    _impl_.store_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ListUsersRequest.store_id)
}

// string authorization_model_id = 2 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ListUsersRequest::clear_authorization_model_id() {
  _impl_.authorization_model_id_.ClearToEmpty();
}
inline const std::string& ListUsersRequest::authorization_model_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ListUsersRequest.authorization_model_id)
  return _internal_authorization_model_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListUsersRequest::set_authorization_model_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.authorization_model_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ListUsersRequest.authorization_model_id)
}
inline std::string* ListUsersRequest::mutable_authorization_model_id() {
  std::string* _s = _internal_mutable_authorization_model_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ListUsersRequest.authorization_model_id)
  return _s;
}
inline const std::string& ListUsersRequest::_internal_authorization_model_id() const {
  return _impl_.authorization_model_id_.Get();
}
inline void ListUsersRequest::_internal_set_authorization_model_id(const std::string& value) {
  
  _impl_.authorization_model_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListUsersRequest::_internal_mutable_authorization_model_id() {
  
  return _impl_.authorization_model_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListUsersRequest::release_authorization_model_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.ListUsersRequest.authorization_model_id)
  return _impl_.authorization_model_id_.Release();
}
inline void ListUsersRequest::set_allocated_authorization_model_id(std::string* authorization_model_id) {
  if (authorization_model_id != nullptr) {
    
  } else {
    
  }
  _impl_.authorization_model_id_.SetAllocated(authorization_model_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.authorization_model_id_.IsDefault()) {
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ListUsersRequest.authorization_model_id)
}

// .openfga.v1.Object object = 3 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline bool ListUsersRequest::_internal_has_object() const {
  return this != internal_default_instance() && _impl_.object_ != nullptr;
}
inline bool ListUsersRequest::has_object() const {
  return _internal_has_object();
}
inline const ::openfga::v1::Object& ListUsersRequest::_internal_object() const {
  const ::openfga::v1::Object* p = _impl_.object_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::Object&>(
      ::openfga::v1::_Object_default_instance_);
}
inline const ::openfga::v1::Object& ListUsersRequest::object() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ListUsersRequest.object)
  return _internal_object();
}
inline void ListUsersRequest::unsafe_arena_set_allocated_object(
    ::openfga::v1::Object* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.object_);
  }
  _impl_.object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.ListUsersRequest.object)
}
inline ::openfga::v1::Object* ListUsersRequest::release_object() {
  
  ::openfga::v1::Object* temp = _impl_.object_;
  _impl_.object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::Object* ListUsersRequest::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:openfga.v1.ListUsersRequest.object)
  
  ::openfga::v1::Object* temp = _impl_.object_;
  _impl_.object_ = nullptr;
  return temp;
}
inline ::openfga::v1::Object* ListUsersRequest::_internal_mutable_object() {
  
  if (_impl_.object_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::Object>(GetArenaForAllocation());
    _impl_.object_ = p;
  }
  return _impl_.object_;
}
inline ::openfga::v1::Object* ListUsersRequest::mutable_object() {
  ::openfga::v1::Object* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ListUsersRequest.object)
  return _msg;
}
inline void ListUsersRequest::set_allocated_object(::openfga::v1::Object* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.object_);
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object));
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.object_ = object;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ListUsersRequest.object)
}

// string relation = 4 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ListUsersRequest::clear_relation() {
  _impl_.relation_.ClearToEmpty();
}
inline const std::string& ListUsersRequest::relation() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ListUsersRequest.relation)
  return _internal_relation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListUsersRequest::set_relation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.relation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ListUsersRequest.relation)
}
inline std::string* ListUsersRequest::mutable_relation() {
  std::string* _s = _internal_mutable_relation();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ListUsersRequest.relation)
  return _s;
}
inline const std::string& ListUsersRequest::_internal_relation() const {
  return _impl_.relation_.Get();
}
inline void ListUsersRequest::_internal_set_relation(const std::string& value) {
  
  _impl_.relation_.Set(value, GetArenaForAllocation());
}
inline std::string* ListUsersRequest::_internal_mutable_relation() {
  
  return _impl_.relation_.Mutable(GetArenaForAllocation());
}
inline std::string* ListUsersRequest::release_relation() {
  // @@protoc_insertion_point(field_release:openfga.v1.ListUsersRequest.relation)
  return _impl_.relation_.Release();
}
inline void ListUsersRequest::set_allocated_relation(std::string* relation) {
  if (relation != nullptr) {
    
  } else {
    
  }
  _impl_.relation_.SetAllocated(relation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.relation_.IsDefault()) {
    _impl_.relation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ListUsersRequest.relation)
}

// repeated .openfga.v1.UserTypeFilter user_filters = 5 [json_name = "user_filters", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int ListUsersRequest::_internal_user_filters_size() const {
  return _impl_.user_filters_.size();
}
inline int ListUsersRequest::user_filters_size() const {
  return _internal_user_filters_size();
}
inline ::openfga::v1::UserTypeFilter* ListUsersRequest::mutable_user_filters(int index) {
  // @@protoc_insertion_point(field_mutable:openfga.v1.ListUsersRequest.user_filters)
  return _impl_.user_filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::UserTypeFilter >*
ListUsersRequest::mutable_user_filters() {
  // @@protoc_insertion_point(field_mutable_list:openfga.v1.ListUsersRequest.user_filters)
  return &_impl_.user_filters_;
}
inline const ::openfga::v1::UserTypeFilter& ListUsersRequest::_internal_user_filters(int index) const {
  return _impl_.user_filters_.Get(index);
}
inline const ::openfga::v1::UserTypeFilter& ListUsersRequest::user_filters(int index) const {
  // @@protoc_insertion_point(field_get:openfga.v1.ListUsersRequest.user_filters)
  return _internal_user_filters(index);
}
inline ::openfga::v1::UserTypeFilter* ListUsersRequest::_internal_add_user_filters() {
  return _impl_.user_filters_.Add();
}
inline ::openfga::v1::UserTypeFilter* ListUsersRequest::add_user_filters() {
  ::openfga::v1::UserTypeFilter* _add = _internal_add_user_filters();
  // @@protoc_insertion_point(field_add:openfga.v1.ListUsersRequest.user_filters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::UserTypeFilter >&
ListUsersRequest::user_filters() const {
  // @@protoc_insertion_point(field_list:openfga.v1.ListUsersRequest.user_filters)
  return _impl_.user_filters_;
}

// repeated .openfga.v1.TupleKey contextual_tuples = 6 [json_name = "contextual_tuples", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int ListUsersRequest::_internal_contextual_tuples_size() const {
  return _impl_.contextual_tuples_.size();
}
inline int ListUsersRequest::contextual_tuples_size() const {
  return _internal_contextual_tuples_size();
}
inline ::openfga::v1::TupleKey* ListUsersRequest::mutable_contextual_tuples(int index) {
  // @@protoc_insertion_point(field_mutable:openfga.v1.ListUsersRequest.contextual_tuples)
  return _impl_.contextual_tuples_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKey >*
ListUsersRequest::mutable_contextual_tuples() {
  // @@protoc_insertion_point(field_mutable_list:openfga.v1.ListUsersRequest.contextual_tuples)
  return &_impl_.contextual_tuples_;
}
inline const ::openfga::v1::TupleKey& ListUsersRequest::_internal_contextual_tuples(int index) const {
  return _impl_.contextual_tuples_.Get(index);
}
inline const ::openfga::v1::TupleKey& ListUsersRequest::contextual_tuples(int index) const {
  // @@protoc_insertion_point(field_get:openfga.v1.ListUsersRequest.contextual_tuples)
  return _internal_contextual_tuples(index);
}
inline ::openfga::v1::TupleKey* ListUsersRequest::_internal_add_contextual_tuples() {
  return _impl_.contextual_tuples_.Add();
}
inline ::openfga::v1::TupleKey* ListUsersRequest::add_contextual_tuples() {
  ::openfga::v1::TupleKey* _add = _internal_add_contextual_tuples();
  // @@protoc_insertion_point(field_add:openfga.v1.ListUsersRequest.contextual_tuples)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKey >&
ListUsersRequest::contextual_tuples() const {
  // @@protoc_insertion_point(field_list:openfga.v1.ListUsersRequest.contextual_tuples)
  return _impl_.contextual_tuples_;
}

// .google.protobuf.Struct context = 7 [json_name = "context"];
inline bool ListUsersRequest::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool ListUsersRequest::has_context() const {
  return _internal_has_context();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ListUsersRequest::_internal_context() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ListUsersRequest::context() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ListUsersRequest.context)
  return _internal_context();
}
inline void ListUsersRequest::unsafe_arena_set_allocated_context(
    ::PROTOBUF_NAMESPACE_ID::Struct* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.ListUsersRequest.context)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ListUsersRequest::release_context() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ListUsersRequest::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:openfga.v1.ListUsersRequest.context)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ListUsersRequest::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ListUsersRequest::mutable_context() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ListUsersRequest.context)
  return _msg;
}
inline void ListUsersRequest::set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(context));
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ListUsersRequest.context)
}

// .openfga.v1.ConsistencyPreference consistency = 8 [json_name = "consistency", (.validate.rules) = {
inline void ListUsersRequest::clear_consistency() {
  _impl_.consistency_ = 0;
}
inline ::openfga::v1::ConsistencyPreference ListUsersRequest::_internal_consistency() const {
  return static_cast< ::openfga::v1::ConsistencyPreference >(_impl_.consistency_);
}
inline ::openfga::v1::ConsistencyPreference ListUsersRequest::consistency() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ListUsersRequest.consistency)
  return _internal_consistency();
}
inline void ListUsersRequest::_internal_set_consistency(::openfga::v1::ConsistencyPreference value) {
  
  _impl_.consistency_ = value;
}
inline void ListUsersRequest::set_consistency(::openfga::v1::ConsistencyPreference value) {
  _internal_set_consistency(value);
  // @@protoc_insertion_point(field_set:openfga.v1.ListUsersRequest.consistency)
}

// -------------------------------------------------------------------

// ListUsersResponse

// repeated .openfga.v1.User users = 1 [json_name = "users", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int ListUsersResponse::_internal_users_size() const {
  return _impl_.users_.size();
}
inline int ListUsersResponse::users_size() const {
  return _internal_users_size();
}
inline ::openfga::v1::User* ListUsersResponse::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:openfga.v1.ListUsersResponse.users)
  return _impl_.users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::User >*
ListUsersResponse::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:openfga.v1.ListUsersResponse.users)
  return &_impl_.users_;
}
inline const ::openfga::v1::User& ListUsersResponse::_internal_users(int index) const {
  return _impl_.users_.Get(index);
}
inline const ::openfga::v1::User& ListUsersResponse::users(int index) const {
  // @@protoc_insertion_point(field_get:openfga.v1.ListUsersResponse.users)
  return _internal_users(index);
}
inline ::openfga::v1::User* ListUsersResponse::_internal_add_users() {
  return _impl_.users_.Add();
}
inline ::openfga::v1::User* ListUsersResponse::add_users() {
  ::openfga::v1::User* _add = _internal_add_users();
  // @@protoc_insertion_point(field_add:openfga.v1.ListUsersResponse.users)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::User >&
ListUsersResponse::users() const {
  // @@protoc_insertion_point(field_list:openfga.v1.ListUsersResponse.users)
  return _impl_.users_;
}

// -------------------------------------------------------------------

// StreamedListObjectsRequest

// string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void StreamedListObjectsRequest::clear_store_id() {
  _impl_.store_id_.ClearToEmpty();
}
inline const std::string& StreamedListObjectsRequest::store_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.StreamedListObjectsRequest.store_id)
  return _internal_store_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamedListObjectsRequest::set_store_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.store_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.StreamedListObjectsRequest.store_id)
}
inline std::string* StreamedListObjectsRequest::mutable_store_id() {
  std::string* _s = _internal_mutable_store_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.StreamedListObjectsRequest.store_id)
  return _s;
}
inline const std::string& StreamedListObjectsRequest::_internal_store_id() const {
  return _impl_.store_id_.Get();
}
inline void StreamedListObjectsRequest::_internal_set_store_id(const std::string& value) {
  
  _impl_.store_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamedListObjectsRequest::_internal_mutable_store_id() {
  
  return _impl_.store_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamedListObjectsRequest::release_store_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.StreamedListObjectsRequest.store_id)
  return _impl_.store_id_.Release();
}
inline void StreamedListObjectsRequest::set_allocated_store_id(std::string* store_id) {
  if (store_id != nullptr) {
    
  } else {
    
  }
  _impl_.store_id_.SetAllocated(store_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.store_id_.IsDefault()) {
    _impl_.store_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.StreamedListObjectsRequest.store_id)
}

// string authorization_model_id = 2 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void StreamedListObjectsRequest::clear_authorization_model_id() {
  _impl_.authorization_model_id_.ClearToEmpty();
}
inline const std::string& StreamedListObjectsRequest::authorization_model_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.StreamedListObjectsRequest.authorization_model_id)
  return _internal_authorization_model_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamedListObjectsRequest::set_authorization_model_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.authorization_model_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.StreamedListObjectsRequest.authorization_model_id)
}
inline std::string* StreamedListObjectsRequest::mutable_authorization_model_id() {
  std::string* _s = _internal_mutable_authorization_model_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.StreamedListObjectsRequest.authorization_model_id)
  return _s;
}
inline const std::string& StreamedListObjectsRequest::_internal_authorization_model_id() const {
  return _impl_.authorization_model_id_.Get();
}
inline void StreamedListObjectsRequest::_internal_set_authorization_model_id(const std::string& value) {
  
  _impl_.authorization_model_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamedListObjectsRequest::_internal_mutable_authorization_model_id() {
  
  return _impl_.authorization_model_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamedListObjectsRequest::release_authorization_model_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.StreamedListObjectsRequest.authorization_model_id)
  return _impl_.authorization_model_id_.Release();
}
inline void StreamedListObjectsRequest::set_allocated_authorization_model_id(std::string* authorization_model_id) {
  if (authorization_model_id != nullptr) {
    
  } else {
    
  }
  _impl_.authorization_model_id_.SetAllocated(authorization_model_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.authorization_model_id_.IsDefault()) {
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.StreamedListObjectsRequest.authorization_model_id)
}

// string type = 3 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void StreamedListObjectsRequest::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& StreamedListObjectsRequest::type() const {
  // @@protoc_insertion_point(field_get:openfga.v1.StreamedListObjectsRequest.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamedListObjectsRequest::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.StreamedListObjectsRequest.type)
}
inline std::string* StreamedListObjectsRequest::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:openfga.v1.StreamedListObjectsRequest.type)
  return _s;
}
inline const std::string& StreamedListObjectsRequest::_internal_type() const {
  return _impl_.type_.Get();
}
inline void StreamedListObjectsRequest::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamedListObjectsRequest::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamedListObjectsRequest::release_type() {
  // @@protoc_insertion_point(field_release:openfga.v1.StreamedListObjectsRequest.type)
  return _impl_.type_.Release();
}
inline void StreamedListObjectsRequest::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.StreamedListObjectsRequest.type)
}

// string relation = 4 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void StreamedListObjectsRequest::clear_relation() {
  _impl_.relation_.ClearToEmpty();
}
inline const std::string& StreamedListObjectsRequest::relation() const {
  // @@protoc_insertion_point(field_get:openfga.v1.StreamedListObjectsRequest.relation)
  return _internal_relation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamedListObjectsRequest::set_relation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.relation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.StreamedListObjectsRequest.relation)
}
inline std::string* StreamedListObjectsRequest::mutable_relation() {
  std::string* _s = _internal_mutable_relation();
  // @@protoc_insertion_point(field_mutable:openfga.v1.StreamedListObjectsRequest.relation)
  return _s;
}
inline const std::string& StreamedListObjectsRequest::_internal_relation() const {
  return _impl_.relation_.Get();
}
inline void StreamedListObjectsRequest::_internal_set_relation(const std::string& value) {
  
  _impl_.relation_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamedListObjectsRequest::_internal_mutable_relation() {
  
  return _impl_.relation_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamedListObjectsRequest::release_relation() {
  // @@protoc_insertion_point(field_release:openfga.v1.StreamedListObjectsRequest.relation)
  return _impl_.relation_.Release();
}
inline void StreamedListObjectsRequest::set_allocated_relation(std::string* relation) {
  if (relation != nullptr) {
    
  } else {
    
  }
  _impl_.relation_.SetAllocated(relation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.relation_.IsDefault()) {
    _impl_.relation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.StreamedListObjectsRequest.relation)
}

// string user = 5 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void StreamedListObjectsRequest::clear_user() {
  _impl_.user_.ClearToEmpty();
}
inline const std::string& StreamedListObjectsRequest::user() const {
  // @@protoc_insertion_point(field_get:openfga.v1.StreamedListObjectsRequest.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamedListObjectsRequest::set_user(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.StreamedListObjectsRequest.user)
}
inline std::string* StreamedListObjectsRequest::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:openfga.v1.StreamedListObjectsRequest.user)
  return _s;
}
inline const std::string& StreamedListObjectsRequest::_internal_user() const {
  return _impl_.user_.Get();
}
inline void StreamedListObjectsRequest::_internal_set_user(const std::string& value) {
  
  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamedListObjectsRequest::_internal_mutable_user() {
  
  return _impl_.user_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamedListObjectsRequest::release_user() {
  // @@protoc_insertion_point(field_release:openfga.v1.StreamedListObjectsRequest.user)
  return _impl_.user_.Release();
}
inline void StreamedListObjectsRequest::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  _impl_.user_.SetAllocated(user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.StreamedListObjectsRequest.user)
}

// .openfga.v1.ContextualTupleKeys contextual_tuples = 6 [json_name = "contextual_tuples"];
inline bool StreamedListObjectsRequest::_internal_has_contextual_tuples() const {
  return this != internal_default_instance() && _impl_.contextual_tuples_ != nullptr;
}
inline bool StreamedListObjectsRequest::has_contextual_tuples() const {
  return _internal_has_contextual_tuples();
}
inline const ::openfga::v1::ContextualTupleKeys& StreamedListObjectsRequest::_internal_contextual_tuples() const {
  const ::openfga::v1::ContextualTupleKeys* p = _impl_.contextual_tuples_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::ContextualTupleKeys&>(
      ::openfga::v1::_ContextualTupleKeys_default_instance_);
}
inline const ::openfga::v1::ContextualTupleKeys& StreamedListObjectsRequest::contextual_tuples() const {
  // @@protoc_insertion_point(field_get:openfga.v1.StreamedListObjectsRequest.contextual_tuples)
  return _internal_contextual_tuples();
}
inline void StreamedListObjectsRequest::unsafe_arena_set_allocated_contextual_tuples(
    ::openfga::v1::ContextualTupleKeys* contextual_tuples) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextual_tuples_);
  }
  _impl_.contextual_tuples_ = contextual_tuples;
  if (contextual_tuples) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.StreamedListObjectsRequest.contextual_tuples)
}
inline ::openfga::v1::ContextualTupleKeys* StreamedListObjectsRequest::release_contextual_tuples() {
  
  ::openfga::v1::ContextualTupleKeys* temp = _impl_.contextual_tuples_;
  _impl_.contextual_tuples_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::ContextualTupleKeys* StreamedListObjectsRequest::unsafe_arena_release_contextual_tuples() {
  // @@protoc_insertion_point(field_release:openfga.v1.StreamedListObjectsRequest.contextual_tuples)
  
  ::openfga::v1::ContextualTupleKeys* temp = _impl_.contextual_tuples_;
  _impl_.contextual_tuples_ = nullptr;
  return temp;
}
inline ::openfga::v1::ContextualTupleKeys* StreamedListObjectsRequest::_internal_mutable_contextual_tuples() {
  
  if (_impl_.contextual_tuples_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::ContextualTupleKeys>(GetArenaForAllocation());
    _impl_.contextual_tuples_ = p;
  }
  return _impl_.contextual_tuples_;
}
inline ::openfga::v1::ContextualTupleKeys* StreamedListObjectsRequest::mutable_contextual_tuples() {
  ::openfga::v1::ContextualTupleKeys* _msg = _internal_mutable_contextual_tuples();
  // @@protoc_insertion_point(field_mutable:openfga.v1.StreamedListObjectsRequest.contextual_tuples)
  return _msg;
}
inline void StreamedListObjectsRequest::set_allocated_contextual_tuples(::openfga::v1::ContextualTupleKeys* contextual_tuples) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextual_tuples_);
  }
  if (contextual_tuples) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(contextual_tuples));
    if (message_arena != submessage_arena) {
      contextual_tuples = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contextual_tuples, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.contextual_tuples_ = contextual_tuples;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.StreamedListObjectsRequest.contextual_tuples)
}

// .google.protobuf.Struct context = 7 [json_name = "context"];
inline bool StreamedListObjectsRequest::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool StreamedListObjectsRequest::has_context() const {
  return _internal_has_context();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& StreamedListObjectsRequest::_internal_context() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& StreamedListObjectsRequest::context() const {
  // @@protoc_insertion_point(field_get:openfga.v1.StreamedListObjectsRequest.context)
  return _internal_context();
}
inline void StreamedListObjectsRequest::unsafe_arena_set_allocated_context(
    ::PROTOBUF_NAMESPACE_ID::Struct* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.StreamedListObjectsRequest.context)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* StreamedListObjectsRequest::release_context() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* StreamedListObjectsRequest::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:openfga.v1.StreamedListObjectsRequest.context)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* StreamedListObjectsRequest::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* StreamedListObjectsRequest::mutable_context() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:openfga.v1.StreamedListObjectsRequest.context)
  return _msg;
}
inline void StreamedListObjectsRequest::set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(context));
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.StreamedListObjectsRequest.context)
}

// .openfga.v1.ConsistencyPreference consistency = 8 [json_name = "consistency", (.validate.rules) = {
inline void StreamedListObjectsRequest::clear_consistency() {
  _impl_.consistency_ = 0;
}
inline ::openfga::v1::ConsistencyPreference StreamedListObjectsRequest::_internal_consistency() const {
  return static_cast< ::openfga::v1::ConsistencyPreference >(_impl_.consistency_);
}
inline ::openfga::v1::ConsistencyPreference StreamedListObjectsRequest::consistency() const {
  // @@protoc_insertion_point(field_get:openfga.v1.StreamedListObjectsRequest.consistency)
  return _internal_consistency();
}
inline void StreamedListObjectsRequest::_internal_set_consistency(::openfga::v1::ConsistencyPreference value) {
  
  _impl_.consistency_ = value;
}
inline void StreamedListObjectsRequest::set_consistency(::openfga::v1::ConsistencyPreference value) {
  _internal_set_consistency(value);
  // @@protoc_insertion_point(field_set:openfga.v1.StreamedListObjectsRequest.consistency)
}

// -------------------------------------------------------------------

// StreamedListObjectsResponse

// string object = 1 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void StreamedListObjectsResponse::clear_object() {
  _impl_.object_.ClearToEmpty();
}
inline const std::string& StreamedListObjectsResponse::object() const {
  // @@protoc_insertion_point(field_get:openfga.v1.StreamedListObjectsResponse.object)
  return _internal_object();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamedListObjectsResponse::set_object(ArgT0&& arg0, ArgT... args) {
 
 _impl_.object_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.StreamedListObjectsResponse.object)
}
inline std::string* StreamedListObjectsResponse::mutable_object() {
  std::string* _s = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:openfga.v1.StreamedListObjectsResponse.object)
  return _s;
}
inline const std::string& StreamedListObjectsResponse::_internal_object() const {
  return _impl_.object_.Get();
}
inline void StreamedListObjectsResponse::_internal_set_object(const std::string& value) {
  
  _impl_.object_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamedListObjectsResponse::_internal_mutable_object() {
  
  return _impl_.object_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamedListObjectsResponse::release_object() {
  // @@protoc_insertion_point(field_release:openfga.v1.StreamedListObjectsResponse.object)
  return _impl_.object_.Release();
}
inline void StreamedListObjectsResponse::set_allocated_object(std::string* object) {
  if (object != nullptr) {
    
  } else {
    
  }
  _impl_.object_.SetAllocated(object, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.object_.IsDefault()) {
    _impl_.object_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.StreamedListObjectsResponse.object)
}

// -------------------------------------------------------------------

// ReadRequest

// string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ReadRequest::clear_store_id() {
  _impl_.store_id_.ClearToEmpty();
}
inline const std::string& ReadRequest::store_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadRequest.store_id)
  return _internal_store_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadRequest::set_store_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.store_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ReadRequest.store_id)
}
inline std::string* ReadRequest::mutable_store_id() {
  std::string* _s = _internal_mutable_store_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadRequest.store_id)
  return _s;
}
inline const std::string& ReadRequest::_internal_store_id() const {
  return _impl_.store_id_.Get();
}
inline void ReadRequest::_internal_set_store_id(const std::string& value) {
  
  _impl_.store_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadRequest::_internal_mutable_store_id() {
  
  return _impl_.store_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadRequest::release_store_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.ReadRequest.store_id)
  return _impl_.store_id_.Release();
}
inline void ReadRequest::set_allocated_store_id(std::string* store_id) {
  if (store_id != nullptr) {
    
  } else {
    
  }
  _impl_.store_id_.SetAllocated(store_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.store_id_.IsDefault()) {
    _impl_.store_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ReadRequest.store_id)
}

// .openfga.v1.ReadRequestTupleKey tuple_key = 2 [json_name = "tuple_key"];
inline bool ReadRequest::_internal_has_tuple_key() const {
  return this != internal_default_instance() && _impl_.tuple_key_ != nullptr;
}
inline bool ReadRequest::has_tuple_key() const {
  return _internal_has_tuple_key();
}
inline void ReadRequest::clear_tuple_key() {
  if (GetArenaForAllocation() == nullptr && _impl_.tuple_key_ != nullptr) {
    delete _impl_.tuple_key_;
  }
  _impl_.tuple_key_ = nullptr;
}
inline const ::openfga::v1::ReadRequestTupleKey& ReadRequest::_internal_tuple_key() const {
  const ::openfga::v1::ReadRequestTupleKey* p = _impl_.tuple_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::ReadRequestTupleKey&>(
      ::openfga::v1::_ReadRequestTupleKey_default_instance_);
}
inline const ::openfga::v1::ReadRequestTupleKey& ReadRequest::tuple_key() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadRequest.tuple_key)
  return _internal_tuple_key();
}
inline void ReadRequest::unsafe_arena_set_allocated_tuple_key(
    ::openfga::v1::ReadRequestTupleKey* tuple_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tuple_key_);
  }
  _impl_.tuple_key_ = tuple_key;
  if (tuple_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.ReadRequest.tuple_key)
}
inline ::openfga::v1::ReadRequestTupleKey* ReadRequest::release_tuple_key() {
  
  ::openfga::v1::ReadRequestTupleKey* temp = _impl_.tuple_key_;
  _impl_.tuple_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::ReadRequestTupleKey* ReadRequest::unsafe_arena_release_tuple_key() {
  // @@protoc_insertion_point(field_release:openfga.v1.ReadRequest.tuple_key)
  
  ::openfga::v1::ReadRequestTupleKey* temp = _impl_.tuple_key_;
  _impl_.tuple_key_ = nullptr;
  return temp;
}
inline ::openfga::v1::ReadRequestTupleKey* ReadRequest::_internal_mutable_tuple_key() {
  
  if (_impl_.tuple_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::ReadRequestTupleKey>(GetArenaForAllocation());
    _impl_.tuple_key_ = p;
  }
  return _impl_.tuple_key_;
}
inline ::openfga::v1::ReadRequestTupleKey* ReadRequest::mutable_tuple_key() {
  ::openfga::v1::ReadRequestTupleKey* _msg = _internal_mutable_tuple_key();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadRequest.tuple_key)
  return _msg;
}
inline void ReadRequest::set_allocated_tuple_key(::openfga::v1::ReadRequestTupleKey* tuple_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tuple_key_;
  }
  if (tuple_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tuple_key);
    if (message_arena != submessage_arena) {
      tuple_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tuple_key, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tuple_key_ = tuple_key;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ReadRequest.tuple_key)
}

// .google.protobuf.Int32Value page_size = 3 [json_name = "page_size", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline bool ReadRequest::_internal_has_page_size() const {
  return this != internal_default_instance() && _impl_.page_size_ != nullptr;
}
inline bool ReadRequest::has_page_size() const {
  return _internal_has_page_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Int32Value& ReadRequest::_internal_page_size() const {
  const ::PROTOBUF_NAMESPACE_ID::Int32Value* p = _impl_.page_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Int32Value&>(
      ::PROTOBUF_NAMESPACE_ID::_Int32Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Int32Value& ReadRequest::page_size() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadRequest.page_size)
  return _internal_page_size();
}
inline void ReadRequest::unsafe_arena_set_allocated_page_size(
    ::PROTOBUF_NAMESPACE_ID::Int32Value* page_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.page_size_);
  }
  _impl_.page_size_ = page_size;
  if (page_size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.ReadRequest.page_size)
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* ReadRequest::release_page_size() {
  
  ::PROTOBUF_NAMESPACE_ID::Int32Value* temp = _impl_.page_size_;
  _impl_.page_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* ReadRequest::unsafe_arena_release_page_size() {
  // @@protoc_insertion_point(field_release:openfga.v1.ReadRequest.page_size)
  
  ::PROTOBUF_NAMESPACE_ID::Int32Value* temp = _impl_.page_size_;
  _impl_.page_size_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* ReadRequest::_internal_mutable_page_size() {
  
  if (_impl_.page_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Int32Value>(GetArenaForAllocation());
    _impl_.page_size_ = p;
  }
  return _impl_.page_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* ReadRequest::mutable_page_size() {
  ::PROTOBUF_NAMESPACE_ID::Int32Value* _msg = _internal_mutable_page_size();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadRequest.page_size)
  return _msg;
}
inline void ReadRequest::set_allocated_page_size(::PROTOBUF_NAMESPACE_ID::Int32Value* page_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.page_size_);
  }
  if (page_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(page_size));
    if (message_arena != submessage_arena) {
      page_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, page_size, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.page_size_ = page_size;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ReadRequest.page_size)
}

// string continuation_token = 4 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ReadRequest::clear_continuation_token() {
  _impl_.continuation_token_.ClearToEmpty();
}
inline const std::string& ReadRequest::continuation_token() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadRequest.continuation_token)
  return _internal_continuation_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadRequest::set_continuation_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.continuation_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ReadRequest.continuation_token)
}
inline std::string* ReadRequest::mutable_continuation_token() {
  std::string* _s = _internal_mutable_continuation_token();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadRequest.continuation_token)
  return _s;
}
inline const std::string& ReadRequest::_internal_continuation_token() const {
  return _impl_.continuation_token_.Get();
}
inline void ReadRequest::_internal_set_continuation_token(const std::string& value) {
  
  _impl_.continuation_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadRequest::_internal_mutable_continuation_token() {
  
  return _impl_.continuation_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadRequest::release_continuation_token() {
  // @@protoc_insertion_point(field_release:openfga.v1.ReadRequest.continuation_token)
  return _impl_.continuation_token_.Release();
}
inline void ReadRequest::set_allocated_continuation_token(std::string* continuation_token) {
  if (continuation_token != nullptr) {
    
  } else {
    
  }
  _impl_.continuation_token_.SetAllocated(continuation_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.continuation_token_.IsDefault()) {
    _impl_.continuation_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ReadRequest.continuation_token)
}

// .openfga.v1.ConsistencyPreference consistency = 5 [json_name = "consistency", (.validate.rules) = {
inline void ReadRequest::clear_consistency() {
  _impl_.consistency_ = 0;
}
inline ::openfga::v1::ConsistencyPreference ReadRequest::_internal_consistency() const {
  return static_cast< ::openfga::v1::ConsistencyPreference >(_impl_.consistency_);
}
inline ::openfga::v1::ConsistencyPreference ReadRequest::consistency() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadRequest.consistency)
  return _internal_consistency();
}
inline void ReadRequest::_internal_set_consistency(::openfga::v1::ConsistencyPreference value) {
  
  _impl_.consistency_ = value;
}
inline void ReadRequest::set_consistency(::openfga::v1::ConsistencyPreference value) {
  _internal_set_consistency(value);
  // @@protoc_insertion_point(field_set:openfga.v1.ReadRequest.consistency)
}

// -------------------------------------------------------------------

// ReadRequestTupleKey

// string user = 1 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ReadRequestTupleKey::clear_user() {
  _impl_.user_.ClearToEmpty();
}
inline const std::string& ReadRequestTupleKey::user() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadRequestTupleKey.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadRequestTupleKey::set_user(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ReadRequestTupleKey.user)
}
inline std::string* ReadRequestTupleKey::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadRequestTupleKey.user)
  return _s;
}
inline const std::string& ReadRequestTupleKey::_internal_user() const {
  return _impl_.user_.Get();
}
inline void ReadRequestTupleKey::_internal_set_user(const std::string& value) {
  
  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadRequestTupleKey::_internal_mutable_user() {
  
  return _impl_.user_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadRequestTupleKey::release_user() {
  // @@protoc_insertion_point(field_release:openfga.v1.ReadRequestTupleKey.user)
  return _impl_.user_.Release();
}
inline void ReadRequestTupleKey::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  _impl_.user_.SetAllocated(user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ReadRequestTupleKey.user)
}

// string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ReadRequestTupleKey::clear_relation() {
  _impl_.relation_.ClearToEmpty();
}
inline const std::string& ReadRequestTupleKey::relation() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadRequestTupleKey.relation)
  return _internal_relation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadRequestTupleKey::set_relation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.relation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ReadRequestTupleKey.relation)
}
inline std::string* ReadRequestTupleKey::mutable_relation() {
  std::string* _s = _internal_mutable_relation();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadRequestTupleKey.relation)
  return _s;
}
inline const std::string& ReadRequestTupleKey::_internal_relation() const {
  return _impl_.relation_.Get();
}
inline void ReadRequestTupleKey::_internal_set_relation(const std::string& value) {
  
  _impl_.relation_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadRequestTupleKey::_internal_mutable_relation() {
  
  return _impl_.relation_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadRequestTupleKey::release_relation() {
  // @@protoc_insertion_point(field_release:openfga.v1.ReadRequestTupleKey.relation)
  return _impl_.relation_.Release();
}
inline void ReadRequestTupleKey::set_allocated_relation(std::string* relation) {
  if (relation != nullptr) {
    
  } else {
    
  }
  _impl_.relation_.SetAllocated(relation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.relation_.IsDefault()) {
    _impl_.relation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ReadRequestTupleKey.relation)
}

// string object = 3 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ReadRequestTupleKey::clear_object() {
  _impl_.object_.ClearToEmpty();
}
inline const std::string& ReadRequestTupleKey::object() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadRequestTupleKey.object)
  return _internal_object();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadRequestTupleKey::set_object(ArgT0&& arg0, ArgT... args) {
 
 _impl_.object_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ReadRequestTupleKey.object)
}
inline std::string* ReadRequestTupleKey::mutable_object() {
  std::string* _s = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadRequestTupleKey.object)
  return _s;
}
inline const std::string& ReadRequestTupleKey::_internal_object() const {
  return _impl_.object_.Get();
}
inline void ReadRequestTupleKey::_internal_set_object(const std::string& value) {
  
  _impl_.object_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadRequestTupleKey::_internal_mutable_object() {
  
  return _impl_.object_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadRequestTupleKey::release_object() {
  // @@protoc_insertion_point(field_release:openfga.v1.ReadRequestTupleKey.object)
  return _impl_.object_.Release();
}
inline void ReadRequestTupleKey::set_allocated_object(std::string* object) {
  if (object != nullptr) {
    
  } else {
    
  }
  _impl_.object_.SetAllocated(object, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.object_.IsDefault()) {
    _impl_.object_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ReadRequestTupleKey.object)
}

// -------------------------------------------------------------------

// ReadResponse

// repeated .openfga.v1.Tuple tuples = 1 [json_name = "tuples", (.google.api.field_behavior) = REQUIRED];
inline int ReadResponse::_internal_tuples_size() const {
  return _impl_.tuples_.size();
}
inline int ReadResponse::tuples_size() const {
  return _internal_tuples_size();
}
inline ::openfga::v1::Tuple* ReadResponse::mutable_tuples(int index) {
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadResponse.tuples)
  return _impl_.tuples_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Tuple >*
ReadResponse::mutable_tuples() {
  // @@protoc_insertion_point(field_mutable_list:openfga.v1.ReadResponse.tuples)
  return &_impl_.tuples_;
}
inline const ::openfga::v1::Tuple& ReadResponse::_internal_tuples(int index) const {
  return _impl_.tuples_.Get(index);
}
inline const ::openfga::v1::Tuple& ReadResponse::tuples(int index) const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadResponse.tuples)
  return _internal_tuples(index);
}
inline ::openfga::v1::Tuple* ReadResponse::_internal_add_tuples() {
  return _impl_.tuples_.Add();
}
inline ::openfga::v1::Tuple* ReadResponse::add_tuples() {
  ::openfga::v1::Tuple* _add = _internal_add_tuples();
  // @@protoc_insertion_point(field_add:openfga.v1.ReadResponse.tuples)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Tuple >&
ReadResponse::tuples() const {
  // @@protoc_insertion_point(field_list:openfga.v1.ReadResponse.tuples)
  return _impl_.tuples_;
}

// string continuation_token = 2 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ReadResponse::clear_continuation_token() {
  _impl_.continuation_token_.ClearToEmpty();
}
inline const std::string& ReadResponse::continuation_token() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadResponse.continuation_token)
  return _internal_continuation_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadResponse::set_continuation_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.continuation_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ReadResponse.continuation_token)
}
inline std::string* ReadResponse::mutable_continuation_token() {
  std::string* _s = _internal_mutable_continuation_token();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadResponse.continuation_token)
  return _s;
}
inline const std::string& ReadResponse::_internal_continuation_token() const {
  return _impl_.continuation_token_.Get();
}
inline void ReadResponse::_internal_set_continuation_token(const std::string& value) {
  
  _impl_.continuation_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadResponse::_internal_mutable_continuation_token() {
  
  return _impl_.continuation_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadResponse::release_continuation_token() {
  // @@protoc_insertion_point(field_release:openfga.v1.ReadResponse.continuation_token)
  return _impl_.continuation_token_.Release();
}
inline void ReadResponse::set_allocated_continuation_token(std::string* continuation_token) {
  if (continuation_token != nullptr) {
    
  } else {
    
  }
  _impl_.continuation_token_.SetAllocated(continuation_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.continuation_token_.IsDefault()) {
    _impl_.continuation_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ReadResponse.continuation_token)
}

// -------------------------------------------------------------------

// WriteRequestWrites

// repeated .openfga.v1.TupleKey tuple_keys = 1 [json_name = "tuple_keys", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int WriteRequestWrites::_internal_tuple_keys_size() const {
  return _impl_.tuple_keys_.size();
}
inline int WriteRequestWrites::tuple_keys_size() const {
  return _internal_tuple_keys_size();
}
inline ::openfga::v1::TupleKey* WriteRequestWrites::mutable_tuple_keys(int index) {
  // @@protoc_insertion_point(field_mutable:openfga.v1.WriteRequestWrites.tuple_keys)
  return _impl_.tuple_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKey >*
WriteRequestWrites::mutable_tuple_keys() {
  // @@protoc_insertion_point(field_mutable_list:openfga.v1.WriteRequestWrites.tuple_keys)
  return &_impl_.tuple_keys_;
}
inline const ::openfga::v1::TupleKey& WriteRequestWrites::_internal_tuple_keys(int index) const {
  return _impl_.tuple_keys_.Get(index);
}
inline const ::openfga::v1::TupleKey& WriteRequestWrites::tuple_keys(int index) const {
  // @@protoc_insertion_point(field_get:openfga.v1.WriteRequestWrites.tuple_keys)
  return _internal_tuple_keys(index);
}
inline ::openfga::v1::TupleKey* WriteRequestWrites::_internal_add_tuple_keys() {
  return _impl_.tuple_keys_.Add();
}
inline ::openfga::v1::TupleKey* WriteRequestWrites::add_tuple_keys() {
  ::openfga::v1::TupleKey* _add = _internal_add_tuple_keys();
  // @@protoc_insertion_point(field_add:openfga.v1.WriteRequestWrites.tuple_keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKey >&
WriteRequestWrites::tuple_keys() const {
  // @@protoc_insertion_point(field_list:openfga.v1.WriteRequestWrites.tuple_keys)
  return _impl_.tuple_keys_;
}

// string on_duplicate = 2 [json_name = "on_duplicate", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void WriteRequestWrites::clear_on_duplicate() {
  _impl_.on_duplicate_.ClearToEmpty();
}
inline const std::string& WriteRequestWrites::on_duplicate() const {
  // @@protoc_insertion_point(field_get:openfga.v1.WriteRequestWrites.on_duplicate)
  return _internal_on_duplicate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteRequestWrites::set_on_duplicate(ArgT0&& arg0, ArgT... args) {
 
 _impl_.on_duplicate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.WriteRequestWrites.on_duplicate)
}
inline std::string* WriteRequestWrites::mutable_on_duplicate() {
  std::string* _s = _internal_mutable_on_duplicate();
  // @@protoc_insertion_point(field_mutable:openfga.v1.WriteRequestWrites.on_duplicate)
  return _s;
}
inline const std::string& WriteRequestWrites::_internal_on_duplicate() const {
  return _impl_.on_duplicate_.Get();
}
inline void WriteRequestWrites::_internal_set_on_duplicate(const std::string& value) {
  
  _impl_.on_duplicate_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteRequestWrites::_internal_mutable_on_duplicate() {
  
  return _impl_.on_duplicate_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteRequestWrites::release_on_duplicate() {
  // @@protoc_insertion_point(field_release:openfga.v1.WriteRequestWrites.on_duplicate)
  return _impl_.on_duplicate_.Release();
}
inline void WriteRequestWrites::set_allocated_on_duplicate(std::string* on_duplicate) {
  if (on_duplicate != nullptr) {
    
  } else {
    
  }
  _impl_.on_duplicate_.SetAllocated(on_duplicate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.on_duplicate_.IsDefault()) {
    _impl_.on_duplicate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.WriteRequestWrites.on_duplicate)
}

// -------------------------------------------------------------------

// WriteRequestDeletes

// repeated .openfga.v1.TupleKeyWithoutCondition tuple_keys = 1 [json_name = "tuple_keys", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int WriteRequestDeletes::_internal_tuple_keys_size() const {
  return _impl_.tuple_keys_.size();
}
inline int WriteRequestDeletes::tuple_keys_size() const {
  return _internal_tuple_keys_size();
}
inline ::openfga::v1::TupleKeyWithoutCondition* WriteRequestDeletes::mutable_tuple_keys(int index) {
  // @@protoc_insertion_point(field_mutable:openfga.v1.WriteRequestDeletes.tuple_keys)
  return _impl_.tuple_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKeyWithoutCondition >*
WriteRequestDeletes::mutable_tuple_keys() {
  // @@protoc_insertion_point(field_mutable_list:openfga.v1.WriteRequestDeletes.tuple_keys)
  return &_impl_.tuple_keys_;
}
inline const ::openfga::v1::TupleKeyWithoutCondition& WriteRequestDeletes::_internal_tuple_keys(int index) const {
  return _impl_.tuple_keys_.Get(index);
}
inline const ::openfga::v1::TupleKeyWithoutCondition& WriteRequestDeletes::tuple_keys(int index) const {
  // @@protoc_insertion_point(field_get:openfga.v1.WriteRequestDeletes.tuple_keys)
  return _internal_tuple_keys(index);
}
inline ::openfga::v1::TupleKeyWithoutCondition* WriteRequestDeletes::_internal_add_tuple_keys() {
  return _impl_.tuple_keys_.Add();
}
inline ::openfga::v1::TupleKeyWithoutCondition* WriteRequestDeletes::add_tuple_keys() {
  ::openfga::v1::TupleKeyWithoutCondition* _add = _internal_add_tuple_keys();
  // @@protoc_insertion_point(field_add:openfga.v1.WriteRequestDeletes.tuple_keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKeyWithoutCondition >&
WriteRequestDeletes::tuple_keys() const {
  // @@protoc_insertion_point(field_list:openfga.v1.WriteRequestDeletes.tuple_keys)
  return _impl_.tuple_keys_;
}

// string on_missing = 2 [json_name = "on_missing", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void WriteRequestDeletes::clear_on_missing() {
  _impl_.on_missing_.ClearToEmpty();
}
inline const std::string& WriteRequestDeletes::on_missing() const {
  // @@protoc_insertion_point(field_get:openfga.v1.WriteRequestDeletes.on_missing)
  return _internal_on_missing();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteRequestDeletes::set_on_missing(ArgT0&& arg0, ArgT... args) {
 
 _impl_.on_missing_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.WriteRequestDeletes.on_missing)
}
inline std::string* WriteRequestDeletes::mutable_on_missing() {
  std::string* _s = _internal_mutable_on_missing();
  // @@protoc_insertion_point(field_mutable:openfga.v1.WriteRequestDeletes.on_missing)
  return _s;
}
inline const std::string& WriteRequestDeletes::_internal_on_missing() const {
  return _impl_.on_missing_.Get();
}
inline void WriteRequestDeletes::_internal_set_on_missing(const std::string& value) {
  
  _impl_.on_missing_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteRequestDeletes::_internal_mutable_on_missing() {
  
  return _impl_.on_missing_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteRequestDeletes::release_on_missing() {
  // @@protoc_insertion_point(field_release:openfga.v1.WriteRequestDeletes.on_missing)
  return _impl_.on_missing_.Release();
}
inline void WriteRequestDeletes::set_allocated_on_missing(std::string* on_missing) {
  if (on_missing != nullptr) {
    
  } else {
    
  }
  _impl_.on_missing_.SetAllocated(on_missing, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.on_missing_.IsDefault()) {
    _impl_.on_missing_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.WriteRequestDeletes.on_missing)
}

// -------------------------------------------------------------------

// WriteRequest

// string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void WriteRequest::clear_store_id() {
  _impl_.store_id_.ClearToEmpty();
}
inline const std::string& WriteRequest::store_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.WriteRequest.store_id)
  return _internal_store_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteRequest::set_store_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.store_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.WriteRequest.store_id)
}
inline std::string* WriteRequest::mutable_store_id() {
  std::string* _s = _internal_mutable_store_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.WriteRequest.store_id)
  return _s;
}
inline const std::string& WriteRequest::_internal_store_id() const {
  return _impl_.store_id_.Get();
}
inline void WriteRequest::_internal_set_store_id(const std::string& value) {
  
  _impl_.store_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteRequest::_internal_mutable_store_id() {
  
  return _impl_.store_id_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteRequest::release_store_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.WriteRequest.store_id)
  return _impl_.store_id_.Release();
}
inline void WriteRequest::set_allocated_store_id(std::string* store_id) {
  if (store_id != nullptr) {
    
  } else {
    
  }
  _impl_.store_id_.SetAllocated(store_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.store_id_.IsDefault()) {
    _impl_.store_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.WriteRequest.store_id)
}

// .openfga.v1.WriteRequestWrites writes = 2 [json_name = "writes"];
inline bool WriteRequest::_internal_has_writes() const {
  return this != internal_default_instance() && _impl_.writes_ != nullptr;
}
inline bool WriteRequest::has_writes() const {
  return _internal_has_writes();
}
inline void WriteRequest::clear_writes() {
  if (GetArenaForAllocation() == nullptr && _impl_.writes_ != nullptr) {
    delete _impl_.writes_;
  }
  _impl_.writes_ = nullptr;
}
inline const ::openfga::v1::WriteRequestWrites& WriteRequest::_internal_writes() const {
  const ::openfga::v1::WriteRequestWrites* p = _impl_.writes_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::WriteRequestWrites&>(
      ::openfga::v1::_WriteRequestWrites_default_instance_);
}
inline const ::openfga::v1::WriteRequestWrites& WriteRequest::writes() const {
  // @@protoc_insertion_point(field_get:openfga.v1.WriteRequest.writes)
  return _internal_writes();
}
inline void WriteRequest::unsafe_arena_set_allocated_writes(
    ::openfga::v1::WriteRequestWrites* writes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.writes_);
  }
  _impl_.writes_ = writes;
  if (writes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.WriteRequest.writes)
}
inline ::openfga::v1::WriteRequestWrites* WriteRequest::release_writes() {
  
  ::openfga::v1::WriteRequestWrites* temp = _impl_.writes_;
  _impl_.writes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::WriteRequestWrites* WriteRequest::unsafe_arena_release_writes() {
  // @@protoc_insertion_point(field_release:openfga.v1.WriteRequest.writes)
  
  ::openfga::v1::WriteRequestWrites* temp = _impl_.writes_;
  _impl_.writes_ = nullptr;
  return temp;
}
inline ::openfga::v1::WriteRequestWrites* WriteRequest::_internal_mutable_writes() {
  
  if (_impl_.writes_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::WriteRequestWrites>(GetArenaForAllocation());
    _impl_.writes_ = p;
  }
  return _impl_.writes_;
}
inline ::openfga::v1::WriteRequestWrites* WriteRequest::mutable_writes() {
  ::openfga::v1::WriteRequestWrites* _msg = _internal_mutable_writes();
  // @@protoc_insertion_point(field_mutable:openfga.v1.WriteRequest.writes)
  return _msg;
}
inline void WriteRequest::set_allocated_writes(::openfga::v1::WriteRequestWrites* writes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.writes_;
  }
  if (writes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(writes);
    if (message_arena != submessage_arena) {
      writes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, writes, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.writes_ = writes;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.WriteRequest.writes)
}

// .openfga.v1.WriteRequestDeletes deletes = 3 [json_name = "deletes"];
inline bool WriteRequest::_internal_has_deletes() const {
  return this != internal_default_instance() && _impl_.deletes_ != nullptr;
}
inline bool WriteRequest::has_deletes() const {
  return _internal_has_deletes();
}
inline void WriteRequest::clear_deletes() {
  if (GetArenaForAllocation() == nullptr && _impl_.deletes_ != nullptr) {
    delete _impl_.deletes_;
  }
  _impl_.deletes_ = nullptr;
}
inline const ::openfga::v1::WriteRequestDeletes& WriteRequest::_internal_deletes() const {
  const ::openfga::v1::WriteRequestDeletes* p = _impl_.deletes_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::WriteRequestDeletes&>(
      ::openfga::v1::_WriteRequestDeletes_default_instance_);
}
inline const ::openfga::v1::WriteRequestDeletes& WriteRequest::deletes() const {
  // @@protoc_insertion_point(field_get:openfga.v1.WriteRequest.deletes)
  return _internal_deletes();
}
inline void WriteRequest::unsafe_arena_set_allocated_deletes(
    ::openfga::v1::WriteRequestDeletes* deletes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deletes_);
  }
  _impl_.deletes_ = deletes;
  if (deletes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.WriteRequest.deletes)
}
inline ::openfga::v1::WriteRequestDeletes* WriteRequest::release_deletes() {
  
  ::openfga::v1::WriteRequestDeletes* temp = _impl_.deletes_;
  _impl_.deletes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::WriteRequestDeletes* WriteRequest::unsafe_arena_release_deletes() {
  // @@protoc_insertion_point(field_release:openfga.v1.WriteRequest.deletes)
  
  ::openfga::v1::WriteRequestDeletes* temp = _impl_.deletes_;
  _impl_.deletes_ = nullptr;
  return temp;
}
inline ::openfga::v1::WriteRequestDeletes* WriteRequest::_internal_mutable_deletes() {
  
  if (_impl_.deletes_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::WriteRequestDeletes>(GetArenaForAllocation());
    _impl_.deletes_ = p;
  }
  return _impl_.deletes_;
}
inline ::openfga::v1::WriteRequestDeletes* WriteRequest::mutable_deletes() {
  ::openfga::v1::WriteRequestDeletes* _msg = _internal_mutable_deletes();
  // @@protoc_insertion_point(field_mutable:openfga.v1.WriteRequest.deletes)
  return _msg;
}
inline void WriteRequest::set_allocated_deletes(::openfga::v1::WriteRequestDeletes* deletes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.deletes_;
  }
  if (deletes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(deletes);
    if (message_arena != submessage_arena) {
      deletes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deletes, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.deletes_ = deletes;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.WriteRequest.deletes)
}

// string authorization_model_id = 4 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void WriteRequest::clear_authorization_model_id() {
  _impl_.authorization_model_id_.ClearToEmpty();
}
inline const std::string& WriteRequest::authorization_model_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.WriteRequest.authorization_model_id)
  return _internal_authorization_model_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteRequest::set_authorization_model_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.authorization_model_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.WriteRequest.authorization_model_id)
}
inline std::string* WriteRequest::mutable_authorization_model_id() {
  std::string* _s = _internal_mutable_authorization_model_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.WriteRequest.authorization_model_id)
  return _s;
}
inline const std::string& WriteRequest::_internal_authorization_model_id() const {
  return _impl_.authorization_model_id_.Get();
}
inline void WriteRequest::_internal_set_authorization_model_id(const std::string& value) {
  
  _impl_.authorization_model_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteRequest::_internal_mutable_authorization_model_id() {
  
  return _impl_.authorization_model_id_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteRequest::release_authorization_model_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.WriteRequest.authorization_model_id)
  return _impl_.authorization_model_id_.Release();
}
inline void WriteRequest::set_allocated_authorization_model_id(std::string* authorization_model_id) {
  if (authorization_model_id != nullptr) {
    
  } else {
    
  }
  _impl_.authorization_model_id_.SetAllocated(authorization_model_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.authorization_model_id_.IsDefault()) {
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.WriteRequest.authorization_model_id)
}

// -------------------------------------------------------------------

// WriteResponse

// -------------------------------------------------------------------

// CheckRequest

// string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void CheckRequest::clear_store_id() {
  _impl_.store_id_.ClearToEmpty();
}
inline const std::string& CheckRequest::store_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.CheckRequest.store_id)
  return _internal_store_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckRequest::set_store_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.store_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.CheckRequest.store_id)
}
inline std::string* CheckRequest::mutable_store_id() {
  std::string* _s = _internal_mutable_store_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.CheckRequest.store_id)
  return _s;
}
inline const std::string& CheckRequest::_internal_store_id() const {
  return _impl_.store_id_.Get();
}
inline void CheckRequest::_internal_set_store_id(const std::string& value) {
  
  _impl_.store_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckRequest::_internal_mutable_store_id() {
  
  return _impl_.store_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CheckRequest::release_store_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.CheckRequest.store_id)
  return _impl_.store_id_.Release();
}
inline void CheckRequest::set_allocated_store_id(std::string* store_id) {
  if (store_id != nullptr) {
    
  } else {
    
  }
  _impl_.store_id_.SetAllocated(store_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.store_id_.IsDefault()) {
    _impl_.store_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.CheckRequest.store_id)
}

// .openfga.v1.CheckRequestTupleKey tuple_key = 2 [json_name = "tuple_key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool CheckRequest::_internal_has_tuple_key() const {
  return this != internal_default_instance() && _impl_.tuple_key_ != nullptr;
}
inline bool CheckRequest::has_tuple_key() const {
  return _internal_has_tuple_key();
}
inline void CheckRequest::clear_tuple_key() {
  if (GetArenaForAllocation() == nullptr && _impl_.tuple_key_ != nullptr) {
    delete _impl_.tuple_key_;
  }
  _impl_.tuple_key_ = nullptr;
}
inline const ::openfga::v1::CheckRequestTupleKey& CheckRequest::_internal_tuple_key() const {
  const ::openfga::v1::CheckRequestTupleKey* p = _impl_.tuple_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::CheckRequestTupleKey&>(
      ::openfga::v1::_CheckRequestTupleKey_default_instance_);
}
inline const ::openfga::v1::CheckRequestTupleKey& CheckRequest::tuple_key() const {
  // @@protoc_insertion_point(field_get:openfga.v1.CheckRequest.tuple_key)
  return _internal_tuple_key();
}
inline void CheckRequest::unsafe_arena_set_allocated_tuple_key(
    ::openfga::v1::CheckRequestTupleKey* tuple_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tuple_key_);
  }
  _impl_.tuple_key_ = tuple_key;
  if (tuple_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.CheckRequest.tuple_key)
}
inline ::openfga::v1::CheckRequestTupleKey* CheckRequest::release_tuple_key() {
  
  ::openfga::v1::CheckRequestTupleKey* temp = _impl_.tuple_key_;
  _impl_.tuple_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::CheckRequestTupleKey* CheckRequest::unsafe_arena_release_tuple_key() {
  // @@protoc_insertion_point(field_release:openfga.v1.CheckRequest.tuple_key)
  
  ::openfga::v1::CheckRequestTupleKey* temp = _impl_.tuple_key_;
  _impl_.tuple_key_ = nullptr;
  return temp;
}
inline ::openfga::v1::CheckRequestTupleKey* CheckRequest::_internal_mutable_tuple_key() {
  
  if (_impl_.tuple_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::CheckRequestTupleKey>(GetArenaForAllocation());
    _impl_.tuple_key_ = p;
  }
  return _impl_.tuple_key_;
}
inline ::openfga::v1::CheckRequestTupleKey* CheckRequest::mutable_tuple_key() {
  ::openfga::v1::CheckRequestTupleKey* _msg = _internal_mutable_tuple_key();
  // @@protoc_insertion_point(field_mutable:openfga.v1.CheckRequest.tuple_key)
  return _msg;
}
inline void CheckRequest::set_allocated_tuple_key(::openfga::v1::CheckRequestTupleKey* tuple_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tuple_key_;
  }
  if (tuple_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tuple_key);
    if (message_arena != submessage_arena) {
      tuple_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tuple_key, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tuple_key_ = tuple_key;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.CheckRequest.tuple_key)
}

// .openfga.v1.ContextualTupleKeys contextual_tuples = 3 [json_name = "contextual_tuples"];
inline bool CheckRequest::_internal_has_contextual_tuples() const {
  return this != internal_default_instance() && _impl_.contextual_tuples_ != nullptr;
}
inline bool CheckRequest::has_contextual_tuples() const {
  return _internal_has_contextual_tuples();
}
inline const ::openfga::v1::ContextualTupleKeys& CheckRequest::_internal_contextual_tuples() const {
  const ::openfga::v1::ContextualTupleKeys* p = _impl_.contextual_tuples_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::ContextualTupleKeys&>(
      ::openfga::v1::_ContextualTupleKeys_default_instance_);
}
inline const ::openfga::v1::ContextualTupleKeys& CheckRequest::contextual_tuples() const {
  // @@protoc_insertion_point(field_get:openfga.v1.CheckRequest.contextual_tuples)
  return _internal_contextual_tuples();
}
inline void CheckRequest::unsafe_arena_set_allocated_contextual_tuples(
    ::openfga::v1::ContextualTupleKeys* contextual_tuples) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextual_tuples_);
  }
  _impl_.contextual_tuples_ = contextual_tuples;
  if (contextual_tuples) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.CheckRequest.contextual_tuples)
}
inline ::openfga::v1::ContextualTupleKeys* CheckRequest::release_contextual_tuples() {
  
  ::openfga::v1::ContextualTupleKeys* temp = _impl_.contextual_tuples_;
  _impl_.contextual_tuples_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::ContextualTupleKeys* CheckRequest::unsafe_arena_release_contextual_tuples() {
  // @@protoc_insertion_point(field_release:openfga.v1.CheckRequest.contextual_tuples)
  
  ::openfga::v1::ContextualTupleKeys* temp = _impl_.contextual_tuples_;
  _impl_.contextual_tuples_ = nullptr;
  return temp;
}
inline ::openfga::v1::ContextualTupleKeys* CheckRequest::_internal_mutable_contextual_tuples() {
  
  if (_impl_.contextual_tuples_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::ContextualTupleKeys>(GetArenaForAllocation());
    _impl_.contextual_tuples_ = p;
  }
  return _impl_.contextual_tuples_;
}
inline ::openfga::v1::ContextualTupleKeys* CheckRequest::mutable_contextual_tuples() {
  ::openfga::v1::ContextualTupleKeys* _msg = _internal_mutable_contextual_tuples();
  // @@protoc_insertion_point(field_mutable:openfga.v1.CheckRequest.contextual_tuples)
  return _msg;
}
inline void CheckRequest::set_allocated_contextual_tuples(::openfga::v1::ContextualTupleKeys* contextual_tuples) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextual_tuples_);
  }
  if (contextual_tuples) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(contextual_tuples));
    if (message_arena != submessage_arena) {
      contextual_tuples = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contextual_tuples, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.contextual_tuples_ = contextual_tuples;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.CheckRequest.contextual_tuples)
}

// string authorization_model_id = 4 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void CheckRequest::clear_authorization_model_id() {
  _impl_.authorization_model_id_.ClearToEmpty();
}
inline const std::string& CheckRequest::authorization_model_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.CheckRequest.authorization_model_id)
  return _internal_authorization_model_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckRequest::set_authorization_model_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.authorization_model_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.CheckRequest.authorization_model_id)
}
inline std::string* CheckRequest::mutable_authorization_model_id() {
  std::string* _s = _internal_mutable_authorization_model_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.CheckRequest.authorization_model_id)
  return _s;
}
inline const std::string& CheckRequest::_internal_authorization_model_id() const {
  return _impl_.authorization_model_id_.Get();
}
inline void CheckRequest::_internal_set_authorization_model_id(const std::string& value) {
  
  _impl_.authorization_model_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckRequest::_internal_mutable_authorization_model_id() {
  
  return _impl_.authorization_model_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CheckRequest::release_authorization_model_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.CheckRequest.authorization_model_id)
  return _impl_.authorization_model_id_.Release();
}
inline void CheckRequest::set_allocated_authorization_model_id(std::string* authorization_model_id) {
  if (authorization_model_id != nullptr) {
    
  } else {
    
  }
  _impl_.authorization_model_id_.SetAllocated(authorization_model_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.authorization_model_id_.IsDefault()) {
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.CheckRequest.authorization_model_id)
}

// bool trace = 5 [json_name = "trace", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void CheckRequest::clear_trace() {
  _impl_.trace_ = false;
}
inline bool CheckRequest::_internal_trace() const {
  return _impl_.trace_;
}
inline bool CheckRequest::trace() const {
  // @@protoc_insertion_point(field_get:openfga.v1.CheckRequest.trace)
  return _internal_trace();
}
inline void CheckRequest::_internal_set_trace(bool value) {
  
  _impl_.trace_ = value;
}
inline void CheckRequest::set_trace(bool value) {
  _internal_set_trace(value);
  // @@protoc_insertion_point(field_set:openfga.v1.CheckRequest.trace)
}

// .google.protobuf.Struct context = 6 [json_name = "context"];
inline bool CheckRequest::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool CheckRequest::has_context() const {
  return _internal_has_context();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& CheckRequest::_internal_context() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& CheckRequest::context() const {
  // @@protoc_insertion_point(field_get:openfga.v1.CheckRequest.context)
  return _internal_context();
}
inline void CheckRequest::unsafe_arena_set_allocated_context(
    ::PROTOBUF_NAMESPACE_ID::Struct* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.CheckRequest.context)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CheckRequest::release_context() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CheckRequest::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:openfga.v1.CheckRequest.context)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CheckRequest::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CheckRequest::mutable_context() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:openfga.v1.CheckRequest.context)
  return _msg;
}
inline void CheckRequest::set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(context));
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.CheckRequest.context)
}

// .openfga.v1.ConsistencyPreference consistency = 7 [json_name = "consistency", (.validate.rules) = {
inline void CheckRequest::clear_consistency() {
  _impl_.consistency_ = 0;
}
inline ::openfga::v1::ConsistencyPreference CheckRequest::_internal_consistency() const {
  return static_cast< ::openfga::v1::ConsistencyPreference >(_impl_.consistency_);
}
inline ::openfga::v1::ConsistencyPreference CheckRequest::consistency() const {
  // @@protoc_insertion_point(field_get:openfga.v1.CheckRequest.consistency)
  return _internal_consistency();
}
inline void CheckRequest::_internal_set_consistency(::openfga::v1::ConsistencyPreference value) {
  
  _impl_.consistency_ = value;
}
inline void CheckRequest::set_consistency(::openfga::v1::ConsistencyPreference value) {
  _internal_set_consistency(value);
  // @@protoc_insertion_point(field_set:openfga.v1.CheckRequest.consistency)
}

// -------------------------------------------------------------------

// CheckRequestTupleKey

// string user = 1 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void CheckRequestTupleKey::clear_user() {
  _impl_.user_.ClearToEmpty();
}
inline const std::string& CheckRequestTupleKey::user() const {
  // @@protoc_insertion_point(field_get:openfga.v1.CheckRequestTupleKey.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckRequestTupleKey::set_user(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.CheckRequestTupleKey.user)
}
inline std::string* CheckRequestTupleKey::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:openfga.v1.CheckRequestTupleKey.user)
  return _s;
}
inline const std::string& CheckRequestTupleKey::_internal_user() const {
  return _impl_.user_.Get();
}
inline void CheckRequestTupleKey::_internal_set_user(const std::string& value) {
  
  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckRequestTupleKey::_internal_mutable_user() {
  
  return _impl_.user_.Mutable(GetArenaForAllocation());
}
inline std::string* CheckRequestTupleKey::release_user() {
  // @@protoc_insertion_point(field_release:openfga.v1.CheckRequestTupleKey.user)
  return _impl_.user_.Release();
}
inline void CheckRequestTupleKey::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  _impl_.user_.SetAllocated(user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.CheckRequestTupleKey.user)
}

// string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void CheckRequestTupleKey::clear_relation() {
  _impl_.relation_.ClearToEmpty();
}
inline const std::string& CheckRequestTupleKey::relation() const {
  // @@protoc_insertion_point(field_get:openfga.v1.CheckRequestTupleKey.relation)
  return _internal_relation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckRequestTupleKey::set_relation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.relation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.CheckRequestTupleKey.relation)
}
inline std::string* CheckRequestTupleKey::mutable_relation() {
  std::string* _s = _internal_mutable_relation();
  // @@protoc_insertion_point(field_mutable:openfga.v1.CheckRequestTupleKey.relation)
  return _s;
}
inline const std::string& CheckRequestTupleKey::_internal_relation() const {
  return _impl_.relation_.Get();
}
inline void CheckRequestTupleKey::_internal_set_relation(const std::string& value) {
  
  _impl_.relation_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckRequestTupleKey::_internal_mutable_relation() {
  
  return _impl_.relation_.Mutable(GetArenaForAllocation());
}
inline std::string* CheckRequestTupleKey::release_relation() {
  // @@protoc_insertion_point(field_release:openfga.v1.CheckRequestTupleKey.relation)
  return _impl_.relation_.Release();
}
inline void CheckRequestTupleKey::set_allocated_relation(std::string* relation) {
  if (relation != nullptr) {
    
  } else {
    
  }
  _impl_.relation_.SetAllocated(relation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.relation_.IsDefault()) {
    _impl_.relation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.CheckRequestTupleKey.relation)
}

// string object = 3 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void CheckRequestTupleKey::clear_object() {
  _impl_.object_.ClearToEmpty();
}
inline const std::string& CheckRequestTupleKey::object() const {
  // @@protoc_insertion_point(field_get:openfga.v1.CheckRequestTupleKey.object)
  return _internal_object();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckRequestTupleKey::set_object(ArgT0&& arg0, ArgT... args) {
 
 _impl_.object_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.CheckRequestTupleKey.object)
}
inline std::string* CheckRequestTupleKey::mutable_object() {
  std::string* _s = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:openfga.v1.CheckRequestTupleKey.object)
  return _s;
}
inline const std::string& CheckRequestTupleKey::_internal_object() const {
  return _impl_.object_.Get();
}
inline void CheckRequestTupleKey::_internal_set_object(const std::string& value) {
  
  _impl_.object_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckRequestTupleKey::_internal_mutable_object() {
  
  return _impl_.object_.Mutable(GetArenaForAllocation());
}
inline std::string* CheckRequestTupleKey::release_object() {
  // @@protoc_insertion_point(field_release:openfga.v1.CheckRequestTupleKey.object)
  return _impl_.object_.Release();
}
inline void CheckRequestTupleKey::set_allocated_object(std::string* object) {
  if (object != nullptr) {
    
  } else {
    
  }
  _impl_.object_.SetAllocated(object, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.object_.IsDefault()) {
    _impl_.object_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.CheckRequestTupleKey.object)
}

// -------------------------------------------------------------------

// CheckResponse

// bool allowed = 1 [json_name = "allowed", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void CheckResponse::clear_allowed() {
  _impl_.allowed_ = false;
}
inline bool CheckResponse::_internal_allowed() const {
  return _impl_.allowed_;
}
inline bool CheckResponse::allowed() const {
  // @@protoc_insertion_point(field_get:openfga.v1.CheckResponse.allowed)
  return _internal_allowed();
}
inline void CheckResponse::_internal_set_allowed(bool value) {
  
  _impl_.allowed_ = value;
}
inline void CheckResponse::set_allowed(bool value) {
  _internal_set_allowed(value);
  // @@protoc_insertion_point(field_set:openfga.v1.CheckResponse.allowed)
}

// string resolution = 2 [json_name = "resolution"];
inline void CheckResponse::clear_resolution() {
  _impl_.resolution_.ClearToEmpty();
}
inline const std::string& CheckResponse::resolution() const {
  // @@protoc_insertion_point(field_get:openfga.v1.CheckResponse.resolution)
  return _internal_resolution();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckResponse::set_resolution(ArgT0&& arg0, ArgT... args) {
 
 _impl_.resolution_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.CheckResponse.resolution)
}
inline std::string* CheckResponse::mutable_resolution() {
  std::string* _s = _internal_mutable_resolution();
  // @@protoc_insertion_point(field_mutable:openfga.v1.CheckResponse.resolution)
  return _s;
}
inline const std::string& CheckResponse::_internal_resolution() const {
  return _impl_.resolution_.Get();
}
inline void CheckResponse::_internal_set_resolution(const std::string& value) {
  
  _impl_.resolution_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckResponse::_internal_mutable_resolution() {
  
  return _impl_.resolution_.Mutable(GetArenaForAllocation());
}
inline std::string* CheckResponse::release_resolution() {
  // @@protoc_insertion_point(field_release:openfga.v1.CheckResponse.resolution)
  return _impl_.resolution_.Release();
}
inline void CheckResponse::set_allocated_resolution(std::string* resolution) {
  if (resolution != nullptr) {
    
  } else {
    
  }
  _impl_.resolution_.SetAllocated(resolution, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resolution_.IsDefault()) {
    _impl_.resolution_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.CheckResponse.resolution)
}

// -------------------------------------------------------------------

// BatchCheckRequest

// string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void BatchCheckRequest::clear_store_id() {
  _impl_.store_id_.ClearToEmpty();
}
inline const std::string& BatchCheckRequest::store_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.BatchCheckRequest.store_id)
  return _internal_store_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BatchCheckRequest::set_store_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.store_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.BatchCheckRequest.store_id)
}
inline std::string* BatchCheckRequest::mutable_store_id() {
  std::string* _s = _internal_mutable_store_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.BatchCheckRequest.store_id)
  return _s;
}
inline const std::string& BatchCheckRequest::_internal_store_id() const {
  return _impl_.store_id_.Get();
}
inline void BatchCheckRequest::_internal_set_store_id(const std::string& value) {
  
  _impl_.store_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BatchCheckRequest::_internal_mutable_store_id() {
  
  return _impl_.store_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BatchCheckRequest::release_store_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.BatchCheckRequest.store_id)
  return _impl_.store_id_.Release();
}
inline void BatchCheckRequest::set_allocated_store_id(std::string* store_id) {
  if (store_id != nullptr) {
    
  } else {
    
  }
  _impl_.store_id_.SetAllocated(store_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.store_id_.IsDefault()) {
    _impl_.store_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.BatchCheckRequest.store_id)
}

// repeated .openfga.v1.BatchCheckItem checks = 2 [json_name = "checks", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int BatchCheckRequest::_internal_checks_size() const {
  return _impl_.checks_.size();
}
inline int BatchCheckRequest::checks_size() const {
  return _internal_checks_size();
}
inline void BatchCheckRequest::clear_checks() {
  _impl_.checks_.Clear();
}
inline ::openfga::v1::BatchCheckItem* BatchCheckRequest::mutable_checks(int index) {
  // @@protoc_insertion_point(field_mutable:openfga.v1.BatchCheckRequest.checks)
  return _impl_.checks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::BatchCheckItem >*
BatchCheckRequest::mutable_checks() {
  // @@protoc_insertion_point(field_mutable_list:openfga.v1.BatchCheckRequest.checks)
  return &_impl_.checks_;
}
inline const ::openfga::v1::BatchCheckItem& BatchCheckRequest::_internal_checks(int index) const {
  return _impl_.checks_.Get(index);
}
inline const ::openfga::v1::BatchCheckItem& BatchCheckRequest::checks(int index) const {
  // @@protoc_insertion_point(field_get:openfga.v1.BatchCheckRequest.checks)
  return _internal_checks(index);
}
inline ::openfga::v1::BatchCheckItem* BatchCheckRequest::_internal_add_checks() {
  return _impl_.checks_.Add();
}
inline ::openfga::v1::BatchCheckItem* BatchCheckRequest::add_checks() {
  ::openfga::v1::BatchCheckItem* _add = _internal_add_checks();
  // @@protoc_insertion_point(field_add:openfga.v1.BatchCheckRequest.checks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::BatchCheckItem >&
BatchCheckRequest::checks() const {
  // @@protoc_insertion_point(field_list:openfga.v1.BatchCheckRequest.checks)
  return _impl_.checks_;
}

// string authorization_model_id = 3 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void BatchCheckRequest::clear_authorization_model_id() {
  _impl_.authorization_model_id_.ClearToEmpty();
}
inline const std::string& BatchCheckRequest::authorization_model_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.BatchCheckRequest.authorization_model_id)
  return _internal_authorization_model_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BatchCheckRequest::set_authorization_model_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.authorization_model_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.BatchCheckRequest.authorization_model_id)
}
inline std::string* BatchCheckRequest::mutable_authorization_model_id() {
  std::string* _s = _internal_mutable_authorization_model_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.BatchCheckRequest.authorization_model_id)
  return _s;
}
inline const std::string& BatchCheckRequest::_internal_authorization_model_id() const {
  return _impl_.authorization_model_id_.Get();
}
inline void BatchCheckRequest::_internal_set_authorization_model_id(const std::string& value) {
  
  _impl_.authorization_model_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BatchCheckRequest::_internal_mutable_authorization_model_id() {
  
  return _impl_.authorization_model_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BatchCheckRequest::release_authorization_model_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.BatchCheckRequest.authorization_model_id)
  return _impl_.authorization_model_id_.Release();
}
inline void BatchCheckRequest::set_allocated_authorization_model_id(std::string* authorization_model_id) {
  if (authorization_model_id != nullptr) {
    
  } else {
    
  }
  _impl_.authorization_model_id_.SetAllocated(authorization_model_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.authorization_model_id_.IsDefault()) {
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.BatchCheckRequest.authorization_model_id)
}

// .openfga.v1.ConsistencyPreference consistency = 4 [json_name = "consistency", (.validate.rules) = {
inline void BatchCheckRequest::clear_consistency() {
  _impl_.consistency_ = 0;
}
inline ::openfga::v1::ConsistencyPreference BatchCheckRequest::_internal_consistency() const {
  return static_cast< ::openfga::v1::ConsistencyPreference >(_impl_.consistency_);
}
inline ::openfga::v1::ConsistencyPreference BatchCheckRequest::consistency() const {
  // @@protoc_insertion_point(field_get:openfga.v1.BatchCheckRequest.consistency)
  return _internal_consistency();
}
inline void BatchCheckRequest::_internal_set_consistency(::openfga::v1::ConsistencyPreference value) {
  
  _impl_.consistency_ = value;
}
inline void BatchCheckRequest::set_consistency(::openfga::v1::ConsistencyPreference value) {
  _internal_set_consistency(value);
  // @@protoc_insertion_point(field_set:openfga.v1.BatchCheckRequest.consistency)
}

// -------------------------------------------------------------------

// BatchCheckItem

// .openfga.v1.CheckRequestTupleKey tuple_key = 1 [json_name = "tuple_key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool BatchCheckItem::_internal_has_tuple_key() const {
  return this != internal_default_instance() && _impl_.tuple_key_ != nullptr;
}
inline bool BatchCheckItem::has_tuple_key() const {
  return _internal_has_tuple_key();
}
inline void BatchCheckItem::clear_tuple_key() {
  if (GetArenaForAllocation() == nullptr && _impl_.tuple_key_ != nullptr) {
    delete _impl_.tuple_key_;
  }
  _impl_.tuple_key_ = nullptr;
}
inline const ::openfga::v1::CheckRequestTupleKey& BatchCheckItem::_internal_tuple_key() const {
  const ::openfga::v1::CheckRequestTupleKey* p = _impl_.tuple_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::CheckRequestTupleKey&>(
      ::openfga::v1::_CheckRequestTupleKey_default_instance_);
}
inline const ::openfga::v1::CheckRequestTupleKey& BatchCheckItem::tuple_key() const {
  // @@protoc_insertion_point(field_get:openfga.v1.BatchCheckItem.tuple_key)
  return _internal_tuple_key();
}
inline void BatchCheckItem::unsafe_arena_set_allocated_tuple_key(
    ::openfga::v1::CheckRequestTupleKey* tuple_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tuple_key_);
  }
  _impl_.tuple_key_ = tuple_key;
  if (tuple_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.BatchCheckItem.tuple_key)
}
inline ::openfga::v1::CheckRequestTupleKey* BatchCheckItem::release_tuple_key() {
  
  ::openfga::v1::CheckRequestTupleKey* temp = _impl_.tuple_key_;
  _impl_.tuple_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::CheckRequestTupleKey* BatchCheckItem::unsafe_arena_release_tuple_key() {
  // @@protoc_insertion_point(field_release:openfga.v1.BatchCheckItem.tuple_key)
  
  ::openfga::v1::CheckRequestTupleKey* temp = _impl_.tuple_key_;
  _impl_.tuple_key_ = nullptr;
  return temp;
}
inline ::openfga::v1::CheckRequestTupleKey* BatchCheckItem::_internal_mutable_tuple_key() {
  
  if (_impl_.tuple_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::CheckRequestTupleKey>(GetArenaForAllocation());
    _impl_.tuple_key_ = p;
  }
  return _impl_.tuple_key_;
}
inline ::openfga::v1::CheckRequestTupleKey* BatchCheckItem::mutable_tuple_key() {
  ::openfga::v1::CheckRequestTupleKey* _msg = _internal_mutable_tuple_key();
  // @@protoc_insertion_point(field_mutable:openfga.v1.BatchCheckItem.tuple_key)
  return _msg;
}
inline void BatchCheckItem::set_allocated_tuple_key(::openfga::v1::CheckRequestTupleKey* tuple_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tuple_key_;
  }
  if (tuple_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tuple_key);
    if (message_arena != submessage_arena) {
      tuple_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tuple_key, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tuple_key_ = tuple_key;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.BatchCheckItem.tuple_key)
}

// .openfga.v1.ContextualTupleKeys contextual_tuples = 2 [json_name = "contextual_tuples"];
inline bool BatchCheckItem::_internal_has_contextual_tuples() const {
  return this != internal_default_instance() && _impl_.contextual_tuples_ != nullptr;
}
inline bool BatchCheckItem::has_contextual_tuples() const {
  return _internal_has_contextual_tuples();
}
inline const ::openfga::v1::ContextualTupleKeys& BatchCheckItem::_internal_contextual_tuples() const {
  const ::openfga::v1::ContextualTupleKeys* p = _impl_.contextual_tuples_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::ContextualTupleKeys&>(
      ::openfga::v1::_ContextualTupleKeys_default_instance_);
}
inline const ::openfga::v1::ContextualTupleKeys& BatchCheckItem::contextual_tuples() const {
  // @@protoc_insertion_point(field_get:openfga.v1.BatchCheckItem.contextual_tuples)
  return _internal_contextual_tuples();
}
inline void BatchCheckItem::unsafe_arena_set_allocated_contextual_tuples(
    ::openfga::v1::ContextualTupleKeys* contextual_tuples) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextual_tuples_);
  }
  _impl_.contextual_tuples_ = contextual_tuples;
  if (contextual_tuples) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.BatchCheckItem.contextual_tuples)
}
inline ::openfga::v1::ContextualTupleKeys* BatchCheckItem::release_contextual_tuples() {
  
  ::openfga::v1::ContextualTupleKeys* temp = _impl_.contextual_tuples_;
  _impl_.contextual_tuples_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::ContextualTupleKeys* BatchCheckItem::unsafe_arena_release_contextual_tuples() {
  // @@protoc_insertion_point(field_release:openfga.v1.BatchCheckItem.contextual_tuples)
  
  ::openfga::v1::ContextualTupleKeys* temp = _impl_.contextual_tuples_;
  _impl_.contextual_tuples_ = nullptr;
  return temp;
}
inline ::openfga::v1::ContextualTupleKeys* BatchCheckItem::_internal_mutable_contextual_tuples() {
  
  if (_impl_.contextual_tuples_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::ContextualTupleKeys>(GetArenaForAllocation());
    _impl_.contextual_tuples_ = p;
  }
  return _impl_.contextual_tuples_;
}
inline ::openfga::v1::ContextualTupleKeys* BatchCheckItem::mutable_contextual_tuples() {
  ::openfga::v1::ContextualTupleKeys* _msg = _internal_mutable_contextual_tuples();
  // @@protoc_insertion_point(field_mutable:openfga.v1.BatchCheckItem.contextual_tuples)
  return _msg;
}
inline void BatchCheckItem::set_allocated_contextual_tuples(::openfga::v1::ContextualTupleKeys* contextual_tuples) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextual_tuples_);
  }
  if (contextual_tuples) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(contextual_tuples));
    if (message_arena != submessage_arena) {
      contextual_tuples = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contextual_tuples, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.contextual_tuples_ = contextual_tuples;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.BatchCheckItem.contextual_tuples)
}

// .google.protobuf.Struct context = 3 [json_name = "context"];
inline bool BatchCheckItem::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool BatchCheckItem::has_context() const {
  return _internal_has_context();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& BatchCheckItem::_internal_context() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& BatchCheckItem::context() const {
  // @@protoc_insertion_point(field_get:openfga.v1.BatchCheckItem.context)
  return _internal_context();
}
inline void BatchCheckItem::unsafe_arena_set_allocated_context(
    ::PROTOBUF_NAMESPACE_ID::Struct* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.BatchCheckItem.context)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* BatchCheckItem::release_context() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* BatchCheckItem::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:openfga.v1.BatchCheckItem.context)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* BatchCheckItem::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* BatchCheckItem::mutable_context() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:openfga.v1.BatchCheckItem.context)
  return _msg;
}
inline void BatchCheckItem::set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(context));
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.BatchCheckItem.context)
}

// string correlation_id = 4 [json_name = "correlation_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void BatchCheckItem::clear_correlation_id() {
  _impl_.correlation_id_.ClearToEmpty();
}
inline const std::string& BatchCheckItem::correlation_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.BatchCheckItem.correlation_id)
  return _internal_correlation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BatchCheckItem::set_correlation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.correlation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.BatchCheckItem.correlation_id)
}
inline std::string* BatchCheckItem::mutable_correlation_id() {
  std::string* _s = _internal_mutable_correlation_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.BatchCheckItem.correlation_id)
  return _s;
}
inline const std::string& BatchCheckItem::_internal_correlation_id() const {
  return _impl_.correlation_id_.Get();
}
inline void BatchCheckItem::_internal_set_correlation_id(const std::string& value) {
  
  _impl_.correlation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BatchCheckItem::_internal_mutable_correlation_id() {
  
  return _impl_.correlation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BatchCheckItem::release_correlation_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.BatchCheckItem.correlation_id)
  return _impl_.correlation_id_.Release();
}
inline void BatchCheckItem::set_allocated_correlation_id(std::string* correlation_id) {
  if (correlation_id != nullptr) {
    
  } else {
    
  }
  _impl_.correlation_id_.SetAllocated(correlation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.correlation_id_.IsDefault()) {
    _impl_.correlation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.BatchCheckItem.correlation_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// BatchCheckResponse

// map<string, .openfga.v1.BatchCheckSingleResult> result = 1 [json_name = "result", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int BatchCheckResponse::_internal_result_size() const {
  return _impl_.result_.size();
}
inline int BatchCheckResponse::result_size() const {
  return _internal_result_size();
}
inline void BatchCheckResponse::clear_result() {
  _impl_.result_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::BatchCheckSingleResult >&
BatchCheckResponse::_internal_result() const {
  return _impl_.result_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::BatchCheckSingleResult >&
BatchCheckResponse::result() const {
  // @@protoc_insertion_point(field_map:openfga.v1.BatchCheckResponse.result)
  return _internal_result();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::BatchCheckSingleResult >*
BatchCheckResponse::_internal_mutable_result() {
  return _impl_.result_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::BatchCheckSingleResult >*
BatchCheckResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable_map:openfga.v1.BatchCheckResponse.result)
  return _internal_mutable_result();
}

// -------------------------------------------------------------------

// BatchCheckSingleResult

// bool allowed = 1 [json_name = "allowed"];
inline bool BatchCheckSingleResult::_internal_has_allowed() const {
  return check_result_case() == kAllowed;
}
inline bool BatchCheckSingleResult::has_allowed() const {
  return _internal_has_allowed();
}
inline void BatchCheckSingleResult::set_has_allowed() {
  _impl_._oneof_case_[0] = kAllowed;
}
inline void BatchCheckSingleResult::clear_allowed() {
  if (_internal_has_allowed()) {
    _impl_.check_result_.allowed_ = false;
    clear_has_check_result();
  }
}
inline bool BatchCheckSingleResult::_internal_allowed() const {
  if (_internal_has_allowed()) {
    return _impl_.check_result_.allowed_;
  }
  return false;
}
inline void BatchCheckSingleResult::_internal_set_allowed(bool value) {
  if (!_internal_has_allowed()) {
    clear_check_result();
    set_has_allowed();
  }
  _impl_.check_result_.allowed_ = value;
}
inline bool BatchCheckSingleResult::allowed() const {
  // @@protoc_insertion_point(field_get:openfga.v1.BatchCheckSingleResult.allowed)
  return _internal_allowed();
}
inline void BatchCheckSingleResult::set_allowed(bool value) {
  _internal_set_allowed(value);
  // @@protoc_insertion_point(field_set:openfga.v1.BatchCheckSingleResult.allowed)
}

// .openfga.v1.CheckError error = 2 [json_name = "error"];
inline bool BatchCheckSingleResult::_internal_has_error() const {
  return check_result_case() == kError;
}
inline bool BatchCheckSingleResult::has_error() const {
  return _internal_has_error();
}
inline void BatchCheckSingleResult::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void BatchCheckSingleResult::clear_error() {
  if (_internal_has_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.check_result_.error_;
    }
    clear_has_check_result();
  }
}
inline ::openfga::v1::CheckError* BatchCheckSingleResult::release_error() {
  // @@protoc_insertion_point(field_release:openfga.v1.BatchCheckSingleResult.error)
  if (_internal_has_error()) {
    clear_has_check_result();
    ::openfga::v1::CheckError* temp = _impl_.check_result_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.check_result_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openfga::v1::CheckError& BatchCheckSingleResult::_internal_error() const {
  return _internal_has_error()
      ? *_impl_.check_result_.error_
      : reinterpret_cast< ::openfga::v1::CheckError&>(::openfga::v1::_CheckError_default_instance_);
}
inline const ::openfga::v1::CheckError& BatchCheckSingleResult::error() const {
  // @@protoc_insertion_point(field_get:openfga.v1.BatchCheckSingleResult.error)
  return _internal_error();
}
inline ::openfga::v1::CheckError* BatchCheckSingleResult::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openfga.v1.BatchCheckSingleResult.error)
  if (_internal_has_error()) {
    clear_has_check_result();
    ::openfga::v1::CheckError* temp = _impl_.check_result_.error_;
    _impl_.check_result_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchCheckSingleResult::unsafe_arena_set_allocated_error(::openfga::v1::CheckError* error) {
  clear_check_result();
  if (error) {
    set_has_error();
    _impl_.check_result_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.BatchCheckSingleResult.error)
}
inline ::openfga::v1::CheckError* BatchCheckSingleResult::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_check_result();
    set_has_error();
    _impl_.check_result_.error_ = CreateMaybeMessage< ::openfga::v1::CheckError >(GetArenaForAllocation());
  }
  return _impl_.check_result_.error_;
}
inline ::openfga::v1::CheckError* BatchCheckSingleResult::mutable_error() {
  ::openfga::v1::CheckError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:openfga.v1.BatchCheckSingleResult.error)
  return _msg;
}

inline bool BatchCheckSingleResult::has_check_result() const {
  return check_result_case() != CHECK_RESULT_NOT_SET;
}
inline void BatchCheckSingleResult::clear_has_check_result() {
  _impl_._oneof_case_[0] = CHECK_RESULT_NOT_SET;
}
inline BatchCheckSingleResult::CheckResultCase BatchCheckSingleResult::check_result_case() const {
  return BatchCheckSingleResult::CheckResultCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CheckError

// .openfga.v1.ErrorCode input_error = 1 [json_name = "input_error"];
inline bool CheckError::_internal_has_input_error() const {
  return code_case() == kInputError;
}
inline bool CheckError::has_input_error() const {
  return _internal_has_input_error();
}
inline void CheckError::set_has_input_error() {
  _impl_._oneof_case_[0] = kInputError;
}
inline void CheckError::clear_input_error() {
  if (_internal_has_input_error()) {
    _impl_.code_.input_error_ = 0;
    clear_has_code();
  }
}
inline ::openfga::v1::ErrorCode CheckError::_internal_input_error() const {
  if (_internal_has_input_error()) {
    return static_cast< ::openfga::v1::ErrorCode >(_impl_.code_.input_error_);
  }
  return static_cast< ::openfga::v1::ErrorCode >(0);
}
inline ::openfga::v1::ErrorCode CheckError::input_error() const {
  // @@protoc_insertion_point(field_get:openfga.v1.CheckError.input_error)
  return _internal_input_error();
}
inline void CheckError::_internal_set_input_error(::openfga::v1::ErrorCode value) {
  if (!_internal_has_input_error()) {
    clear_code();
    set_has_input_error();
  }
  _impl_.code_.input_error_ = value;
}
inline void CheckError::set_input_error(::openfga::v1::ErrorCode value) {
  _internal_set_input_error(value);
  // @@protoc_insertion_point(field_set:openfga.v1.CheckError.input_error)
}

// .openfga.v1.InternalErrorCode internal_error = 2 [json_name = "internal_error"];
inline bool CheckError::_internal_has_internal_error() const {
  return code_case() == kInternalError;
}
inline bool CheckError::has_internal_error() const {
  return _internal_has_internal_error();
}
inline void CheckError::set_has_internal_error() {
  _impl_._oneof_case_[0] = kInternalError;
}
inline void CheckError::clear_internal_error() {
  if (_internal_has_internal_error()) {
    _impl_.code_.internal_error_ = 0;
    clear_has_code();
  }
}
inline ::openfga::v1::InternalErrorCode CheckError::_internal_internal_error() const {
  if (_internal_has_internal_error()) {
    return static_cast< ::openfga::v1::InternalErrorCode >(_impl_.code_.internal_error_);
  }
  return static_cast< ::openfga::v1::InternalErrorCode >(0);
}
inline ::openfga::v1::InternalErrorCode CheckError::internal_error() const {
  // @@protoc_insertion_point(field_get:openfga.v1.CheckError.internal_error)
  return _internal_internal_error();
}
inline void CheckError::_internal_set_internal_error(::openfga::v1::InternalErrorCode value) {
  if (!_internal_has_internal_error()) {
    clear_code();
    set_has_internal_error();
  }
  _impl_.code_.internal_error_ = value;
}
inline void CheckError::set_internal_error(::openfga::v1::InternalErrorCode value) {
  _internal_set_internal_error(value);
  // @@protoc_insertion_point(field_set:openfga.v1.CheckError.internal_error)
}

// string message = 3 [json_name = "message"];
inline void CheckError::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& CheckError::message() const {
  // @@protoc_insertion_point(field_get:openfga.v1.CheckError.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckError::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.CheckError.message)
}
inline std::string* CheckError::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:openfga.v1.CheckError.message)
  return _s;
}
inline const std::string& CheckError::_internal_message() const {
  return _impl_.message_.Get();
}
inline void CheckError::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckError::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* CheckError::release_message() {
  // @@protoc_insertion_point(field_release:openfga.v1.CheckError.message)
  return _impl_.message_.Release();
}
inline void CheckError::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.CheckError.message)
}

inline bool CheckError::has_code() const {
  return code_case() != CODE_NOT_SET;
}
inline void CheckError::clear_has_code() {
  _impl_._oneof_case_[0] = CODE_NOT_SET;
}
inline CheckError::CodeCase CheckError::code_case() const {
  return CheckError::CodeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ExpandRequest

// string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ExpandRequest::clear_store_id() {
  _impl_.store_id_.ClearToEmpty();
}
inline const std::string& ExpandRequest::store_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ExpandRequest.store_id)
  return _internal_store_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExpandRequest::set_store_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.store_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ExpandRequest.store_id)
}
inline std::string* ExpandRequest::mutable_store_id() {
  std::string* _s = _internal_mutable_store_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ExpandRequest.store_id)
  return _s;
}
inline const std::string& ExpandRequest::_internal_store_id() const {
  return _impl_.store_id_.Get();
}
inline void ExpandRequest::_internal_set_store_id(const std::string& value) {
  
  _impl_.store_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ExpandRequest::_internal_mutable_store_id() {
  
  return _impl_.store_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ExpandRequest::release_store_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.ExpandRequest.store_id)
  return _impl_.store_id_.Release();
}
inline void ExpandRequest::set_allocated_store_id(std::string* store_id) {
  if (store_id != nullptr) {
    
  } else {
    
  }
  _impl_.store_id_.SetAllocated(store_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.store_id_.IsDefault()) {
    _impl_.store_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ExpandRequest.store_id)
}

// .openfga.v1.ExpandRequestTupleKey tuple_key = 2 [json_name = "tuple_key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool ExpandRequest::_internal_has_tuple_key() const {
  return this != internal_default_instance() && _impl_.tuple_key_ != nullptr;
}
inline bool ExpandRequest::has_tuple_key() const {
  return _internal_has_tuple_key();
}
inline void ExpandRequest::clear_tuple_key() {
  if (GetArenaForAllocation() == nullptr && _impl_.tuple_key_ != nullptr) {
    delete _impl_.tuple_key_;
  }
  _impl_.tuple_key_ = nullptr;
}
inline const ::openfga::v1::ExpandRequestTupleKey& ExpandRequest::_internal_tuple_key() const {
  const ::openfga::v1::ExpandRequestTupleKey* p = _impl_.tuple_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::ExpandRequestTupleKey&>(
      ::openfga::v1::_ExpandRequestTupleKey_default_instance_);
}
inline const ::openfga::v1::ExpandRequestTupleKey& ExpandRequest::tuple_key() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ExpandRequest.tuple_key)
  return _internal_tuple_key();
}
inline void ExpandRequest::unsafe_arena_set_allocated_tuple_key(
    ::openfga::v1::ExpandRequestTupleKey* tuple_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tuple_key_);
  }
  _impl_.tuple_key_ = tuple_key;
  if (tuple_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.ExpandRequest.tuple_key)
}
inline ::openfga::v1::ExpandRequestTupleKey* ExpandRequest::release_tuple_key() {
  
  ::openfga::v1::ExpandRequestTupleKey* temp = _impl_.tuple_key_;
  _impl_.tuple_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::ExpandRequestTupleKey* ExpandRequest::unsafe_arena_release_tuple_key() {
  // @@protoc_insertion_point(field_release:openfga.v1.ExpandRequest.tuple_key)
  
  ::openfga::v1::ExpandRequestTupleKey* temp = _impl_.tuple_key_;
  _impl_.tuple_key_ = nullptr;
  return temp;
}
inline ::openfga::v1::ExpandRequestTupleKey* ExpandRequest::_internal_mutable_tuple_key() {
  
  if (_impl_.tuple_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::ExpandRequestTupleKey>(GetArenaForAllocation());
    _impl_.tuple_key_ = p;
  }
  return _impl_.tuple_key_;
}
inline ::openfga::v1::ExpandRequestTupleKey* ExpandRequest::mutable_tuple_key() {
  ::openfga::v1::ExpandRequestTupleKey* _msg = _internal_mutable_tuple_key();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ExpandRequest.tuple_key)
  return _msg;
}
inline void ExpandRequest::set_allocated_tuple_key(::openfga::v1::ExpandRequestTupleKey* tuple_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tuple_key_;
  }
  if (tuple_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tuple_key);
    if (message_arena != submessage_arena) {
      tuple_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tuple_key, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tuple_key_ = tuple_key;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ExpandRequest.tuple_key)
}

// string authorization_model_id = 3 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ExpandRequest::clear_authorization_model_id() {
  _impl_.authorization_model_id_.ClearToEmpty();
}
inline const std::string& ExpandRequest::authorization_model_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ExpandRequest.authorization_model_id)
  return _internal_authorization_model_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExpandRequest::set_authorization_model_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.authorization_model_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ExpandRequest.authorization_model_id)
}
inline std::string* ExpandRequest::mutable_authorization_model_id() {
  std::string* _s = _internal_mutable_authorization_model_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ExpandRequest.authorization_model_id)
  return _s;
}
inline const std::string& ExpandRequest::_internal_authorization_model_id() const {
  return _impl_.authorization_model_id_.Get();
}
inline void ExpandRequest::_internal_set_authorization_model_id(const std::string& value) {
  
  _impl_.authorization_model_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ExpandRequest::_internal_mutable_authorization_model_id() {
  
  return _impl_.authorization_model_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ExpandRequest::release_authorization_model_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.ExpandRequest.authorization_model_id)
  return _impl_.authorization_model_id_.Release();
}
inline void ExpandRequest::set_allocated_authorization_model_id(std::string* authorization_model_id) {
  if (authorization_model_id != nullptr) {
    
  } else {
    
  }
  _impl_.authorization_model_id_.SetAllocated(authorization_model_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.authorization_model_id_.IsDefault()) {
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ExpandRequest.authorization_model_id)
}

// .openfga.v1.ConsistencyPreference consistency = 4 [json_name = "consistency", (.validate.rules) = {
inline void ExpandRequest::clear_consistency() {
  _impl_.consistency_ = 0;
}
inline ::openfga::v1::ConsistencyPreference ExpandRequest::_internal_consistency() const {
  return static_cast< ::openfga::v1::ConsistencyPreference >(_impl_.consistency_);
}
inline ::openfga::v1::ConsistencyPreference ExpandRequest::consistency() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ExpandRequest.consistency)
  return _internal_consistency();
}
inline void ExpandRequest::_internal_set_consistency(::openfga::v1::ConsistencyPreference value) {
  
  _impl_.consistency_ = value;
}
inline void ExpandRequest::set_consistency(::openfga::v1::ConsistencyPreference value) {
  _internal_set_consistency(value);
  // @@protoc_insertion_point(field_set:openfga.v1.ExpandRequest.consistency)
}

// .openfga.v1.ContextualTupleKeys contextual_tuples = 5 [json_name = "contextual_tuples"];
inline bool ExpandRequest::_internal_has_contextual_tuples() const {
  return this != internal_default_instance() && _impl_.contextual_tuples_ != nullptr;
}
inline bool ExpandRequest::has_contextual_tuples() const {
  return _internal_has_contextual_tuples();
}
inline const ::openfga::v1::ContextualTupleKeys& ExpandRequest::_internal_contextual_tuples() const {
  const ::openfga::v1::ContextualTupleKeys* p = _impl_.contextual_tuples_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::ContextualTupleKeys&>(
      ::openfga::v1::_ContextualTupleKeys_default_instance_);
}
inline const ::openfga::v1::ContextualTupleKeys& ExpandRequest::contextual_tuples() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ExpandRequest.contextual_tuples)
  return _internal_contextual_tuples();
}
inline void ExpandRequest::unsafe_arena_set_allocated_contextual_tuples(
    ::openfga::v1::ContextualTupleKeys* contextual_tuples) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextual_tuples_);
  }
  _impl_.contextual_tuples_ = contextual_tuples;
  if (contextual_tuples) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.ExpandRequest.contextual_tuples)
}
inline ::openfga::v1::ContextualTupleKeys* ExpandRequest::release_contextual_tuples() {
  
  ::openfga::v1::ContextualTupleKeys* temp = _impl_.contextual_tuples_;
  _impl_.contextual_tuples_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::ContextualTupleKeys* ExpandRequest::unsafe_arena_release_contextual_tuples() {
  // @@protoc_insertion_point(field_release:openfga.v1.ExpandRequest.contextual_tuples)
  
  ::openfga::v1::ContextualTupleKeys* temp = _impl_.contextual_tuples_;
  _impl_.contextual_tuples_ = nullptr;
  return temp;
}
inline ::openfga::v1::ContextualTupleKeys* ExpandRequest::_internal_mutable_contextual_tuples() {
  
  if (_impl_.contextual_tuples_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::ContextualTupleKeys>(GetArenaForAllocation());
    _impl_.contextual_tuples_ = p;
  }
  return _impl_.contextual_tuples_;
}
inline ::openfga::v1::ContextualTupleKeys* ExpandRequest::mutable_contextual_tuples() {
  ::openfga::v1::ContextualTupleKeys* _msg = _internal_mutable_contextual_tuples();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ExpandRequest.contextual_tuples)
  return _msg;
}
inline void ExpandRequest::set_allocated_contextual_tuples(::openfga::v1::ContextualTupleKeys* contextual_tuples) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contextual_tuples_);
  }
  if (contextual_tuples) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(contextual_tuples));
    if (message_arena != submessage_arena) {
      contextual_tuples = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contextual_tuples, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.contextual_tuples_ = contextual_tuples;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ExpandRequest.contextual_tuples)
}

// -------------------------------------------------------------------

// ExpandRequestTupleKey

// string relation = 1 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ExpandRequestTupleKey::clear_relation() {
  _impl_.relation_.ClearToEmpty();
}
inline const std::string& ExpandRequestTupleKey::relation() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ExpandRequestTupleKey.relation)
  return _internal_relation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExpandRequestTupleKey::set_relation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.relation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ExpandRequestTupleKey.relation)
}
inline std::string* ExpandRequestTupleKey::mutable_relation() {
  std::string* _s = _internal_mutable_relation();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ExpandRequestTupleKey.relation)
  return _s;
}
inline const std::string& ExpandRequestTupleKey::_internal_relation() const {
  return _impl_.relation_.Get();
}
inline void ExpandRequestTupleKey::_internal_set_relation(const std::string& value) {
  
  _impl_.relation_.Set(value, GetArenaForAllocation());
}
inline std::string* ExpandRequestTupleKey::_internal_mutable_relation() {
  
  return _impl_.relation_.Mutable(GetArenaForAllocation());
}
inline std::string* ExpandRequestTupleKey::release_relation() {
  // @@protoc_insertion_point(field_release:openfga.v1.ExpandRequestTupleKey.relation)
  return _impl_.relation_.Release();
}
inline void ExpandRequestTupleKey::set_allocated_relation(std::string* relation) {
  if (relation != nullptr) {
    
  } else {
    
  }
  _impl_.relation_.SetAllocated(relation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.relation_.IsDefault()) {
    _impl_.relation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ExpandRequestTupleKey.relation)
}

// string object = 2 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ExpandRequestTupleKey::clear_object() {
  _impl_.object_.ClearToEmpty();
}
inline const std::string& ExpandRequestTupleKey::object() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ExpandRequestTupleKey.object)
  return _internal_object();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExpandRequestTupleKey::set_object(ArgT0&& arg0, ArgT... args) {
 
 _impl_.object_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ExpandRequestTupleKey.object)
}
inline std::string* ExpandRequestTupleKey::mutable_object() {
  std::string* _s = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ExpandRequestTupleKey.object)
  return _s;
}
inline const std::string& ExpandRequestTupleKey::_internal_object() const {
  return _impl_.object_.Get();
}
inline void ExpandRequestTupleKey::_internal_set_object(const std::string& value) {
  
  _impl_.object_.Set(value, GetArenaForAllocation());
}
inline std::string* ExpandRequestTupleKey::_internal_mutable_object() {
  
  return _impl_.object_.Mutable(GetArenaForAllocation());
}
inline std::string* ExpandRequestTupleKey::release_object() {
  // @@protoc_insertion_point(field_release:openfga.v1.ExpandRequestTupleKey.object)
  return _impl_.object_.Release();
}
inline void ExpandRequestTupleKey::set_allocated_object(std::string* object) {
  if (object != nullptr) {
    
  } else {
    
  }
  _impl_.object_.SetAllocated(object, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.object_.IsDefault()) {
    _impl_.object_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ExpandRequestTupleKey.object)
}

// -------------------------------------------------------------------

// ExpandResponse

// .openfga.v1.UsersetTree tree = 1 [json_name = "tree"];
inline bool ExpandResponse::_internal_has_tree() const {
  return this != internal_default_instance() && _impl_.tree_ != nullptr;
}
inline bool ExpandResponse::has_tree() const {
  return _internal_has_tree();
}
inline const ::openfga::v1::UsersetTree& ExpandResponse::_internal_tree() const {
  const ::openfga::v1::UsersetTree* p = _impl_.tree_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::UsersetTree&>(
      ::openfga::v1::_UsersetTree_default_instance_);
}
inline const ::openfga::v1::UsersetTree& ExpandResponse::tree() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ExpandResponse.tree)
  return _internal_tree();
}
inline void ExpandResponse::unsafe_arena_set_allocated_tree(
    ::openfga::v1::UsersetTree* tree) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tree_);
  }
  _impl_.tree_ = tree;
  if (tree) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.ExpandResponse.tree)
}
inline ::openfga::v1::UsersetTree* ExpandResponse::release_tree() {
  
  ::openfga::v1::UsersetTree* temp = _impl_.tree_;
  _impl_.tree_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::UsersetTree* ExpandResponse::unsafe_arena_release_tree() {
  // @@protoc_insertion_point(field_release:openfga.v1.ExpandResponse.tree)
  
  ::openfga::v1::UsersetTree* temp = _impl_.tree_;
  _impl_.tree_ = nullptr;
  return temp;
}
inline ::openfga::v1::UsersetTree* ExpandResponse::_internal_mutable_tree() {
  
  if (_impl_.tree_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::UsersetTree>(GetArenaForAllocation());
    _impl_.tree_ = p;
  }
  return _impl_.tree_;
}
inline ::openfga::v1::UsersetTree* ExpandResponse::mutable_tree() {
  ::openfga::v1::UsersetTree* _msg = _internal_mutable_tree();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ExpandResponse.tree)
  return _msg;
}
inline void ExpandResponse::set_allocated_tree(::openfga::v1::UsersetTree* tree) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tree_);
  }
  if (tree) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tree));
    if (message_arena != submessage_arena) {
      tree = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tree, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tree_ = tree;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ExpandResponse.tree)
}

// -------------------------------------------------------------------

// ReadAuthorizationModelRequest

// string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ReadAuthorizationModelRequest::clear_store_id() {
  _impl_.store_id_.ClearToEmpty();
}
inline const std::string& ReadAuthorizationModelRequest::store_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadAuthorizationModelRequest.store_id)
  return _internal_store_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadAuthorizationModelRequest::set_store_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.store_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ReadAuthorizationModelRequest.store_id)
}
inline std::string* ReadAuthorizationModelRequest::mutable_store_id() {
  std::string* _s = _internal_mutable_store_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadAuthorizationModelRequest.store_id)
  return _s;
}
inline const std::string& ReadAuthorizationModelRequest::_internal_store_id() const {
  return _impl_.store_id_.Get();
}
inline void ReadAuthorizationModelRequest::_internal_set_store_id(const std::string& value) {
  
  _impl_.store_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadAuthorizationModelRequest::_internal_mutable_store_id() {
  
  return _impl_.store_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadAuthorizationModelRequest::release_store_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.ReadAuthorizationModelRequest.store_id)
  return _impl_.store_id_.Release();
}
inline void ReadAuthorizationModelRequest::set_allocated_store_id(std::string* store_id) {
  if (store_id != nullptr) {
    
  } else {
    
  }
  _impl_.store_id_.SetAllocated(store_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.store_id_.IsDefault()) {
    _impl_.store_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ReadAuthorizationModelRequest.store_id)
}

// string id = 2 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ReadAuthorizationModelRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ReadAuthorizationModelRequest::id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadAuthorizationModelRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadAuthorizationModelRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ReadAuthorizationModelRequest.id)
}
inline std::string* ReadAuthorizationModelRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadAuthorizationModelRequest.id)
  return _s;
}
inline const std::string& ReadAuthorizationModelRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ReadAuthorizationModelRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadAuthorizationModelRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadAuthorizationModelRequest::release_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.ReadAuthorizationModelRequest.id)
  return _impl_.id_.Release();
}
inline void ReadAuthorizationModelRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ReadAuthorizationModelRequest.id)
}

// -------------------------------------------------------------------

// ReadAuthorizationModelResponse

// .openfga.v1.AuthorizationModel authorization_model = 1 [json_name = "authorization_model"];
inline bool ReadAuthorizationModelResponse::_internal_has_authorization_model() const {
  return this != internal_default_instance() && _impl_.authorization_model_ != nullptr;
}
inline bool ReadAuthorizationModelResponse::has_authorization_model() const {
  return _internal_has_authorization_model();
}
inline const ::openfga::v1::AuthorizationModel& ReadAuthorizationModelResponse::_internal_authorization_model() const {
  const ::openfga::v1::AuthorizationModel* p = _impl_.authorization_model_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::AuthorizationModel&>(
      ::openfga::v1::_AuthorizationModel_default_instance_);
}
inline const ::openfga::v1::AuthorizationModel& ReadAuthorizationModelResponse::authorization_model() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadAuthorizationModelResponse.authorization_model)
  return _internal_authorization_model();
}
inline void ReadAuthorizationModelResponse::unsafe_arena_set_allocated_authorization_model(
    ::openfga::v1::AuthorizationModel* authorization_model) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.authorization_model_);
  }
  _impl_.authorization_model_ = authorization_model;
  if (authorization_model) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.ReadAuthorizationModelResponse.authorization_model)
}
inline ::openfga::v1::AuthorizationModel* ReadAuthorizationModelResponse::release_authorization_model() {
  
  ::openfga::v1::AuthorizationModel* temp = _impl_.authorization_model_;
  _impl_.authorization_model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::AuthorizationModel* ReadAuthorizationModelResponse::unsafe_arena_release_authorization_model() {
  // @@protoc_insertion_point(field_release:openfga.v1.ReadAuthorizationModelResponse.authorization_model)
  
  ::openfga::v1::AuthorizationModel* temp = _impl_.authorization_model_;
  _impl_.authorization_model_ = nullptr;
  return temp;
}
inline ::openfga::v1::AuthorizationModel* ReadAuthorizationModelResponse::_internal_mutable_authorization_model() {
  
  if (_impl_.authorization_model_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::AuthorizationModel>(GetArenaForAllocation());
    _impl_.authorization_model_ = p;
  }
  return _impl_.authorization_model_;
}
inline ::openfga::v1::AuthorizationModel* ReadAuthorizationModelResponse::mutable_authorization_model() {
  ::openfga::v1::AuthorizationModel* _msg = _internal_mutable_authorization_model();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadAuthorizationModelResponse.authorization_model)
  return _msg;
}
inline void ReadAuthorizationModelResponse::set_allocated_authorization_model(::openfga::v1::AuthorizationModel* authorization_model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.authorization_model_);
  }
  if (authorization_model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(authorization_model));
    if (message_arena != submessage_arena) {
      authorization_model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, authorization_model, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.authorization_model_ = authorization_model;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ReadAuthorizationModelResponse.authorization_model)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// WriteAuthorizationModelRequest

// string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void WriteAuthorizationModelRequest::clear_store_id() {
  _impl_.store_id_.ClearToEmpty();
}
inline const std::string& WriteAuthorizationModelRequest::store_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.WriteAuthorizationModelRequest.store_id)
  return _internal_store_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteAuthorizationModelRequest::set_store_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.store_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.WriteAuthorizationModelRequest.store_id)
}
inline std::string* WriteAuthorizationModelRequest::mutable_store_id() {
  std::string* _s = _internal_mutable_store_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.WriteAuthorizationModelRequest.store_id)
  return _s;
}
inline const std::string& WriteAuthorizationModelRequest::_internal_store_id() const {
  return _impl_.store_id_.Get();
}
inline void WriteAuthorizationModelRequest::_internal_set_store_id(const std::string& value) {
  
  _impl_.store_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteAuthorizationModelRequest::_internal_mutable_store_id() {
  
  return _impl_.store_id_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteAuthorizationModelRequest::release_store_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.WriteAuthorizationModelRequest.store_id)
  return _impl_.store_id_.Release();
}
inline void WriteAuthorizationModelRequest::set_allocated_store_id(std::string* store_id) {
  if (store_id != nullptr) {
    
  } else {
    
  }
  _impl_.store_id_.SetAllocated(store_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.store_id_.IsDefault()) {
    _impl_.store_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.WriteAuthorizationModelRequest.store_id)
}

// repeated .openfga.v1.TypeDefinition type_definitions = 2 [json_name = "type_definitions", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int WriteAuthorizationModelRequest::_internal_type_definitions_size() const {
  return _impl_.type_definitions_.size();
}
inline int WriteAuthorizationModelRequest::type_definitions_size() const {
  return _internal_type_definitions_size();
}
inline ::openfga::v1::TypeDefinition* WriteAuthorizationModelRequest::mutable_type_definitions(int index) {
  // @@protoc_insertion_point(field_mutable:openfga.v1.WriteAuthorizationModelRequest.type_definitions)
  return _impl_.type_definitions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TypeDefinition >*
WriteAuthorizationModelRequest::mutable_type_definitions() {
  // @@protoc_insertion_point(field_mutable_list:openfga.v1.WriteAuthorizationModelRequest.type_definitions)
  return &_impl_.type_definitions_;
}
inline const ::openfga::v1::TypeDefinition& WriteAuthorizationModelRequest::_internal_type_definitions(int index) const {
  return _impl_.type_definitions_.Get(index);
}
inline const ::openfga::v1::TypeDefinition& WriteAuthorizationModelRequest::type_definitions(int index) const {
  // @@protoc_insertion_point(field_get:openfga.v1.WriteAuthorizationModelRequest.type_definitions)
  return _internal_type_definitions(index);
}
inline ::openfga::v1::TypeDefinition* WriteAuthorizationModelRequest::_internal_add_type_definitions() {
  return _impl_.type_definitions_.Add();
}
inline ::openfga::v1::TypeDefinition* WriteAuthorizationModelRequest::add_type_definitions() {
  ::openfga::v1::TypeDefinition* _add = _internal_add_type_definitions();
  // @@protoc_insertion_point(field_add:openfga.v1.WriteAuthorizationModelRequest.type_definitions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TypeDefinition >&
WriteAuthorizationModelRequest::type_definitions() const {
  // @@protoc_insertion_point(field_list:openfga.v1.WriteAuthorizationModelRequest.type_definitions)
  return _impl_.type_definitions_;
}

// string schema_version = 3 [json_name = "schema_version", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void WriteAuthorizationModelRequest::clear_schema_version() {
  _impl_.schema_version_.ClearToEmpty();
}
inline const std::string& WriteAuthorizationModelRequest::schema_version() const {
  // @@protoc_insertion_point(field_get:openfga.v1.WriteAuthorizationModelRequest.schema_version)
  return _internal_schema_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteAuthorizationModelRequest::set_schema_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.WriteAuthorizationModelRequest.schema_version)
}
inline std::string* WriteAuthorizationModelRequest::mutable_schema_version() {
  std::string* _s = _internal_mutable_schema_version();
  // @@protoc_insertion_point(field_mutable:openfga.v1.WriteAuthorizationModelRequest.schema_version)
  return _s;
}
inline const std::string& WriteAuthorizationModelRequest::_internal_schema_version() const {
  return _impl_.schema_version_.Get();
}
inline void WriteAuthorizationModelRequest::_internal_set_schema_version(const std::string& value) {
  
  _impl_.schema_version_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteAuthorizationModelRequest::_internal_mutable_schema_version() {
  
  return _impl_.schema_version_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteAuthorizationModelRequest::release_schema_version() {
  // @@protoc_insertion_point(field_release:openfga.v1.WriteAuthorizationModelRequest.schema_version)
  return _impl_.schema_version_.Release();
}
inline void WriteAuthorizationModelRequest::set_allocated_schema_version(std::string* schema_version) {
  if (schema_version != nullptr) {
    
  } else {
    
  }
  _impl_.schema_version_.SetAllocated(schema_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_version_.IsDefault()) {
    _impl_.schema_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.WriteAuthorizationModelRequest.schema_version)
}

// map<string, .openfga.v1.Condition> conditions = 4 [json_name = "conditions", (.validate.rules) = {
inline int WriteAuthorizationModelRequest::_internal_conditions_size() const {
  return _impl_.conditions_.size();
}
inline int WriteAuthorizationModelRequest::conditions_size() const {
  return _internal_conditions_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::Condition >&
WriteAuthorizationModelRequest::_internal_conditions() const {
  return _impl_.conditions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::Condition >&
WriteAuthorizationModelRequest::conditions() const {
  // @@protoc_insertion_point(field_map:openfga.v1.WriteAuthorizationModelRequest.conditions)
  return _internal_conditions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::Condition >*
WriteAuthorizationModelRequest::_internal_mutable_conditions() {
  return _impl_.conditions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::Condition >*
WriteAuthorizationModelRequest::mutable_conditions() {
  // @@protoc_insertion_point(field_mutable_map:openfga.v1.WriteAuthorizationModelRequest.conditions)
  return _internal_mutable_conditions();
}

// -------------------------------------------------------------------

// WriteAuthorizationModelResponse

// string authorization_model_id = 1 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void WriteAuthorizationModelResponse::clear_authorization_model_id() {
  _impl_.authorization_model_id_.ClearToEmpty();
}
inline const std::string& WriteAuthorizationModelResponse::authorization_model_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.WriteAuthorizationModelResponse.authorization_model_id)
  return _internal_authorization_model_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteAuthorizationModelResponse::set_authorization_model_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.authorization_model_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.WriteAuthorizationModelResponse.authorization_model_id)
}
inline std::string* WriteAuthorizationModelResponse::mutable_authorization_model_id() {
  std::string* _s = _internal_mutable_authorization_model_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.WriteAuthorizationModelResponse.authorization_model_id)
  return _s;
}
inline const std::string& WriteAuthorizationModelResponse::_internal_authorization_model_id() const {
  return _impl_.authorization_model_id_.Get();
}
inline void WriteAuthorizationModelResponse::_internal_set_authorization_model_id(const std::string& value) {
  
  _impl_.authorization_model_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteAuthorizationModelResponse::_internal_mutable_authorization_model_id() {
  
  return _impl_.authorization_model_id_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteAuthorizationModelResponse::release_authorization_model_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.WriteAuthorizationModelResponse.authorization_model_id)
  return _impl_.authorization_model_id_.Release();
}
inline void WriteAuthorizationModelResponse::set_allocated_authorization_model_id(std::string* authorization_model_id) {
  if (authorization_model_id != nullptr) {
    
  } else {
    
  }
  _impl_.authorization_model_id_.SetAllocated(authorization_model_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.authorization_model_id_.IsDefault()) {
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.WriteAuthorizationModelResponse.authorization_model_id)
}

// -------------------------------------------------------------------

// ReadAuthorizationModelsRequest

// string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ReadAuthorizationModelsRequest::clear_store_id() {
  _impl_.store_id_.ClearToEmpty();
}
inline const std::string& ReadAuthorizationModelsRequest::store_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadAuthorizationModelsRequest.store_id)
  return _internal_store_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadAuthorizationModelsRequest::set_store_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.store_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ReadAuthorizationModelsRequest.store_id)
}
inline std::string* ReadAuthorizationModelsRequest::mutable_store_id() {
  std::string* _s = _internal_mutable_store_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadAuthorizationModelsRequest.store_id)
  return _s;
}
inline const std::string& ReadAuthorizationModelsRequest::_internal_store_id() const {
  return _impl_.store_id_.Get();
}
inline void ReadAuthorizationModelsRequest::_internal_set_store_id(const std::string& value) {
  
  _impl_.store_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadAuthorizationModelsRequest::_internal_mutable_store_id() {
  
  return _impl_.store_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadAuthorizationModelsRequest::release_store_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.ReadAuthorizationModelsRequest.store_id)
  return _impl_.store_id_.Release();
}
inline void ReadAuthorizationModelsRequest::set_allocated_store_id(std::string* store_id) {
  if (store_id != nullptr) {
    
  } else {
    
  }
  _impl_.store_id_.SetAllocated(store_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.store_id_.IsDefault()) {
    _impl_.store_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ReadAuthorizationModelsRequest.store_id)
}

// .google.protobuf.Int32Value page_size = 2 [json_name = "page_size", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline bool ReadAuthorizationModelsRequest::_internal_has_page_size() const {
  return this != internal_default_instance() && _impl_.page_size_ != nullptr;
}
inline bool ReadAuthorizationModelsRequest::has_page_size() const {
  return _internal_has_page_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Int32Value& ReadAuthorizationModelsRequest::_internal_page_size() const {
  const ::PROTOBUF_NAMESPACE_ID::Int32Value* p = _impl_.page_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Int32Value&>(
      ::PROTOBUF_NAMESPACE_ID::_Int32Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Int32Value& ReadAuthorizationModelsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadAuthorizationModelsRequest.page_size)
  return _internal_page_size();
}
inline void ReadAuthorizationModelsRequest::unsafe_arena_set_allocated_page_size(
    ::PROTOBUF_NAMESPACE_ID::Int32Value* page_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.page_size_);
  }
  _impl_.page_size_ = page_size;
  if (page_size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.ReadAuthorizationModelsRequest.page_size)
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* ReadAuthorizationModelsRequest::release_page_size() {
  
  ::PROTOBUF_NAMESPACE_ID::Int32Value* temp = _impl_.page_size_;
  _impl_.page_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* ReadAuthorizationModelsRequest::unsafe_arena_release_page_size() {
  // @@protoc_insertion_point(field_release:openfga.v1.ReadAuthorizationModelsRequest.page_size)
  
  ::PROTOBUF_NAMESPACE_ID::Int32Value* temp = _impl_.page_size_;
  _impl_.page_size_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* ReadAuthorizationModelsRequest::_internal_mutable_page_size() {
  
  if (_impl_.page_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Int32Value>(GetArenaForAllocation());
    _impl_.page_size_ = p;
  }
  return _impl_.page_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* ReadAuthorizationModelsRequest::mutable_page_size() {
  ::PROTOBUF_NAMESPACE_ID::Int32Value* _msg = _internal_mutable_page_size();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadAuthorizationModelsRequest.page_size)
  return _msg;
}
inline void ReadAuthorizationModelsRequest::set_allocated_page_size(::PROTOBUF_NAMESPACE_ID::Int32Value* page_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.page_size_);
  }
  if (page_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(page_size));
    if (message_arena != submessage_arena) {
      page_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, page_size, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.page_size_ = page_size;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ReadAuthorizationModelsRequest.page_size)
}

// string continuation_token = 3 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ReadAuthorizationModelsRequest::clear_continuation_token() {
  _impl_.continuation_token_.ClearToEmpty();
}
inline const std::string& ReadAuthorizationModelsRequest::continuation_token() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadAuthorizationModelsRequest.continuation_token)
  return _internal_continuation_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadAuthorizationModelsRequest::set_continuation_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.continuation_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ReadAuthorizationModelsRequest.continuation_token)
}
inline std::string* ReadAuthorizationModelsRequest::mutable_continuation_token() {
  std::string* _s = _internal_mutable_continuation_token();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadAuthorizationModelsRequest.continuation_token)
  return _s;
}
inline const std::string& ReadAuthorizationModelsRequest::_internal_continuation_token() const {
  return _impl_.continuation_token_.Get();
}
inline void ReadAuthorizationModelsRequest::_internal_set_continuation_token(const std::string& value) {
  
  _impl_.continuation_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadAuthorizationModelsRequest::_internal_mutable_continuation_token() {
  
  return _impl_.continuation_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadAuthorizationModelsRequest::release_continuation_token() {
  // @@protoc_insertion_point(field_release:openfga.v1.ReadAuthorizationModelsRequest.continuation_token)
  return _impl_.continuation_token_.Release();
}
inline void ReadAuthorizationModelsRequest::set_allocated_continuation_token(std::string* continuation_token) {
  if (continuation_token != nullptr) {
    
  } else {
    
  }
  _impl_.continuation_token_.SetAllocated(continuation_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.continuation_token_.IsDefault()) {
    _impl_.continuation_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ReadAuthorizationModelsRequest.continuation_token)
}

// -------------------------------------------------------------------

// ReadAuthorizationModelsResponse

// repeated .openfga.v1.AuthorizationModel authorization_models = 1 [json_name = "authorization_models", (.google.api.field_behavior) = REQUIRED];
inline int ReadAuthorizationModelsResponse::_internal_authorization_models_size() const {
  return _impl_.authorization_models_.size();
}
inline int ReadAuthorizationModelsResponse::authorization_models_size() const {
  return _internal_authorization_models_size();
}
inline ::openfga::v1::AuthorizationModel* ReadAuthorizationModelsResponse::mutable_authorization_models(int index) {
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadAuthorizationModelsResponse.authorization_models)
  return _impl_.authorization_models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::AuthorizationModel >*
ReadAuthorizationModelsResponse::mutable_authorization_models() {
  // @@protoc_insertion_point(field_mutable_list:openfga.v1.ReadAuthorizationModelsResponse.authorization_models)
  return &_impl_.authorization_models_;
}
inline const ::openfga::v1::AuthorizationModel& ReadAuthorizationModelsResponse::_internal_authorization_models(int index) const {
  return _impl_.authorization_models_.Get(index);
}
inline const ::openfga::v1::AuthorizationModel& ReadAuthorizationModelsResponse::authorization_models(int index) const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadAuthorizationModelsResponse.authorization_models)
  return _internal_authorization_models(index);
}
inline ::openfga::v1::AuthorizationModel* ReadAuthorizationModelsResponse::_internal_add_authorization_models() {
  return _impl_.authorization_models_.Add();
}
inline ::openfga::v1::AuthorizationModel* ReadAuthorizationModelsResponse::add_authorization_models() {
  ::openfga::v1::AuthorizationModel* _add = _internal_add_authorization_models();
  // @@protoc_insertion_point(field_add:openfga.v1.ReadAuthorizationModelsResponse.authorization_models)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::AuthorizationModel >&
ReadAuthorizationModelsResponse::authorization_models() const {
  // @@protoc_insertion_point(field_list:openfga.v1.ReadAuthorizationModelsResponse.authorization_models)
  return _impl_.authorization_models_;
}

// string continuation_token = 2 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ReadAuthorizationModelsResponse::clear_continuation_token() {
  _impl_.continuation_token_.ClearToEmpty();
}
inline const std::string& ReadAuthorizationModelsResponse::continuation_token() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadAuthorizationModelsResponse.continuation_token)
  return _internal_continuation_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadAuthorizationModelsResponse::set_continuation_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.continuation_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ReadAuthorizationModelsResponse.continuation_token)
}
inline std::string* ReadAuthorizationModelsResponse::mutable_continuation_token() {
  std::string* _s = _internal_mutable_continuation_token();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadAuthorizationModelsResponse.continuation_token)
  return _s;
}
inline const std::string& ReadAuthorizationModelsResponse::_internal_continuation_token() const {
  return _impl_.continuation_token_.Get();
}
inline void ReadAuthorizationModelsResponse::_internal_set_continuation_token(const std::string& value) {
  
  _impl_.continuation_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadAuthorizationModelsResponse::_internal_mutable_continuation_token() {
  
  return _impl_.continuation_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadAuthorizationModelsResponse::release_continuation_token() {
  // @@protoc_insertion_point(field_release:openfga.v1.ReadAuthorizationModelsResponse.continuation_token)
  return _impl_.continuation_token_.Release();
}
inline void ReadAuthorizationModelsResponse::set_allocated_continuation_token(std::string* continuation_token) {
  if (continuation_token != nullptr) {
    
  } else {
    
  }
  _impl_.continuation_token_.SetAllocated(continuation_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.continuation_token_.IsDefault()) {
    _impl_.continuation_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ReadAuthorizationModelsResponse.continuation_token)
}

// -------------------------------------------------------------------

// WriteAssertionsRequest

// string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void WriteAssertionsRequest::clear_store_id() {
  _impl_.store_id_.ClearToEmpty();
}
inline const std::string& WriteAssertionsRequest::store_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.WriteAssertionsRequest.store_id)
  return _internal_store_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteAssertionsRequest::set_store_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.store_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.WriteAssertionsRequest.store_id)
}
inline std::string* WriteAssertionsRequest::mutable_store_id() {
  std::string* _s = _internal_mutable_store_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.WriteAssertionsRequest.store_id)
  return _s;
}
inline const std::string& WriteAssertionsRequest::_internal_store_id() const {
  return _impl_.store_id_.Get();
}
inline void WriteAssertionsRequest::_internal_set_store_id(const std::string& value) {
  
  _impl_.store_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteAssertionsRequest::_internal_mutable_store_id() {
  
  return _impl_.store_id_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteAssertionsRequest::release_store_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.WriteAssertionsRequest.store_id)
  return _impl_.store_id_.Release();
}
inline void WriteAssertionsRequest::set_allocated_store_id(std::string* store_id) {
  if (store_id != nullptr) {
    
  } else {
    
  }
  _impl_.store_id_.SetAllocated(store_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.store_id_.IsDefault()) {
    _impl_.store_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.WriteAssertionsRequest.store_id)
}

// string authorization_model_id = 2 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void WriteAssertionsRequest::clear_authorization_model_id() {
  _impl_.authorization_model_id_.ClearToEmpty();
}
inline const std::string& WriteAssertionsRequest::authorization_model_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.WriteAssertionsRequest.authorization_model_id)
  return _internal_authorization_model_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteAssertionsRequest::set_authorization_model_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.authorization_model_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.WriteAssertionsRequest.authorization_model_id)
}
inline std::string* WriteAssertionsRequest::mutable_authorization_model_id() {
  std::string* _s = _internal_mutable_authorization_model_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.WriteAssertionsRequest.authorization_model_id)
  return _s;
}
inline const std::string& WriteAssertionsRequest::_internal_authorization_model_id() const {
  return _impl_.authorization_model_id_.Get();
}
inline void WriteAssertionsRequest::_internal_set_authorization_model_id(const std::string& value) {
  
  _impl_.authorization_model_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteAssertionsRequest::_internal_mutable_authorization_model_id() {
  
  return _impl_.authorization_model_id_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteAssertionsRequest::release_authorization_model_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.WriteAssertionsRequest.authorization_model_id)
  return _impl_.authorization_model_id_.Release();
}
inline void WriteAssertionsRequest::set_allocated_authorization_model_id(std::string* authorization_model_id) {
  if (authorization_model_id != nullptr) {
    
  } else {
    
  }
  _impl_.authorization_model_id_.SetAllocated(authorization_model_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.authorization_model_id_.IsDefault()) {
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.WriteAssertionsRequest.authorization_model_id)
}

// repeated .openfga.v1.Assertion assertions = 3 [json_name = "assertions", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int WriteAssertionsRequest::_internal_assertions_size() const {
  return _impl_.assertions_.size();
}
inline int WriteAssertionsRequest::assertions_size() const {
  return _internal_assertions_size();
}
inline void WriteAssertionsRequest::clear_assertions() {
  _impl_.assertions_.Clear();
}
inline ::openfga::v1::Assertion* WriteAssertionsRequest::mutable_assertions(int index) {
  // @@protoc_insertion_point(field_mutable:openfga.v1.WriteAssertionsRequest.assertions)
  return _impl_.assertions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Assertion >*
WriteAssertionsRequest::mutable_assertions() {
  // @@protoc_insertion_point(field_mutable_list:openfga.v1.WriteAssertionsRequest.assertions)
  return &_impl_.assertions_;
}
inline const ::openfga::v1::Assertion& WriteAssertionsRequest::_internal_assertions(int index) const {
  return _impl_.assertions_.Get(index);
}
inline const ::openfga::v1::Assertion& WriteAssertionsRequest::assertions(int index) const {
  // @@protoc_insertion_point(field_get:openfga.v1.WriteAssertionsRequest.assertions)
  return _internal_assertions(index);
}
inline ::openfga::v1::Assertion* WriteAssertionsRequest::_internal_add_assertions() {
  return _impl_.assertions_.Add();
}
inline ::openfga::v1::Assertion* WriteAssertionsRequest::add_assertions() {
  ::openfga::v1::Assertion* _add = _internal_add_assertions();
  // @@protoc_insertion_point(field_add:openfga.v1.WriteAssertionsRequest.assertions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Assertion >&
WriteAssertionsRequest::assertions() const {
  // @@protoc_insertion_point(field_list:openfga.v1.WriteAssertionsRequest.assertions)
  return _impl_.assertions_;
}

// -------------------------------------------------------------------

// WriteAssertionsResponse

// -------------------------------------------------------------------

// ReadAssertionsRequest

// string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ReadAssertionsRequest::clear_store_id() {
  _impl_.store_id_.ClearToEmpty();
}
inline const std::string& ReadAssertionsRequest::store_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadAssertionsRequest.store_id)
  return _internal_store_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadAssertionsRequest::set_store_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.store_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ReadAssertionsRequest.store_id)
}
inline std::string* ReadAssertionsRequest::mutable_store_id() {
  std::string* _s = _internal_mutable_store_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadAssertionsRequest.store_id)
  return _s;
}
inline const std::string& ReadAssertionsRequest::_internal_store_id() const {
  return _impl_.store_id_.Get();
}
inline void ReadAssertionsRequest::_internal_set_store_id(const std::string& value) {
  
  _impl_.store_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadAssertionsRequest::_internal_mutable_store_id() {
  
  return _impl_.store_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadAssertionsRequest::release_store_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.ReadAssertionsRequest.store_id)
  return _impl_.store_id_.Release();
}
inline void ReadAssertionsRequest::set_allocated_store_id(std::string* store_id) {
  if (store_id != nullptr) {
    
  } else {
    
  }
  _impl_.store_id_.SetAllocated(store_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.store_id_.IsDefault()) {
    _impl_.store_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ReadAssertionsRequest.store_id)
}

// string authorization_model_id = 2 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ReadAssertionsRequest::clear_authorization_model_id() {
  _impl_.authorization_model_id_.ClearToEmpty();
}
inline const std::string& ReadAssertionsRequest::authorization_model_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadAssertionsRequest.authorization_model_id)
  return _internal_authorization_model_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadAssertionsRequest::set_authorization_model_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.authorization_model_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ReadAssertionsRequest.authorization_model_id)
}
inline std::string* ReadAssertionsRequest::mutable_authorization_model_id() {
  std::string* _s = _internal_mutable_authorization_model_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadAssertionsRequest.authorization_model_id)
  return _s;
}
inline const std::string& ReadAssertionsRequest::_internal_authorization_model_id() const {
  return _impl_.authorization_model_id_.Get();
}
inline void ReadAssertionsRequest::_internal_set_authorization_model_id(const std::string& value) {
  
  _impl_.authorization_model_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadAssertionsRequest::_internal_mutable_authorization_model_id() {
  
  return _impl_.authorization_model_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadAssertionsRequest::release_authorization_model_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.ReadAssertionsRequest.authorization_model_id)
  return _impl_.authorization_model_id_.Release();
}
inline void ReadAssertionsRequest::set_allocated_authorization_model_id(std::string* authorization_model_id) {
  if (authorization_model_id != nullptr) {
    
  } else {
    
  }
  _impl_.authorization_model_id_.SetAllocated(authorization_model_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.authorization_model_id_.IsDefault()) {
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ReadAssertionsRequest.authorization_model_id)
}

// -------------------------------------------------------------------

// ReadAssertionsResponse

// string authorization_model_id = 1 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ReadAssertionsResponse::clear_authorization_model_id() {
  _impl_.authorization_model_id_.ClearToEmpty();
}
inline const std::string& ReadAssertionsResponse::authorization_model_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadAssertionsResponse.authorization_model_id)
  return _internal_authorization_model_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadAssertionsResponse::set_authorization_model_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.authorization_model_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ReadAssertionsResponse.authorization_model_id)
}
inline std::string* ReadAssertionsResponse::mutable_authorization_model_id() {
  std::string* _s = _internal_mutable_authorization_model_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadAssertionsResponse.authorization_model_id)
  return _s;
}
inline const std::string& ReadAssertionsResponse::_internal_authorization_model_id() const {
  return _impl_.authorization_model_id_.Get();
}
inline void ReadAssertionsResponse::_internal_set_authorization_model_id(const std::string& value) {
  
  _impl_.authorization_model_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadAssertionsResponse::_internal_mutable_authorization_model_id() {
  
  return _impl_.authorization_model_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadAssertionsResponse::release_authorization_model_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.ReadAssertionsResponse.authorization_model_id)
  return _impl_.authorization_model_id_.Release();
}
inline void ReadAssertionsResponse::set_allocated_authorization_model_id(std::string* authorization_model_id) {
  if (authorization_model_id != nullptr) {
    
  } else {
    
  }
  _impl_.authorization_model_id_.SetAllocated(authorization_model_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.authorization_model_id_.IsDefault()) {
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ReadAssertionsResponse.authorization_model_id)
}

// repeated .openfga.v1.Assertion assertions = 2 [json_name = "assertions"];
inline int ReadAssertionsResponse::_internal_assertions_size() const {
  return _impl_.assertions_.size();
}
inline int ReadAssertionsResponse::assertions_size() const {
  return _internal_assertions_size();
}
inline void ReadAssertionsResponse::clear_assertions() {
  _impl_.assertions_.Clear();
}
inline ::openfga::v1::Assertion* ReadAssertionsResponse::mutable_assertions(int index) {
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadAssertionsResponse.assertions)
  return _impl_.assertions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Assertion >*
ReadAssertionsResponse::mutable_assertions() {
  // @@protoc_insertion_point(field_mutable_list:openfga.v1.ReadAssertionsResponse.assertions)
  return &_impl_.assertions_;
}
inline const ::openfga::v1::Assertion& ReadAssertionsResponse::_internal_assertions(int index) const {
  return _impl_.assertions_.Get(index);
}
inline const ::openfga::v1::Assertion& ReadAssertionsResponse::assertions(int index) const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadAssertionsResponse.assertions)
  return _internal_assertions(index);
}
inline ::openfga::v1::Assertion* ReadAssertionsResponse::_internal_add_assertions() {
  return _impl_.assertions_.Add();
}
inline ::openfga::v1::Assertion* ReadAssertionsResponse::add_assertions() {
  ::openfga::v1::Assertion* _add = _internal_add_assertions();
  // @@protoc_insertion_point(field_add:openfga.v1.ReadAssertionsResponse.assertions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Assertion >&
ReadAssertionsResponse::assertions() const {
  // @@protoc_insertion_point(field_list:openfga.v1.ReadAssertionsResponse.assertions)
  return _impl_.assertions_;
}

// -------------------------------------------------------------------

// ReadChangesRequest

// string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ReadChangesRequest::clear_store_id() {
  _impl_.store_id_.ClearToEmpty();
}
inline const std::string& ReadChangesRequest::store_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadChangesRequest.store_id)
  return _internal_store_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadChangesRequest::set_store_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.store_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ReadChangesRequest.store_id)
}
inline std::string* ReadChangesRequest::mutable_store_id() {
  std::string* _s = _internal_mutable_store_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadChangesRequest.store_id)
  return _s;
}
inline const std::string& ReadChangesRequest::_internal_store_id() const {
  return _impl_.store_id_.Get();
}
inline void ReadChangesRequest::_internal_set_store_id(const std::string& value) {
  
  _impl_.store_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadChangesRequest::_internal_mutable_store_id() {
  
  return _impl_.store_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadChangesRequest::release_store_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.ReadChangesRequest.store_id)
  return _impl_.store_id_.Release();
}
inline void ReadChangesRequest::set_allocated_store_id(std::string* store_id) {
  if (store_id != nullptr) {
    
  } else {
    
  }
  _impl_.store_id_.SetAllocated(store_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.store_id_.IsDefault()) {
    _impl_.store_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ReadChangesRequest.store_id)
}

// string type = 2 [json_name = "type", (.validate.rules) = {
inline void ReadChangesRequest::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& ReadChangesRequest::type() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadChangesRequest.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadChangesRequest::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ReadChangesRequest.type)
}
inline std::string* ReadChangesRequest::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadChangesRequest.type)
  return _s;
}
inline const std::string& ReadChangesRequest::_internal_type() const {
  return _impl_.type_.Get();
}
inline void ReadChangesRequest::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadChangesRequest::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadChangesRequest::release_type() {
  // @@protoc_insertion_point(field_release:openfga.v1.ReadChangesRequest.type)
  return _impl_.type_.Release();
}
inline void ReadChangesRequest::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ReadChangesRequest.type)
}

// .google.protobuf.Int32Value page_size = 3 [json_name = "page_size", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline bool ReadChangesRequest::_internal_has_page_size() const {
  return this != internal_default_instance() && _impl_.page_size_ != nullptr;
}
inline bool ReadChangesRequest::has_page_size() const {
  return _internal_has_page_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Int32Value& ReadChangesRequest::_internal_page_size() const {
  const ::PROTOBUF_NAMESPACE_ID::Int32Value* p = _impl_.page_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Int32Value&>(
      ::PROTOBUF_NAMESPACE_ID::_Int32Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Int32Value& ReadChangesRequest::page_size() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadChangesRequest.page_size)
  return _internal_page_size();
}
inline void ReadChangesRequest::unsafe_arena_set_allocated_page_size(
    ::PROTOBUF_NAMESPACE_ID::Int32Value* page_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.page_size_);
  }
  _impl_.page_size_ = page_size;
  if (page_size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.ReadChangesRequest.page_size)
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* ReadChangesRequest::release_page_size() {
  
  ::PROTOBUF_NAMESPACE_ID::Int32Value* temp = _impl_.page_size_;
  _impl_.page_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* ReadChangesRequest::unsafe_arena_release_page_size() {
  // @@protoc_insertion_point(field_release:openfga.v1.ReadChangesRequest.page_size)
  
  ::PROTOBUF_NAMESPACE_ID::Int32Value* temp = _impl_.page_size_;
  _impl_.page_size_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* ReadChangesRequest::_internal_mutable_page_size() {
  
  if (_impl_.page_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Int32Value>(GetArenaForAllocation());
    _impl_.page_size_ = p;
  }
  return _impl_.page_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* ReadChangesRequest::mutable_page_size() {
  ::PROTOBUF_NAMESPACE_ID::Int32Value* _msg = _internal_mutable_page_size();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadChangesRequest.page_size)
  return _msg;
}
inline void ReadChangesRequest::set_allocated_page_size(::PROTOBUF_NAMESPACE_ID::Int32Value* page_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.page_size_);
  }
  if (page_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(page_size));
    if (message_arena != submessage_arena) {
      page_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, page_size, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.page_size_ = page_size;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ReadChangesRequest.page_size)
}

// string continuation_token = 4 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ReadChangesRequest::clear_continuation_token() {
  _impl_.continuation_token_.ClearToEmpty();
}
inline const std::string& ReadChangesRequest::continuation_token() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadChangesRequest.continuation_token)
  return _internal_continuation_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadChangesRequest::set_continuation_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.continuation_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ReadChangesRequest.continuation_token)
}
inline std::string* ReadChangesRequest::mutable_continuation_token() {
  std::string* _s = _internal_mutable_continuation_token();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadChangesRequest.continuation_token)
  return _s;
}
inline const std::string& ReadChangesRequest::_internal_continuation_token() const {
  return _impl_.continuation_token_.Get();
}
inline void ReadChangesRequest::_internal_set_continuation_token(const std::string& value) {
  
  _impl_.continuation_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadChangesRequest::_internal_mutable_continuation_token() {
  
  return _impl_.continuation_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadChangesRequest::release_continuation_token() {
  // @@protoc_insertion_point(field_release:openfga.v1.ReadChangesRequest.continuation_token)
  return _impl_.continuation_token_.Release();
}
inline void ReadChangesRequest::set_allocated_continuation_token(std::string* continuation_token) {
  if (continuation_token != nullptr) {
    
  } else {
    
  }
  _impl_.continuation_token_.SetAllocated(continuation_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.continuation_token_.IsDefault()) {
    _impl_.continuation_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ReadChangesRequest.continuation_token)
}

// .google.protobuf.Timestamp start_time = 5 [json_name = "start_time", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline bool ReadChangesRequest::_internal_has_start_time() const {
  return this != internal_default_instance() && _impl_.start_time_ != nullptr;
}
inline bool ReadChangesRequest::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ReadChangesRequest::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ReadChangesRequest::start_time() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadChangesRequest.start_time)
  return _internal_start_time();
}
inline void ReadChangesRequest::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.ReadChangesRequest.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ReadChangesRequest::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ReadChangesRequest::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:openfga.v1.ReadChangesRequest.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ReadChangesRequest::_internal_mutable_start_time() {
  
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_time_ = p;
  }
  return _impl_.start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ReadChangesRequest::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadChangesRequest.start_time)
  return _msg;
}
inline void ReadChangesRequest::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ReadChangesRequest.start_time)
}

// -------------------------------------------------------------------

// ReadChangesResponse

// repeated .openfga.v1.TupleChange changes = 1 [json_name = "changes", (.google.api.field_behavior) = REQUIRED];
inline int ReadChangesResponse::_internal_changes_size() const {
  return _impl_.changes_.size();
}
inline int ReadChangesResponse::changes_size() const {
  return _internal_changes_size();
}
inline ::openfga::v1::TupleChange* ReadChangesResponse::mutable_changes(int index) {
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadChangesResponse.changes)
  return _impl_.changes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleChange >*
ReadChangesResponse::mutable_changes() {
  // @@protoc_insertion_point(field_mutable_list:openfga.v1.ReadChangesResponse.changes)
  return &_impl_.changes_;
}
inline const ::openfga::v1::TupleChange& ReadChangesResponse::_internal_changes(int index) const {
  return _impl_.changes_.Get(index);
}
inline const ::openfga::v1::TupleChange& ReadChangesResponse::changes(int index) const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadChangesResponse.changes)
  return _internal_changes(index);
}
inline ::openfga::v1::TupleChange* ReadChangesResponse::_internal_add_changes() {
  return _impl_.changes_.Add();
}
inline ::openfga::v1::TupleChange* ReadChangesResponse::add_changes() {
  ::openfga::v1::TupleChange* _add = _internal_add_changes();
  // @@protoc_insertion_point(field_add:openfga.v1.ReadChangesResponse.changes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleChange >&
ReadChangesResponse::changes() const {
  // @@protoc_insertion_point(field_list:openfga.v1.ReadChangesResponse.changes)
  return _impl_.changes_;
}

// string continuation_token = 2 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ReadChangesResponse::clear_continuation_token() {
  _impl_.continuation_token_.ClearToEmpty();
}
inline const std::string& ReadChangesResponse::continuation_token() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ReadChangesResponse.continuation_token)
  return _internal_continuation_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadChangesResponse::set_continuation_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.continuation_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ReadChangesResponse.continuation_token)
}
inline std::string* ReadChangesResponse::mutable_continuation_token() {
  std::string* _s = _internal_mutable_continuation_token();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ReadChangesResponse.continuation_token)
  return _s;
}
inline const std::string& ReadChangesResponse::_internal_continuation_token() const {
  return _impl_.continuation_token_.Get();
}
inline void ReadChangesResponse::_internal_set_continuation_token(const std::string& value) {
  
  _impl_.continuation_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadChangesResponse::_internal_mutable_continuation_token() {
  
  return _impl_.continuation_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadChangesResponse::release_continuation_token() {
  // @@protoc_insertion_point(field_release:openfga.v1.ReadChangesResponse.continuation_token)
  return _impl_.continuation_token_.Release();
}
inline void ReadChangesResponse::set_allocated_continuation_token(std::string* continuation_token) {
  if (continuation_token != nullptr) {
    
  } else {
    
  }
  _impl_.continuation_token_.SetAllocated(continuation_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.continuation_token_.IsDefault()) {
    _impl_.continuation_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ReadChangesResponse.continuation_token)
}

// -------------------------------------------------------------------

// CreateStoreRequest

// string name = 1 [json_name = "name", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void CreateStoreRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreateStoreRequest::name() const {
  // @@protoc_insertion_point(field_get:openfga.v1.CreateStoreRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateStoreRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.CreateStoreRequest.name)
}
inline std::string* CreateStoreRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:openfga.v1.CreateStoreRequest.name)
  return _s;
}
inline const std::string& CreateStoreRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CreateStoreRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateStoreRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateStoreRequest::release_name() {
  // @@protoc_insertion_point(field_release:openfga.v1.CreateStoreRequest.name)
  return _impl_.name_.Release();
}
inline void CreateStoreRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.CreateStoreRequest.name)
}

// -------------------------------------------------------------------

// CreateStoreResponse

// string id = 1 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void CreateStoreResponse::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& CreateStoreResponse::id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.CreateStoreResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateStoreResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.CreateStoreResponse.id)
}
inline std::string* CreateStoreResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.CreateStoreResponse.id)
  return _s;
}
inline const std::string& CreateStoreResponse::_internal_id() const {
  return _impl_.id_.Get();
}
inline void CreateStoreResponse::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateStoreResponse::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateStoreResponse::release_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.CreateStoreResponse.id)
  return _impl_.id_.Release();
}
inline void CreateStoreResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.CreateStoreResponse.id)
}

// string name = 2 [json_name = "name", (.google.api.field_behavior) = REQUIRED];
inline void CreateStoreResponse::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreateStoreResponse::name() const {
  // @@protoc_insertion_point(field_get:openfga.v1.CreateStoreResponse.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateStoreResponse::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.CreateStoreResponse.name)
}
inline std::string* CreateStoreResponse::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:openfga.v1.CreateStoreResponse.name)
  return _s;
}
inline const std::string& CreateStoreResponse::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CreateStoreResponse::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateStoreResponse::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateStoreResponse::release_name() {
  // @@protoc_insertion_point(field_release:openfga.v1.CreateStoreResponse.name)
  return _impl_.name_.Release();
}
inline void CreateStoreResponse::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.CreateStoreResponse.name)
}

// .google.protobuf.Timestamp created_at = 3 [json_name = "created_at", (.google.api.field_behavior) = REQUIRED];
inline bool CreateStoreResponse::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool CreateStoreResponse::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CreateStoreResponse::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CreateStoreResponse::created_at() const {
  // @@protoc_insertion_point(field_get:openfga.v1.CreateStoreResponse.created_at)
  return _internal_created_at();
}
inline void CreateStoreResponse::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.CreateStoreResponse.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateStoreResponse::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateStoreResponse::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:openfga.v1.CreateStoreResponse.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateStoreResponse::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateStoreResponse::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:openfga.v1.CreateStoreResponse.created_at)
  return _msg;
}
inline void CreateStoreResponse::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.CreateStoreResponse.created_at)
}

// .google.protobuf.Timestamp updated_at = 4 [json_name = "updated_at", (.google.api.field_behavior) = REQUIRED];
inline bool CreateStoreResponse::_internal_has_updated_at() const {
  return this != internal_default_instance() && _impl_.updated_at_ != nullptr;
}
inline bool CreateStoreResponse::has_updated_at() const {
  return _internal_has_updated_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CreateStoreResponse::_internal_updated_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CreateStoreResponse::updated_at() const {
  // @@protoc_insertion_point(field_get:openfga.v1.CreateStoreResponse.updated_at)
  return _internal_updated_at();
}
inline void CreateStoreResponse::unsafe_arena_set_allocated_updated_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  _impl_.updated_at_ = updated_at;
  if (updated_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.CreateStoreResponse.updated_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateStoreResponse::release_updated_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateStoreResponse::unsafe_arena_release_updated_at() {
  // @@protoc_insertion_point(field_release:openfga.v1.CreateStoreResponse.updated_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateStoreResponse::_internal_mutable_updated_at() {
  
  if (_impl_.updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.updated_at_ = p;
  }
  return _impl_.updated_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CreateStoreResponse::mutable_updated_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:openfga.v1.CreateStoreResponse.updated_at)
  return _msg;
}
inline void CreateStoreResponse::set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  if (updated_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at));
    if (message_arena != submessage_arena) {
      updated_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.updated_at_ = updated_at;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.CreateStoreResponse.updated_at)
}

// -------------------------------------------------------------------

// UpdateStoreRequest

// string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void UpdateStoreRequest::clear_store_id() {
  _impl_.store_id_.ClearToEmpty();
}
inline const std::string& UpdateStoreRequest::store_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UpdateStoreRequest.store_id)
  return _internal_store_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateStoreRequest::set_store_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.store_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.UpdateStoreRequest.store_id)
}
inline std::string* UpdateStoreRequest::mutable_store_id() {
  std::string* _s = _internal_mutable_store_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.UpdateStoreRequest.store_id)
  return _s;
}
inline const std::string& UpdateStoreRequest::_internal_store_id() const {
  return _impl_.store_id_.Get();
}
inline void UpdateStoreRequest::_internal_set_store_id(const std::string& value) {
  
  _impl_.store_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateStoreRequest::_internal_mutable_store_id() {
  
  return _impl_.store_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateStoreRequest::release_store_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.UpdateStoreRequest.store_id)
  return _impl_.store_id_.Release();
}
inline void UpdateStoreRequest::set_allocated_store_id(std::string* store_id) {
  if (store_id != nullptr) {
    
  } else {
    
  }
  _impl_.store_id_.SetAllocated(store_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.store_id_.IsDefault()) {
    _impl_.store_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.UpdateStoreRequest.store_id)
}

// string name = 2 [json_name = "name", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void UpdateStoreRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UpdateStoreRequest::name() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UpdateStoreRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateStoreRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.UpdateStoreRequest.name)
}
inline std::string* UpdateStoreRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:openfga.v1.UpdateStoreRequest.name)
  return _s;
}
inline const std::string& UpdateStoreRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UpdateStoreRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateStoreRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateStoreRequest::release_name() {
  // @@protoc_insertion_point(field_release:openfga.v1.UpdateStoreRequest.name)
  return _impl_.name_.Release();
}
inline void UpdateStoreRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.UpdateStoreRequest.name)
}

// -------------------------------------------------------------------

// UpdateStoreResponse

// string id = 1 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void UpdateStoreResponse::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& UpdateStoreResponse::id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UpdateStoreResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateStoreResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.UpdateStoreResponse.id)
}
inline std::string* UpdateStoreResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.UpdateStoreResponse.id)
  return _s;
}
inline const std::string& UpdateStoreResponse::_internal_id() const {
  return _impl_.id_.Get();
}
inline void UpdateStoreResponse::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateStoreResponse::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateStoreResponse::release_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.UpdateStoreResponse.id)
  return _impl_.id_.Release();
}
inline void UpdateStoreResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.UpdateStoreResponse.id)
}

// string name = 2 [json_name = "name", (.google.api.field_behavior) = REQUIRED];
inline void UpdateStoreResponse::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UpdateStoreResponse::name() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UpdateStoreResponse.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateStoreResponse::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.UpdateStoreResponse.name)
}
inline std::string* UpdateStoreResponse::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:openfga.v1.UpdateStoreResponse.name)
  return _s;
}
inline const std::string& UpdateStoreResponse::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UpdateStoreResponse::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateStoreResponse::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateStoreResponse::release_name() {
  // @@protoc_insertion_point(field_release:openfga.v1.UpdateStoreResponse.name)
  return _impl_.name_.Release();
}
inline void UpdateStoreResponse::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.UpdateStoreResponse.name)
}

// .google.protobuf.Timestamp created_at = 3 [json_name = "created_at", (.google.api.field_behavior) = REQUIRED];
inline bool UpdateStoreResponse::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool UpdateStoreResponse::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UpdateStoreResponse::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UpdateStoreResponse::created_at() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UpdateStoreResponse.created_at)
  return _internal_created_at();
}
inline void UpdateStoreResponse::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.UpdateStoreResponse.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateStoreResponse::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateStoreResponse::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:openfga.v1.UpdateStoreResponse.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateStoreResponse::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateStoreResponse::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:openfga.v1.UpdateStoreResponse.created_at)
  return _msg;
}
inline void UpdateStoreResponse::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.UpdateStoreResponse.created_at)
}

// .google.protobuf.Timestamp updated_at = 4 [json_name = "updated_at", (.google.api.field_behavior) = REQUIRED];
inline bool UpdateStoreResponse::_internal_has_updated_at() const {
  return this != internal_default_instance() && _impl_.updated_at_ != nullptr;
}
inline bool UpdateStoreResponse::has_updated_at() const {
  return _internal_has_updated_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UpdateStoreResponse::_internal_updated_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UpdateStoreResponse::updated_at() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UpdateStoreResponse.updated_at)
  return _internal_updated_at();
}
inline void UpdateStoreResponse::unsafe_arena_set_allocated_updated_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  _impl_.updated_at_ = updated_at;
  if (updated_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.UpdateStoreResponse.updated_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateStoreResponse::release_updated_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateStoreResponse::unsafe_arena_release_updated_at() {
  // @@protoc_insertion_point(field_release:openfga.v1.UpdateStoreResponse.updated_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateStoreResponse::_internal_mutable_updated_at() {
  
  if (_impl_.updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.updated_at_ = p;
  }
  return _impl_.updated_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UpdateStoreResponse::mutable_updated_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:openfga.v1.UpdateStoreResponse.updated_at)
  return _msg;
}
inline void UpdateStoreResponse::set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  if (updated_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at));
    if (message_arena != submessage_arena) {
      updated_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.updated_at_ = updated_at;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.UpdateStoreResponse.updated_at)
}

// -------------------------------------------------------------------

// DeleteStoreRequest

// string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void DeleteStoreRequest::clear_store_id() {
  _impl_.store_id_.ClearToEmpty();
}
inline const std::string& DeleteStoreRequest::store_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.DeleteStoreRequest.store_id)
  return _internal_store_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteStoreRequest::set_store_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.store_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.DeleteStoreRequest.store_id)
}
inline std::string* DeleteStoreRequest::mutable_store_id() {
  std::string* _s = _internal_mutable_store_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.DeleteStoreRequest.store_id)
  return _s;
}
inline const std::string& DeleteStoreRequest::_internal_store_id() const {
  return _impl_.store_id_.Get();
}
inline void DeleteStoreRequest::_internal_set_store_id(const std::string& value) {
  
  _impl_.store_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteStoreRequest::_internal_mutable_store_id() {
  
  return _impl_.store_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteStoreRequest::release_store_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.DeleteStoreRequest.store_id)
  return _impl_.store_id_.Release();
}
inline void DeleteStoreRequest::set_allocated_store_id(std::string* store_id) {
  if (store_id != nullptr) {
    
  } else {
    
  }
  _impl_.store_id_.SetAllocated(store_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.store_id_.IsDefault()) {
    _impl_.store_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.DeleteStoreRequest.store_id)
}

// -------------------------------------------------------------------

// DeleteStoreResponse

// -------------------------------------------------------------------

// GetStoreRequest

// string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void GetStoreRequest::clear_store_id() {
  _impl_.store_id_.ClearToEmpty();
}
inline const std::string& GetStoreRequest::store_id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.GetStoreRequest.store_id)
  return _internal_store_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetStoreRequest::set_store_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.store_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.GetStoreRequest.store_id)
}
inline std::string* GetStoreRequest::mutable_store_id() {
  std::string* _s = _internal_mutable_store_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.GetStoreRequest.store_id)
  return _s;
}
inline const std::string& GetStoreRequest::_internal_store_id() const {
  return _impl_.store_id_.Get();
}
inline void GetStoreRequest::_internal_set_store_id(const std::string& value) {
  
  _impl_.store_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetStoreRequest::_internal_mutable_store_id() {
  
  return _impl_.store_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetStoreRequest::release_store_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.GetStoreRequest.store_id)
  return _impl_.store_id_.Release();
}
inline void GetStoreRequest::set_allocated_store_id(std::string* store_id) {
  if (store_id != nullptr) {
    
  } else {
    
  }
  _impl_.store_id_.SetAllocated(store_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.store_id_.IsDefault()) {
    _impl_.store_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.GetStoreRequest.store_id)
}

// -------------------------------------------------------------------

// GetStoreResponse

// string id = 1 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void GetStoreResponse::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetStoreResponse::id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.GetStoreResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetStoreResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.GetStoreResponse.id)
}
inline std::string* GetStoreResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.GetStoreResponse.id)
  return _s;
}
inline const std::string& GetStoreResponse::_internal_id() const {
  return _impl_.id_.Get();
}
inline void GetStoreResponse::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetStoreResponse::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetStoreResponse::release_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.GetStoreResponse.id)
  return _impl_.id_.Release();
}
inline void GetStoreResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.GetStoreResponse.id)
}

// string name = 2 [json_name = "name", (.google.api.field_behavior) = REQUIRED];
inline void GetStoreResponse::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetStoreResponse::name() const {
  // @@protoc_insertion_point(field_get:openfga.v1.GetStoreResponse.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetStoreResponse::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.GetStoreResponse.name)
}
inline std::string* GetStoreResponse::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:openfga.v1.GetStoreResponse.name)
  return _s;
}
inline const std::string& GetStoreResponse::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetStoreResponse::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetStoreResponse::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetStoreResponse::release_name() {
  // @@protoc_insertion_point(field_release:openfga.v1.GetStoreResponse.name)
  return _impl_.name_.Release();
}
inline void GetStoreResponse::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.GetStoreResponse.name)
}

// .google.protobuf.Timestamp created_at = 3 [json_name = "created_at", (.google.api.field_behavior) = REQUIRED];
inline bool GetStoreResponse::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool GetStoreResponse::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetStoreResponse::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetStoreResponse::created_at() const {
  // @@protoc_insertion_point(field_get:openfga.v1.GetStoreResponse.created_at)
  return _internal_created_at();
}
inline void GetStoreResponse::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.GetStoreResponse.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetStoreResponse::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetStoreResponse::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:openfga.v1.GetStoreResponse.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetStoreResponse::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetStoreResponse::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:openfga.v1.GetStoreResponse.created_at)
  return _msg;
}
inline void GetStoreResponse::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.GetStoreResponse.created_at)
}

// .google.protobuf.Timestamp updated_at = 4 [json_name = "updated_at", (.google.api.field_behavior) = REQUIRED];
inline bool GetStoreResponse::_internal_has_updated_at() const {
  return this != internal_default_instance() && _impl_.updated_at_ != nullptr;
}
inline bool GetStoreResponse::has_updated_at() const {
  return _internal_has_updated_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetStoreResponse::_internal_updated_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetStoreResponse::updated_at() const {
  // @@protoc_insertion_point(field_get:openfga.v1.GetStoreResponse.updated_at)
  return _internal_updated_at();
}
inline void GetStoreResponse::unsafe_arena_set_allocated_updated_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  _impl_.updated_at_ = updated_at;
  if (updated_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.GetStoreResponse.updated_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetStoreResponse::release_updated_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetStoreResponse::unsafe_arena_release_updated_at() {
  // @@protoc_insertion_point(field_release:openfga.v1.GetStoreResponse.updated_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetStoreResponse::_internal_mutable_updated_at() {
  
  if (_impl_.updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.updated_at_ = p;
  }
  return _impl_.updated_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetStoreResponse::mutable_updated_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:openfga.v1.GetStoreResponse.updated_at)
  return _msg;
}
inline void GetStoreResponse::set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  if (updated_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at));
    if (message_arena != submessage_arena) {
      updated_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.updated_at_ = updated_at;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.GetStoreResponse.updated_at)
}

// .google.protobuf.Timestamp deleted_at = 5 [json_name = "deleted_at"];
inline bool GetStoreResponse::_internal_has_deleted_at() const {
  return this != internal_default_instance() && _impl_.deleted_at_ != nullptr;
}
inline bool GetStoreResponse::has_deleted_at() const {
  return _internal_has_deleted_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetStoreResponse::_internal_deleted_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.deleted_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetStoreResponse::deleted_at() const {
  // @@protoc_insertion_point(field_get:openfga.v1.GetStoreResponse.deleted_at)
  return _internal_deleted_at();
}
inline void GetStoreResponse::unsafe_arena_set_allocated_deleted_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deleted_at_);
  }
  _impl_.deleted_at_ = deleted_at;
  if (deleted_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.GetStoreResponse.deleted_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetStoreResponse::release_deleted_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.deleted_at_;
  _impl_.deleted_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetStoreResponse::unsafe_arena_release_deleted_at() {
  // @@protoc_insertion_point(field_release:openfga.v1.GetStoreResponse.deleted_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.deleted_at_;
  _impl_.deleted_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetStoreResponse::_internal_mutable_deleted_at() {
  
  if (_impl_.deleted_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.deleted_at_ = p;
  }
  return _impl_.deleted_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetStoreResponse::mutable_deleted_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_deleted_at();
  // @@protoc_insertion_point(field_mutable:openfga.v1.GetStoreResponse.deleted_at)
  return _msg;
}
inline void GetStoreResponse::set_allocated_deleted_at(::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deleted_at_);
  }
  if (deleted_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deleted_at));
    if (message_arena != submessage_arena) {
      deleted_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deleted_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.deleted_at_ = deleted_at;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.GetStoreResponse.deleted_at)
}

// -------------------------------------------------------------------

// ListStoresRequest

// .google.protobuf.Int32Value page_size = 1 [json_name = "page_size", (.validate.rules) = {
inline bool ListStoresRequest::_internal_has_page_size() const {
  return this != internal_default_instance() && _impl_.page_size_ != nullptr;
}
inline bool ListStoresRequest::has_page_size() const {
  return _internal_has_page_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Int32Value& ListStoresRequest::_internal_page_size() const {
  const ::PROTOBUF_NAMESPACE_ID::Int32Value* p = _impl_.page_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Int32Value&>(
      ::PROTOBUF_NAMESPACE_ID::_Int32Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Int32Value& ListStoresRequest::page_size() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ListStoresRequest.page_size)
  return _internal_page_size();
}
inline void ListStoresRequest::unsafe_arena_set_allocated_page_size(
    ::PROTOBUF_NAMESPACE_ID::Int32Value* page_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.page_size_);
  }
  _impl_.page_size_ = page_size;
  if (page_size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.ListStoresRequest.page_size)
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* ListStoresRequest::release_page_size() {
  
  ::PROTOBUF_NAMESPACE_ID::Int32Value* temp = _impl_.page_size_;
  _impl_.page_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* ListStoresRequest::unsafe_arena_release_page_size() {
  // @@protoc_insertion_point(field_release:openfga.v1.ListStoresRequest.page_size)
  
  ::PROTOBUF_NAMESPACE_ID::Int32Value* temp = _impl_.page_size_;
  _impl_.page_size_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* ListStoresRequest::_internal_mutable_page_size() {
  
  if (_impl_.page_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Int32Value>(GetArenaForAllocation());
    _impl_.page_size_ = p;
  }
  return _impl_.page_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* ListStoresRequest::mutable_page_size() {
  ::PROTOBUF_NAMESPACE_ID::Int32Value* _msg = _internal_mutable_page_size();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ListStoresRequest.page_size)
  return _msg;
}
inline void ListStoresRequest::set_allocated_page_size(::PROTOBUF_NAMESPACE_ID::Int32Value* page_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.page_size_);
  }
  if (page_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(page_size));
    if (message_arena != submessage_arena) {
      page_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, page_size, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.page_size_ = page_size;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ListStoresRequest.page_size)
}

// string continuation_token = 2 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ListStoresRequest::clear_continuation_token() {
  _impl_.continuation_token_.ClearToEmpty();
}
inline const std::string& ListStoresRequest::continuation_token() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ListStoresRequest.continuation_token)
  return _internal_continuation_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListStoresRequest::set_continuation_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.continuation_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ListStoresRequest.continuation_token)
}
inline std::string* ListStoresRequest::mutable_continuation_token() {
  std::string* _s = _internal_mutable_continuation_token();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ListStoresRequest.continuation_token)
  return _s;
}
inline const std::string& ListStoresRequest::_internal_continuation_token() const {
  return _impl_.continuation_token_.Get();
}
inline void ListStoresRequest::_internal_set_continuation_token(const std::string& value) {
  
  _impl_.continuation_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListStoresRequest::_internal_mutable_continuation_token() {
  
  return _impl_.continuation_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListStoresRequest::release_continuation_token() {
  // @@protoc_insertion_point(field_release:openfga.v1.ListStoresRequest.continuation_token)
  return _impl_.continuation_token_.Release();
}
inline void ListStoresRequest::set_allocated_continuation_token(std::string* continuation_token) {
  if (continuation_token != nullptr) {
    
  } else {
    
  }
  _impl_.continuation_token_.SetAllocated(continuation_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.continuation_token_.IsDefault()) {
    _impl_.continuation_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ListStoresRequest.continuation_token)
}

// string name = 3 [json_name = "name", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ListStoresRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ListStoresRequest::name() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ListStoresRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListStoresRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ListStoresRequest.name)
}
inline std::string* ListStoresRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ListStoresRequest.name)
  return _s;
}
inline const std::string& ListStoresRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ListStoresRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ListStoresRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ListStoresRequest::release_name() {
  // @@protoc_insertion_point(field_release:openfga.v1.ListStoresRequest.name)
  return _impl_.name_.Release();
}
inline void ListStoresRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ListStoresRequest.name)
}

// -------------------------------------------------------------------

// ListStoresResponse

// repeated .openfga.v1.Store stores = 1 [json_name = "stores", (.google.api.field_behavior) = REQUIRED];
inline int ListStoresResponse::_internal_stores_size() const {
  return _impl_.stores_.size();
}
inline int ListStoresResponse::stores_size() const {
  return _internal_stores_size();
}
inline ::openfga::v1::Store* ListStoresResponse::mutable_stores(int index) {
  // @@protoc_insertion_point(field_mutable:openfga.v1.ListStoresResponse.stores)
  return _impl_.stores_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Store >*
ListStoresResponse::mutable_stores() {
  // @@protoc_insertion_point(field_mutable_list:openfga.v1.ListStoresResponse.stores)
  return &_impl_.stores_;
}
inline const ::openfga::v1::Store& ListStoresResponse::_internal_stores(int index) const {
  return _impl_.stores_.Get(index);
}
inline const ::openfga::v1::Store& ListStoresResponse::stores(int index) const {
  // @@protoc_insertion_point(field_get:openfga.v1.ListStoresResponse.stores)
  return _internal_stores(index);
}
inline ::openfga::v1::Store* ListStoresResponse::_internal_add_stores() {
  return _impl_.stores_.Add();
}
inline ::openfga::v1::Store* ListStoresResponse::add_stores() {
  ::openfga::v1::Store* _add = _internal_add_stores();
  // @@protoc_insertion_point(field_add:openfga.v1.ListStoresResponse.stores)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Store >&
ListStoresResponse::stores() const {
  // @@protoc_insertion_point(field_list:openfga.v1.ListStoresResponse.stores)
  return _impl_.stores_;
}

// string continuation_token = 2 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void ListStoresResponse::clear_continuation_token() {
  _impl_.continuation_token_.ClearToEmpty();
}
inline const std::string& ListStoresResponse::continuation_token() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ListStoresResponse.continuation_token)
  return _internal_continuation_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListStoresResponse::set_continuation_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.continuation_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ListStoresResponse.continuation_token)
}
inline std::string* ListStoresResponse::mutable_continuation_token() {
  std::string* _s = _internal_mutable_continuation_token();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ListStoresResponse.continuation_token)
  return _s;
}
inline const std::string& ListStoresResponse::_internal_continuation_token() const {
  return _impl_.continuation_token_.Get();
}
inline void ListStoresResponse::_internal_set_continuation_token(const std::string& value) {
  
  _impl_.continuation_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListStoresResponse::_internal_mutable_continuation_token() {
  
  return _impl_.continuation_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListStoresResponse::release_continuation_token() {
  // @@protoc_insertion_point(field_release:openfga.v1.ListStoresResponse.continuation_token)
  return _impl_.continuation_token_.Release();
}
inline void ListStoresResponse::set_allocated_continuation_token(std::string* continuation_token) {
  if (continuation_token != nullptr) {
    
  } else {
    
  }
  _impl_.continuation_token_.SetAllocated(continuation_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.continuation_token_.IsDefault()) {
    _impl_.continuation_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ListStoresResponse.continuation_token)
}

// -------------------------------------------------------------------

// AssertionTupleKey

// string object = 1 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void AssertionTupleKey::clear_object() {
  _impl_.object_.ClearToEmpty();
}
inline const std::string& AssertionTupleKey::object() const {
  // @@protoc_insertion_point(field_get:openfga.v1.AssertionTupleKey.object)
  return _internal_object();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssertionTupleKey::set_object(ArgT0&& arg0, ArgT... args) {
 
 _impl_.object_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.AssertionTupleKey.object)
}
inline std::string* AssertionTupleKey::mutable_object() {
  std::string* _s = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:openfga.v1.AssertionTupleKey.object)
  return _s;
}
inline const std::string& AssertionTupleKey::_internal_object() const {
  return _impl_.object_.Get();
}
inline void AssertionTupleKey::_internal_set_object(const std::string& value) {
  
  _impl_.object_.Set(value, GetArenaForAllocation());
}
inline std::string* AssertionTupleKey::_internal_mutable_object() {
  
  return _impl_.object_.Mutable(GetArenaForAllocation());
}
inline std::string* AssertionTupleKey::release_object() {
  // @@protoc_insertion_point(field_release:openfga.v1.AssertionTupleKey.object)
  return _impl_.object_.Release();
}
inline void AssertionTupleKey::set_allocated_object(std::string* object) {
  if (object != nullptr) {
    
  } else {
    
  }
  _impl_.object_.SetAllocated(object, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.object_.IsDefault()) {
    _impl_.object_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.AssertionTupleKey.object)
}

// string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void AssertionTupleKey::clear_relation() {
  _impl_.relation_.ClearToEmpty();
}
inline const std::string& AssertionTupleKey::relation() const {
  // @@protoc_insertion_point(field_get:openfga.v1.AssertionTupleKey.relation)
  return _internal_relation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssertionTupleKey::set_relation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.relation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.AssertionTupleKey.relation)
}
inline std::string* AssertionTupleKey::mutable_relation() {
  std::string* _s = _internal_mutable_relation();
  // @@protoc_insertion_point(field_mutable:openfga.v1.AssertionTupleKey.relation)
  return _s;
}
inline const std::string& AssertionTupleKey::_internal_relation() const {
  return _impl_.relation_.Get();
}
inline void AssertionTupleKey::_internal_set_relation(const std::string& value) {
  
  _impl_.relation_.Set(value, GetArenaForAllocation());
}
inline std::string* AssertionTupleKey::_internal_mutable_relation() {
  
  return _impl_.relation_.Mutable(GetArenaForAllocation());
}
inline std::string* AssertionTupleKey::release_relation() {
  // @@protoc_insertion_point(field_release:openfga.v1.AssertionTupleKey.relation)
  return _impl_.relation_.Release();
}
inline void AssertionTupleKey::set_allocated_relation(std::string* relation) {
  if (relation != nullptr) {
    
  } else {
    
  }
  _impl_.relation_.SetAllocated(relation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.relation_.IsDefault()) {
    _impl_.relation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.AssertionTupleKey.relation)
}

// string user = 3 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void AssertionTupleKey::clear_user() {
  _impl_.user_.ClearToEmpty();
}
inline const std::string& AssertionTupleKey::user() const {
  // @@protoc_insertion_point(field_get:openfga.v1.AssertionTupleKey.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssertionTupleKey::set_user(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.AssertionTupleKey.user)
}
inline std::string* AssertionTupleKey::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:openfga.v1.AssertionTupleKey.user)
  return _s;
}
inline const std::string& AssertionTupleKey::_internal_user() const {
  return _impl_.user_.Get();
}
inline void AssertionTupleKey::_internal_set_user(const std::string& value) {
  
  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* AssertionTupleKey::_internal_mutable_user() {
  
  return _impl_.user_.Mutable(GetArenaForAllocation());
}
inline std::string* AssertionTupleKey::release_user() {
  // @@protoc_insertion_point(field_release:openfga.v1.AssertionTupleKey.user)
  return _impl_.user_.Release();
}
inline void AssertionTupleKey::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  _impl_.user_.SetAllocated(user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.AssertionTupleKey.user)
}

// -------------------------------------------------------------------

// Assertion

// .openfga.v1.AssertionTupleKey tuple_key = 1 [json_name = "tuple_key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool Assertion::_internal_has_tuple_key() const {
  return this != internal_default_instance() && _impl_.tuple_key_ != nullptr;
}
inline bool Assertion::has_tuple_key() const {
  return _internal_has_tuple_key();
}
inline void Assertion::clear_tuple_key() {
  if (GetArenaForAllocation() == nullptr && _impl_.tuple_key_ != nullptr) {
    delete _impl_.tuple_key_;
  }
  _impl_.tuple_key_ = nullptr;
}
inline const ::openfga::v1::AssertionTupleKey& Assertion::_internal_tuple_key() const {
  const ::openfga::v1::AssertionTupleKey* p = _impl_.tuple_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::AssertionTupleKey&>(
      ::openfga::v1::_AssertionTupleKey_default_instance_);
}
inline const ::openfga::v1::AssertionTupleKey& Assertion::tuple_key() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Assertion.tuple_key)
  return _internal_tuple_key();
}
inline void Assertion::unsafe_arena_set_allocated_tuple_key(
    ::openfga::v1::AssertionTupleKey* tuple_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tuple_key_);
  }
  _impl_.tuple_key_ = tuple_key;
  if (tuple_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.Assertion.tuple_key)
}
inline ::openfga::v1::AssertionTupleKey* Assertion::release_tuple_key() {
  
  ::openfga::v1::AssertionTupleKey* temp = _impl_.tuple_key_;
  _impl_.tuple_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::AssertionTupleKey* Assertion::unsafe_arena_release_tuple_key() {
  // @@protoc_insertion_point(field_release:openfga.v1.Assertion.tuple_key)
  
  ::openfga::v1::AssertionTupleKey* temp = _impl_.tuple_key_;
  _impl_.tuple_key_ = nullptr;
  return temp;
}
inline ::openfga::v1::AssertionTupleKey* Assertion::_internal_mutable_tuple_key() {
  
  if (_impl_.tuple_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::AssertionTupleKey>(GetArenaForAllocation());
    _impl_.tuple_key_ = p;
  }
  return _impl_.tuple_key_;
}
inline ::openfga::v1::AssertionTupleKey* Assertion::mutable_tuple_key() {
  ::openfga::v1::AssertionTupleKey* _msg = _internal_mutable_tuple_key();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Assertion.tuple_key)
  return _msg;
}
inline void Assertion::set_allocated_tuple_key(::openfga::v1::AssertionTupleKey* tuple_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tuple_key_;
  }
  if (tuple_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tuple_key);
    if (message_arena != submessage_arena) {
      tuple_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tuple_key, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tuple_key_ = tuple_key;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.Assertion.tuple_key)
}

// bool expectation = 2 [json_name = "expectation", (.google.api.field_behavior) = REQUIRED];
inline void Assertion::clear_expectation() {
  _impl_.expectation_ = false;
}
inline bool Assertion::_internal_expectation() const {
  return _impl_.expectation_;
}
inline bool Assertion::expectation() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Assertion.expectation)
  return _internal_expectation();
}
inline void Assertion::_internal_set_expectation(bool value) {
  
  _impl_.expectation_ = value;
}
inline void Assertion::set_expectation(bool value) {
  _internal_set_expectation(value);
  // @@protoc_insertion_point(field_set:openfga.v1.Assertion.expectation)
}

// repeated .openfga.v1.TupleKey contextual_tuples = 3 [json_name = "contextual_tuples", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int Assertion::_internal_contextual_tuples_size() const {
  return _impl_.contextual_tuples_.size();
}
inline int Assertion::contextual_tuples_size() const {
  return _internal_contextual_tuples_size();
}
inline ::openfga::v1::TupleKey* Assertion::mutable_contextual_tuples(int index) {
  // @@protoc_insertion_point(field_mutable:openfga.v1.Assertion.contextual_tuples)
  return _impl_.contextual_tuples_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKey >*
Assertion::mutable_contextual_tuples() {
  // @@protoc_insertion_point(field_mutable_list:openfga.v1.Assertion.contextual_tuples)
  return &_impl_.contextual_tuples_;
}
inline const ::openfga::v1::TupleKey& Assertion::_internal_contextual_tuples(int index) const {
  return _impl_.contextual_tuples_.Get(index);
}
inline const ::openfga::v1::TupleKey& Assertion::contextual_tuples(int index) const {
  // @@protoc_insertion_point(field_get:openfga.v1.Assertion.contextual_tuples)
  return _internal_contextual_tuples(index);
}
inline ::openfga::v1::TupleKey* Assertion::_internal_add_contextual_tuples() {
  return _impl_.contextual_tuples_.Add();
}
inline ::openfga::v1::TupleKey* Assertion::add_contextual_tuples() {
  ::openfga::v1::TupleKey* _add = _internal_add_contextual_tuples();
  // @@protoc_insertion_point(field_add:openfga.v1.Assertion.contextual_tuples)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKey >&
Assertion::contextual_tuples() const {
  // @@protoc_insertion_point(field_list:openfga.v1.Assertion.contextual_tuples)
  return _impl_.contextual_tuples_;
}

// .google.protobuf.Struct context = 4 [json_name = "context", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline bool Assertion::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool Assertion::has_context() const {
  return _internal_has_context();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Assertion::_internal_context() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Assertion::context() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Assertion.context)
  return _internal_context();
}
inline void Assertion::unsafe_arena_set_allocated_context(
    ::PROTOBUF_NAMESPACE_ID::Struct* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.Assertion.context)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Assertion::release_context() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Assertion::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:openfga.v1.Assertion.context)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Assertion::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Assertion::mutable_context() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Assertion.context)
  return _msg;
}
inline void Assertion::set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(context));
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.Assertion.context)
}

// -------------------------------------------------------------------

// Assertions

// repeated .openfga.v1.Assertion assertions = 1 [json_name = "assertions", (.google.api.field_behavior) = REQUIRED];
inline int Assertions::_internal_assertions_size() const {
  return _impl_.assertions_.size();
}
inline int Assertions::assertions_size() const {
  return _internal_assertions_size();
}
inline void Assertions::clear_assertions() {
  _impl_.assertions_.Clear();
}
inline ::openfga::v1::Assertion* Assertions::mutable_assertions(int index) {
  // @@protoc_insertion_point(field_mutable:openfga.v1.Assertions.assertions)
  return _impl_.assertions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Assertion >*
Assertions::mutable_assertions() {
  // @@protoc_insertion_point(field_mutable_list:openfga.v1.Assertions.assertions)
  return &_impl_.assertions_;
}
inline const ::openfga::v1::Assertion& Assertions::_internal_assertions(int index) const {
  return _impl_.assertions_.Get(index);
}
inline const ::openfga::v1::Assertion& Assertions::assertions(int index) const {
  // @@protoc_insertion_point(field_get:openfga.v1.Assertions.assertions)
  return _internal_assertions(index);
}
inline ::openfga::v1::Assertion* Assertions::_internal_add_assertions() {
  return _impl_.assertions_.Add();
}
inline ::openfga::v1::Assertion* Assertions::add_assertions() {
  ::openfga::v1::Assertion* _add = _internal_add_assertions();
  // @@protoc_insertion_point(field_add:openfga.v1.Assertions.assertions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Assertion >&
Assertions::assertions() const {
  // @@protoc_insertion_point(field_list:openfga.v1.Assertions.assertions)
  return _impl_.assertions_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace openfga

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_openfga_2fv1_2fopenfga_5fservice_2eproto
