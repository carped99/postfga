// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: openfga/v1/openfga.proto

#include "openfga/v1/openfga.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace openfga {
namespace v1 {
PROTOBUF_CONSTEXPR Object::Object(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ObjectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ObjectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ObjectDefaultTypeInternal() {}
  union {
    Object _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ObjectDefaultTypeInternal _Object_default_instance_;
PROTOBUF_CONSTEXPR User::User(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.user_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct UserDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserDefaultTypeInternal() {}
  union {
    User _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserDefaultTypeInternal _User_default_instance_;
PROTOBUF_CONSTEXPR UsersetUser::UsersetUser(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.relation_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UsersetUserDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UsersetUserDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UsersetUserDefaultTypeInternal() {}
  union {
    UsersetUser _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UsersetUserDefaultTypeInternal _UsersetUser_default_instance_;
PROTOBUF_CONSTEXPR RelationshipCondition::RelationshipCondition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.context_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RelationshipConditionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RelationshipConditionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RelationshipConditionDefaultTypeInternal() {}
  union {
    RelationshipCondition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RelationshipConditionDefaultTypeInternal _RelationshipCondition_default_instance_;
PROTOBUF_CONSTEXPR TupleKeyWithoutCondition::TupleKeyWithoutCondition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.user_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.relation_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.object_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TupleKeyWithoutConditionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TupleKeyWithoutConditionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TupleKeyWithoutConditionDefaultTypeInternal() {}
  union {
    TupleKeyWithoutCondition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TupleKeyWithoutConditionDefaultTypeInternal _TupleKeyWithoutCondition_default_instance_;
PROTOBUF_CONSTEXPR TypedWildcard::TypedWildcard(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TypedWildcardDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TypedWildcardDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TypedWildcardDefaultTypeInternal() {}
  union {
    TypedWildcard _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TypedWildcardDefaultTypeInternal _TypedWildcard_default_instance_;
PROTOBUF_CONSTEXPR TupleKey::TupleKey(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.user_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.relation_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.object_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.condition_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TupleKeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TupleKeyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TupleKeyDefaultTypeInternal() {}
  union {
    TupleKey _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TupleKeyDefaultTypeInternal _TupleKey_default_instance_;
PROTOBUF_CONSTEXPR Tuple::Tuple(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/nullptr
  , /*decltype(_impl_.timestamp_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TupleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TupleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TupleDefaultTypeInternal() {}
  union {
    Tuple _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TupleDefaultTypeInternal _Tuple_default_instance_;
PROTOBUF_CONSTEXPR TupleKeys::TupleKeys(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tuple_keys_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TupleKeysDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TupleKeysDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TupleKeysDefaultTypeInternal() {}
  union {
    TupleKeys _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TupleKeysDefaultTypeInternal _TupleKeys_default_instance_;
PROTOBUF_CONSTEXPR ContextualTupleKeys::ContextualTupleKeys(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tuple_keys_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ContextualTupleKeysDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContextualTupleKeysDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContextualTupleKeysDefaultTypeInternal() {}
  union {
    ContextualTupleKeys _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContextualTupleKeysDefaultTypeInternal _ContextualTupleKeys_default_instance_;
PROTOBUF_CONSTEXPR UsersetTree_Leaf::UsersetTree_Leaf(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct UsersetTree_LeafDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UsersetTree_LeafDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UsersetTree_LeafDefaultTypeInternal() {}
  union {
    UsersetTree_Leaf _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UsersetTree_LeafDefaultTypeInternal _UsersetTree_Leaf_default_instance_;
PROTOBUF_CONSTEXPR UsersetTree_Nodes::UsersetTree_Nodes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nodes_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UsersetTree_NodesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UsersetTree_NodesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UsersetTree_NodesDefaultTypeInternal() {}
  union {
    UsersetTree_Nodes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UsersetTree_NodesDefaultTypeInternal _UsersetTree_Nodes_default_instance_;
PROTOBUF_CONSTEXPR UsersetTree_Users::UsersetTree_Users(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.users_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UsersetTree_UsersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UsersetTree_UsersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UsersetTree_UsersDefaultTypeInternal() {}
  union {
    UsersetTree_Users _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UsersetTree_UsersDefaultTypeInternal _UsersetTree_Users_default_instance_;
PROTOBUF_CONSTEXPR UsersetTree_Computed::UsersetTree_Computed(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.userset_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UsersetTree_ComputedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UsersetTree_ComputedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UsersetTree_ComputedDefaultTypeInternal() {}
  union {
    UsersetTree_Computed _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UsersetTree_ComputedDefaultTypeInternal _UsersetTree_Computed_default_instance_;
PROTOBUF_CONSTEXPR UsersetTree_TupleToUserset::UsersetTree_TupleToUserset(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.computed_)*/{}
  , /*decltype(_impl_.tupleset_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UsersetTree_TupleToUsersetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UsersetTree_TupleToUsersetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UsersetTree_TupleToUsersetDefaultTypeInternal() {}
  union {
    UsersetTree_TupleToUserset _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UsersetTree_TupleToUsersetDefaultTypeInternal _UsersetTree_TupleToUserset_default_instance_;
PROTOBUF_CONSTEXPR UsersetTree_Difference::UsersetTree_Difference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_.subtract_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UsersetTree_DifferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UsersetTree_DifferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UsersetTree_DifferenceDefaultTypeInternal() {}
  union {
    UsersetTree_Difference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UsersetTree_DifferenceDefaultTypeInternal _UsersetTree_Difference_default_instance_;
PROTOBUF_CONSTEXPR UsersetTree_Node::UsersetTree_Node(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct UsersetTree_NodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UsersetTree_NodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UsersetTree_NodeDefaultTypeInternal() {}
  union {
    UsersetTree_Node _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UsersetTree_NodeDefaultTypeInternal _UsersetTree_Node_default_instance_;
PROTOBUF_CONSTEXPR UsersetTree::UsersetTree(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.root_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UsersetTreeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UsersetTreeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UsersetTreeDefaultTypeInternal() {}
  union {
    UsersetTree _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UsersetTreeDefaultTypeInternal _UsersetTree_default_instance_;
PROTOBUF_CONSTEXPR TupleChange::TupleChange(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tuple_key_)*/nullptr
  , /*decltype(_impl_.timestamp_)*/nullptr
  , /*decltype(_impl_.operation_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TupleChangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TupleChangeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TupleChangeDefaultTypeInternal() {}
  union {
    TupleChange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TupleChangeDefaultTypeInternal _TupleChange_default_instance_;
PROTOBUF_CONSTEXPR Store::Store(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.created_at_)*/nullptr
  , /*decltype(_impl_.updated_at_)*/nullptr
  , /*decltype(_impl_.deleted_at_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StoreDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StoreDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StoreDefaultTypeInternal() {}
  union {
    Store _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StoreDefaultTypeInternal _Store_default_instance_;
PROTOBUF_CONSTEXPR UserTypeFilter::UserTypeFilter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.relation_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UserTypeFilterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserTypeFilterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserTypeFilterDefaultTypeInternal() {}
  union {
    UserTypeFilter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserTypeFilterDefaultTypeInternal _UserTypeFilter_default_instance_;
}  // namespace v1
}  // namespace openfga
static ::_pb::Metadata file_level_metadata_openfga_2fv1_2fopenfga_2eproto[21];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_openfga_2fv1_2fopenfga_2eproto[1];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_openfga_2fv1_2fopenfga_2eproto = nullptr;

const uint32_t TableStruct_openfga_2fv1_2fopenfga_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::Object, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::Object, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::Object, _impl_.id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::User, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::User, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::openfga::v1::User, _impl_.user_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UsersetUser, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UsersetUser, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UsersetUser, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UsersetUser, _impl_.relation_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::RelationshipCondition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::RelationshipCondition, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::RelationshipCondition, _impl_.context_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::TupleKeyWithoutCondition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::TupleKeyWithoutCondition, _impl_.user_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::TupleKeyWithoutCondition, _impl_.relation_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::TupleKeyWithoutCondition, _impl_.object_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::TypedWildcard, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::TypedWildcard, _impl_.type_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::TupleKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::TupleKey, _impl_.user_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::TupleKey, _impl_.relation_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::TupleKey, _impl_.object_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::TupleKey, _impl_.condition_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::Tuple, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::Tuple, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::Tuple, _impl_.timestamp_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::TupleKeys, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::TupleKeys, _impl_.tuple_keys_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ContextualTupleKeys, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ContextualTupleKeys, _impl_.tuple_keys_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UsersetTree_Leaf, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UsersetTree_Leaf, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UsersetTree_Leaf, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UsersetTree_Nodes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UsersetTree_Nodes, _impl_.nodes_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UsersetTree_Users, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UsersetTree_Users, _impl_.users_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UsersetTree_Computed, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UsersetTree_Computed, _impl_.userset_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UsersetTree_TupleToUserset, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UsersetTree_TupleToUserset, _impl_.tupleset_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UsersetTree_TupleToUserset, _impl_.computed_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UsersetTree_Difference, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UsersetTree_Difference, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UsersetTree_Difference, _impl_.subtract_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UsersetTree_Node, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UsersetTree_Node, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UsersetTree_Node, _impl_.name_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UsersetTree_Node, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UsersetTree, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UsersetTree, _impl_.root_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::TupleChange, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::TupleChange, _impl_.tuple_key_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::TupleChange, _impl_.operation_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::TupleChange, _impl_.timestamp_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::Store, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::Store, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::Store, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::Store, _impl_.created_at_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::Store, _impl_.updated_at_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::Store, _impl_.deleted_at_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UserTypeFilter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UserTypeFilter, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UserTypeFilter, _impl_.relation_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::openfga::v1::Object)},
  { 8, -1, -1, sizeof(::openfga::v1::User)},
  { 18, -1, -1, sizeof(::openfga::v1::UsersetUser)},
  { 27, -1, -1, sizeof(::openfga::v1::RelationshipCondition)},
  { 35, -1, -1, sizeof(::openfga::v1::TupleKeyWithoutCondition)},
  { 44, -1, -1, sizeof(::openfga::v1::TypedWildcard)},
  { 51, -1, -1, sizeof(::openfga::v1::TupleKey)},
  { 61, -1, -1, sizeof(::openfga::v1::Tuple)},
  { 69, -1, -1, sizeof(::openfga::v1::TupleKeys)},
  { 76, -1, -1, sizeof(::openfga::v1::ContextualTupleKeys)},
  { 83, -1, -1, sizeof(::openfga::v1::UsersetTree_Leaf)},
  { 93, -1, -1, sizeof(::openfga::v1::UsersetTree_Nodes)},
  { 100, -1, -1, sizeof(::openfga::v1::UsersetTree_Users)},
  { 107, -1, -1, sizeof(::openfga::v1::UsersetTree_Computed)},
  { 114, -1, -1, sizeof(::openfga::v1::UsersetTree_TupleToUserset)},
  { 122, -1, -1, sizeof(::openfga::v1::UsersetTree_Difference)},
  { 130, -1, -1, sizeof(::openfga::v1::UsersetTree_Node)},
  { 142, -1, -1, sizeof(::openfga::v1::UsersetTree)},
  { 149, -1, -1, sizeof(::openfga::v1::TupleChange)},
  { 158, -1, -1, sizeof(::openfga::v1::Store)},
  { 169, -1, -1, sizeof(::openfga::v1::UserTypeFilter)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::openfga::v1::_Object_default_instance_._instance,
  &::openfga::v1::_User_default_instance_._instance,
  &::openfga::v1::_UsersetUser_default_instance_._instance,
  &::openfga::v1::_RelationshipCondition_default_instance_._instance,
  &::openfga::v1::_TupleKeyWithoutCondition_default_instance_._instance,
  &::openfga::v1::_TypedWildcard_default_instance_._instance,
  &::openfga::v1::_TupleKey_default_instance_._instance,
  &::openfga::v1::_Tuple_default_instance_._instance,
  &::openfga::v1::_TupleKeys_default_instance_._instance,
  &::openfga::v1::_ContextualTupleKeys_default_instance_._instance,
  &::openfga::v1::_UsersetTree_Leaf_default_instance_._instance,
  &::openfga::v1::_UsersetTree_Nodes_default_instance_._instance,
  &::openfga::v1::_UsersetTree_Users_default_instance_._instance,
  &::openfga::v1::_UsersetTree_Computed_default_instance_._instance,
  &::openfga::v1::_UsersetTree_TupleToUserset_default_instance_._instance,
  &::openfga::v1::_UsersetTree_Difference_default_instance_._instance,
  &::openfga::v1::_UsersetTree_Node_default_instance_._instance,
  &::openfga::v1::_UsersetTree_default_instance_._instance,
  &::openfga::v1::_TupleChange_default_instance_._instance,
  &::openfga::v1::_Store_default_instance_._instance,
  &::openfga::v1::_UserTypeFilter_default_instance_._instance,
};

const char descriptor_table_protodef_openfga_2fv1_2fopenfga_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\030openfga/v1/openfga.proto\022\nopenfga.v1\032\037"
  "google/api/field_behavior.proto\032\034google/"
  "protobuf/struct.proto\032\037google/protobuf/t"
  "imestamp.proto\032.protoc-gen-openapiv2/opt"
  "ions/annotations.proto\032\027validate/validat"
  "e.proto\"\236\001\n\006Object\022A\n\004type\030\001 \001(\tB-\222A\014J\n\""
  "document\"\340A\002\372B\030r\0262\021^[^:#@\\s]{1,254}$\320\001\000R"
  "\004type\022Q\n\002id\030\002 \001(\tBA\222A(J&\"0bcdf6fa-a6aa-4"
  "730-a8eb-9cf172ff16d9\"\340A\002\372B\020r\0162\t[^#:\\s]+"
  "$\320\001\000R\002id\"\252\001\n\004User\022,\n\006object\030\001 \001(\0132\022.open"
  "fga.v1.ObjectH\000R\006object\0223\n\007userset\030\002 \001(\013"
  "2\027.openfga.v1.UsersetUserH\000R\007userset\0227\n\010"
  "wildcard\030\003 \001(\0132\031.openfga.v1.TypedWildcar"
  "dH\000R\010wildcardB\006\n\004user\"\307\001\n\013UsersetUser\022>\n"
  "\004type\030\001 \001(\tB*\222A\tJ\007\"group\"\340A\002\372B\030r\0262\021^[^:#"
  "@\\s]{1,254}$\320\001\000R\004type\0220\n\002id\030\002 \001(\tB \222A\007J\005"
  "\"fga\"\340A\002\372B\020r\0162\t[^#:\\s]+$\320\001\000R\002id\022F\n\010relat"
  "ion\030\003 \001(\tB*\222A\nJ\010\"member\"\340A\002\372B\027r\0252\020^[^:#@"
  "\\s]{1,50}$\320\001\001R\010relation\"\217\001\n\025Relationship"
  "Condition\022C\n\004name\030\001 \001(\tB/\222A\021J\014\"condition"
  "1\"x\200\002\340A\002\372B\025r\0232\016^[^\\s]{2,256}$\320\001\000R\004name\0221"
  "\n\007context\030\002 \001(\0132\027.google.protobuf.Struct"
  "R\007context\"\353\001\n\030TupleKeyWithoutCondition\0222"
  "\n\004user\030\001 \001(\tB\036\222A\020J\013\"user:anne\"x\200\004\340A\002\372B\005r"
  "\003(\200\004R\004user\022H\n\010relation\030\002 \001(\tB,\222A\014J\010\"read"
  "er\"x2\340A\002\372B\027r\0252\020^[^:#@\\s]{1,50}$\320\001\001R\010rela"
  "tion\022Q\n\006object\030\003 \001(\tB9\222A\033J\026\"document:202"
  "1-budget\"x\200\002\340A\002\372B\025r\0232\016^[^\\s]{2,256}$\320\001\001R"
  "\006object\"R\n\rTypedWildcard\022A\n\004type\030\001 \001(\tB-"
  "\222A\014J\n\"employee\"\340A\002\372B\030r\0262\021^[^:#@\\s]{1,254"
  "}$\320\001\000R\004type\"\237\002\n\010TupleKey\0225\n\004user\030\001 \001(\tB!"
  "\222A\020J\013\"user:anne\"x\200\004\340A\002\372B\010r\006(\200\004\320\001\000R\004user\022"
  "H\n\010relation\030\002 \001(\tB,\222A\014J\010\"reader\"x2\340A\002\372B\027"
  "r\0252\020^[^:#@\\s]{1,50}$\320\001\001R\010relation\022Q\n\006obj"
  "ect\030\003 \001(\tB9\222A\033J\026\"document:2021-budget\"x\200"
  "\002\340A\002\372B\025r\0232\016^[^\\s]{2,256}$\320\001\001R\006object\022\?\n\t"
  "condition\030\004 \001(\0132!.openfga.v1.Relationshi"
  "pConditionR\tcondition\"{\n\005Tuple\0223\n\003key\030\001 "
  "\001(\0132\024.openfga.v1.TupleKeyB\013\340A\002\372B\005\212\001\002\020\001R\003"
  "key\022=\n\ttimestamp\030\002 \001(\0132\032.google.protobuf"
  ".TimestampB\003\340A\002R\ttimestamp\"T\n\tTupleKeys\022"
  "G\n\ntuple_keys\030\001 \003(\0132\024.openfga.v1.TupleKe"
  "yB\021\222A\003\250\001\001\340A\002\372B\005\222\001\002\010\001R\ntuple_keys\"^\n\023Cont"
  "extualTupleKeys\022G\n\ntuple_keys\030\001 \003(\0132\024.op"
  "enfga.v1.TupleKeyB\021\222A\003\240\001d\340A\002\372B\005\222\001\002\020dR\ntu"
  "ple_keys\"\351\007\n\013UsersetTree\0220\n\004root\030\001 \001(\0132\034"
  ".openfga.v1.UsersetTree.NodeR\004root\032\332\001\n\004L"
  "eaf\0225\n\005users\030\001 \001(\0132\035.openfga.v1.UsersetT"
  "ree.UsersH\000R\005users\022>\n\010computed\030\002 \001(\0132 .o"
  "penfga.v1.UsersetTree.ComputedH\000R\010comput"
  "ed\022R\n\020tuple_to_userset\030\003 \001(\0132&.openfga.v"
  "1.UsersetTree.TupleToUsersetH\000R\016tupleToU"
  "sersetB\007\n\005value\032@\n\005Nodes\0227\n\005nodes\030\001 \003(\0132"
  "\034.openfga.v1.UsersetTree.NodeB\003\340A\002R\005node"
  "s\032\"\n\005Users\022\031\n\005users\030\001 \003(\tB\003\340A\002R\005users\0321\n"
  "\010Computed\022%\n\007userset\030\001 \001(\tB\013\340A\002\372B\005r\003\320\001\000R"
  "\007userset\032|\n\016TupleToUserset\022\'\n\010tupleset\030\001"
  " \001(\tB\013\340A\002\372B\005r\003\320\001\000R\010tupleset\022A\n\010computed\030"
  "\002 \003(\0132 .openfga.v1.UsersetTree.ComputedB"
  "\003\340A\002R\010computed\032\222\001\n\nDifference\022=\n\004base\030\001 "
  "\001(\0132\034.openfga.v1.UsersetTree.NodeB\013\340A\002\372B"
  "\005\212\001\002\020\001R\004base\022E\n\010subtract\030\002 \001(\0132\034.openfga"
  ".v1.UsersetTree.NodeB\013\340A\002\372B\005\212\001\002\020\001R\010subtr"
  "act\032\236\002\n\004Node\022\027\n\004name\030\001 \001(\tB\003\340A\002R\004name\0222\n"
  "\004leaf\030\002 \001(\0132\034.openfga.v1.UsersetTree.Lea"
  "fH\000R\004leaf\022D\n\ndifference\030\005 \001(\0132\".openfga."
  "v1.UsersetTree.DifferenceH\000R\ndifference\022"
  "5\n\005union\030\006 \001(\0132\035.openfga.v1.UsersetTree."
  "NodesH\000R\005union\022C\n\014intersection\030\007 \001(\0132\035.o"
  "penfga.v1.UsersetTree.NodesH\000R\014intersect"
  "ionB\007\n\005value\"\324\001\n\013TupleChange\022\?\n\ttuple_ke"
  "y\030\001 \001(\0132\024.openfga.v1.TupleKeyB\013\340A\002\372B\005\212\001\002"
  "\020\001R\ttuple_key\022E\n\toperation\030\002 \001(\0162\032.openf"
  "ga.v1.TupleOperationB\013\340A\002\372B\005\202\001\002\020\001R\topera"
  "tion\022=\n\ttimestamp\030\003 \001(\0132\032.google.protobu"
  "f.TimestampB\003\340A\002R\ttimestamp\"\203\002\n\005Store\022\033\n"
  "\002id\030\001 \001(\tB\013\340A\002\372B\005r\003\320\001\000R\002id\022\037\n\004name\030\002 \001(\t"
  "B\013\340A\002\372B\005r\003\320\001\000R\004name\022\?\n\ncreated_at\030\003 \001(\0132"
  "\032.google.protobuf.TimestampB\003\340A\002R\ncreate"
  "d_at\022\?\n\nupdated_at\030\004 \001(\0132\032.google.protob"
  "uf.TimestampB\003\340A\002R\nupdated_at\022:\n\ndeleted"
  "_at\030\005 \001(\0132\032.google.protobuf.TimestampR\nd"
  "eleted_at\"\225\001\n\016UserTypeFilter\022>\n\004type\030\001 \001"
  "(\tB*\222A\tJ\007\"group\"\340A\002\372B\030r\0262\021^[^:#@\\s]{1,25"
  "4}$\320\001\000R\004type\022C\n\010relation\030\002 \001(\tB\'\222A\nJ\010\"me"
  "mber\"\372B\027r\0252\020^[^:#@\\s]{1,50}$\320\001\001R\010relatio"
  "n*G\n\016TupleOperation\022\031\n\025TUPLE_OPERATION_W"
  "RITE\020\000\022\032\n\026TUPLE_OPERATION_DELETE\020\001Bg\n\016co"
  "m.openfga.v1B\014OpenfgaProtoP\001\242\002\003OXX\252\002\nOpe"
  "nfga.V1\312\002\nOpenfga\\V1\342\002\026Openfga\\V1\\GPBMet"
  "adata\352\002\013Openfga::V1b\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_openfga_2fv1_2fopenfga_2eproto_deps[5] = {
  &::descriptor_table_google_2fapi_2ffield_5fbehavior_2eproto,
  &::descriptor_table_google_2fprotobuf_2fstruct_2eproto,
  &::descriptor_table_google_2fprotobuf_2ftimestamp_2eproto,
  &::descriptor_table_protoc_2dgen_2dopenapiv2_2foptions_2fannotations_2eproto,
  &::descriptor_table_validate_2fvalidate_2eproto,
};
static ::_pbi::once_flag descriptor_table_openfga_2fv1_2fopenfga_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_openfga_2fv1_2fopenfga_2eproto = {
    false, false, 3627, descriptor_table_protodef_openfga_2fv1_2fopenfga_2eproto,
    "openfga/v1/openfga.proto",
    &descriptor_table_openfga_2fv1_2fopenfga_2eproto_once, descriptor_table_openfga_2fv1_2fopenfga_2eproto_deps, 5, 21,
    schemas, file_default_instances, TableStruct_openfga_2fv1_2fopenfga_2eproto::offsets,
    file_level_metadata_openfga_2fv1_2fopenfga_2eproto, file_level_enum_descriptors_openfga_2fv1_2fopenfga_2eproto,
    file_level_service_descriptors_openfga_2fv1_2fopenfga_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_openfga_2fv1_2fopenfga_2eproto_getter() {
  return &descriptor_table_openfga_2fv1_2fopenfga_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_openfga_2fv1_2fopenfga_2eproto(&descriptor_table_openfga_2fv1_2fopenfga_2eproto);
namespace openfga {
namespace v1 {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TupleOperation_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_openfga_2fv1_2fopenfga_2eproto);
  return file_level_enum_descriptors_openfga_2fv1_2fopenfga_2eproto[0];
}
bool TupleOperation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Object::_Internal {
 public:
};

Object::Object(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.Object)
}
Object::Object(const Object& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Object* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){}
    , decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type().empty()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.Object)
}

inline void Object::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){}
    , decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Object::~Object() {
  // @@protoc_insertion_point(destructor:openfga.v1.Object)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Object::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.type_.Destroy();
  _impl_.id_.Destroy();
}

void Object::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Object::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.Object)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.type_.ClearToEmpty();
  _impl_.id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Object::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type = 1 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.Object.type"));
        } else
          goto handle_unusual;
        continue;
      // string id = 2 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.Object.id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Object::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.Object)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type = 1 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.Object.type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type(), target);
  }

  // string id = 2 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.Object.id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.Object)
  return target;
}

size_t Object::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.Object)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string type = 1 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());
  }

  // string id = 2 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Object::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Object::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Object::GetClassData() const { return &_class_data_; }


void Object::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Object*>(&to_msg);
  auto& from = static_cast<const Object&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.Object)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_type().empty()) {
    _this->_internal_set_type(from._internal_type());
  }
  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Object::CopyFrom(const Object& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.Object)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Object::IsInitialized() const {
  return true;
}

void Object::InternalSwap(Object* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Object::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_2eproto[0]);
}

// ===================================================================

class User::_Internal {
 public:
  static const ::openfga::v1::Object& object(const User* msg);
  static const ::openfga::v1::UsersetUser& userset(const User* msg);
  static const ::openfga::v1::TypedWildcard& wildcard(const User* msg);
};

const ::openfga::v1::Object&
User::_Internal::object(const User* msg) {
  return *msg->_impl_.user_.object_;
}
const ::openfga::v1::UsersetUser&
User::_Internal::userset(const User* msg) {
  return *msg->_impl_.user_.userset_;
}
const ::openfga::v1::TypedWildcard&
User::_Internal::wildcard(const User* msg) {
  return *msg->_impl_.user_.wildcard_;
}
void User::set_allocated_object(::openfga::v1::Object* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_user();
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    set_has_object();
    _impl_.user_.object_ = object;
  }
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.User.object)
}
void User::set_allocated_userset(::openfga::v1::UsersetUser* userset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_user();
  if (userset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(userset);
    if (message_arena != submessage_arena) {
      userset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, userset, submessage_arena);
    }
    set_has_userset();
    _impl_.user_.userset_ = userset;
  }
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.User.userset)
}
void User::set_allocated_wildcard(::openfga::v1::TypedWildcard* wildcard) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_user();
  if (wildcard) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wildcard);
    if (message_arena != submessage_arena) {
      wildcard = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wildcard, submessage_arena);
    }
    set_has_wildcard();
    _impl_.user_.wildcard_ = wildcard;
  }
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.User.wildcard)
}
User::User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.User)
}
User::User(const User& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  User* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.user_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_user();
  switch (from.user_case()) {
    case kObject: {
      _this->_internal_mutable_object()->::openfga::v1::Object::MergeFrom(
          from._internal_object());
      break;
    }
    case kUserset: {
      _this->_internal_mutable_userset()->::openfga::v1::UsersetUser::MergeFrom(
          from._internal_userset());
      break;
    }
    case kWildcard: {
      _this->_internal_mutable_wildcard()->::openfga::v1::TypedWildcard::MergeFrom(
          from._internal_wildcard());
      break;
    }
    case USER_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.User)
}

inline void User::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.user_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_user();
}

User::~User() {
  // @@protoc_insertion_point(destructor:openfga.v1.User)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void User::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_user()) {
    clear_user();
  }
}

void User::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void User::clear_user() {
// @@protoc_insertion_point(one_of_clear_start:openfga.v1.User)
  switch (user_case()) {
    case kObject: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.user_.object_;
      }
      break;
    }
    case kUserset: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.user_.userset_;
      }
      break;
    }
    case kWildcard: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.user_.wildcard_;
      }
      break;
    }
    case USER_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = USER_NOT_SET;
}


void User::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.User)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_user();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* User::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .openfga.v1.Object object = 1 [json_name = "object"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_object(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.UsersetUser userset = 2 [json_name = "userset"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_userset(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.TypedWildcard wildcard = 3 [json_name = "wildcard"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_wildcard(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* User::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.User)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .openfga.v1.Object object = 1 [json_name = "object"];
  if (_internal_has_object()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::object(this),
        _Internal::object(this).GetCachedSize(), target, stream);
  }

  // .openfga.v1.UsersetUser userset = 2 [json_name = "userset"];
  if (_internal_has_userset()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::userset(this),
        _Internal::userset(this).GetCachedSize(), target, stream);
  }

  // .openfga.v1.TypedWildcard wildcard = 3 [json_name = "wildcard"];
  if (_internal_has_wildcard()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::wildcard(this),
        _Internal::wildcard(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.User)
  return target;
}

size_t User::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.User)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (user_case()) {
    // .openfga.v1.Object object = 1 [json_name = "object"];
    case kObject: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.user_.object_);
      break;
    }
    // .openfga.v1.UsersetUser userset = 2 [json_name = "userset"];
    case kUserset: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.user_.userset_);
      break;
    }
    // .openfga.v1.TypedWildcard wildcard = 3 [json_name = "wildcard"];
    case kWildcard: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.user_.wildcard_);
      break;
    }
    case USER_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData User::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    User::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*User::GetClassData() const { return &_class_data_; }


void User::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<User*>(&to_msg);
  auto& from = static_cast<const User&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.User)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.user_case()) {
    case kObject: {
      _this->_internal_mutable_object()->::openfga::v1::Object::MergeFrom(
          from._internal_object());
      break;
    }
    case kUserset: {
      _this->_internal_mutable_userset()->::openfga::v1::UsersetUser::MergeFrom(
          from._internal_userset());
      break;
    }
    case kWildcard: {
      _this->_internal_mutable_wildcard()->::openfga::v1::TypedWildcard::MergeFrom(
          from._internal_wildcard());
      break;
    }
    case USER_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void User::CopyFrom(const User& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.User)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool User::IsInitialized() const {
  return true;
}

void User::InternalSwap(User* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.user_, other->_impl_.user_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata User::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_2eproto[1]);
}

// ===================================================================

class UsersetUser::_Internal {
 public:
};

UsersetUser::UsersetUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.UsersetUser)
}
UsersetUser::UsersetUser(const UsersetUser& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UsersetUser* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.relation_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type().empty()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.relation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_relation().empty()) {
    _this->_impl_.relation_.Set(from._internal_relation(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.UsersetUser)
}

inline void UsersetUser::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.relation_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.relation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UsersetUser::~UsersetUser() {
  // @@protoc_insertion_point(destructor:openfga.v1.UsersetUser)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UsersetUser::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.type_.Destroy();
  _impl_.id_.Destroy();
  _impl_.relation_.Destroy();
}

void UsersetUser::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UsersetUser::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.UsersetUser)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.type_.ClearToEmpty();
  _impl_.id_.ClearToEmpty();
  _impl_.relation_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UsersetUser::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type = 1 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.UsersetUser.type"));
        } else
          goto handle_unusual;
        continue;
      // string id = 2 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.UsersetUser.id"));
        } else
          goto handle_unusual;
        continue;
      // string relation = 3 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_relation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.UsersetUser.relation"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UsersetUser::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.UsersetUser)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type = 1 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.UsersetUser.type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type(), target);
  }

  // string id = 2 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.UsersetUser.id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_id(), target);
  }

  // string relation = 3 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_relation().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_relation().data(), static_cast<int>(this->_internal_relation().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.UsersetUser.relation");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_relation(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.UsersetUser)
  return target;
}

size_t UsersetUser::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.UsersetUser)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string type = 1 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());
  }

  // string id = 2 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // string relation = 3 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_relation().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_relation());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UsersetUser::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UsersetUser::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UsersetUser::GetClassData() const { return &_class_data_; }


void UsersetUser::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UsersetUser*>(&to_msg);
  auto& from = static_cast<const UsersetUser&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.UsersetUser)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_type().empty()) {
    _this->_internal_set_type(from._internal_type());
  }
  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  if (!from._internal_relation().empty()) {
    _this->_internal_set_relation(from._internal_relation());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UsersetUser::CopyFrom(const UsersetUser& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.UsersetUser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsersetUser::IsInitialized() const {
  return true;
}

void UsersetUser::InternalSwap(UsersetUser* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.relation_, lhs_arena,
      &other->_impl_.relation_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata UsersetUser::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_2eproto[2]);
}

// ===================================================================

class RelationshipCondition::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::Struct& context(const RelationshipCondition* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Struct&
RelationshipCondition::_Internal::context(const RelationshipCondition* msg) {
  return *msg->_impl_.context_;
}
void RelationshipCondition::clear_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
    delete _impl_.context_;
  }
  _impl_.context_ = nullptr;
}
RelationshipCondition::RelationshipCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.RelationshipCondition)
}
RelationshipCondition::RelationshipCondition(const RelationshipCondition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RelationshipCondition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.context_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_context()) {
    _this->_impl_.context_ = new ::PROTOBUF_NAMESPACE_ID::Struct(*from._impl_.context_);
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.RelationshipCondition)
}

inline void RelationshipCondition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.context_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RelationshipCondition::~RelationshipCondition() {
  // @@protoc_insertion_point(destructor:openfga.v1.RelationshipCondition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RelationshipCondition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.context_;
}

void RelationshipCondition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RelationshipCondition::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.RelationshipCondition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
    delete _impl_.context_;
  }
  _impl_.context_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RelationshipCondition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [json_name = "name", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.RelationshipCondition.name"));
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Struct context = 2 [json_name = "context"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_context(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RelationshipCondition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.RelationshipCondition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [json_name = "name", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.RelationshipCondition.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .google.protobuf.Struct context = 2 [json_name = "context"];
  if (this->_internal_has_context()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::context(this),
        _Internal::context(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.RelationshipCondition)
  return target;
}

size_t RelationshipCondition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.RelationshipCondition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [json_name = "name", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .google.protobuf.Struct context = 2 [json_name = "context"];
  if (this->_internal_has_context()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.context_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RelationshipCondition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RelationshipCondition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RelationshipCondition::GetClassData() const { return &_class_data_; }


void RelationshipCondition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RelationshipCondition*>(&to_msg);
  auto& from = static_cast<const RelationshipCondition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.RelationshipCondition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_context()) {
    _this->_internal_mutable_context()->::PROTOBUF_NAMESPACE_ID::Struct::MergeFrom(
        from._internal_context());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RelationshipCondition::CopyFrom(const RelationshipCondition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.RelationshipCondition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RelationshipCondition::IsInitialized() const {
  return true;
}

void RelationshipCondition::InternalSwap(RelationshipCondition* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.context_, other->_impl_.context_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RelationshipCondition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_2eproto[3]);
}

// ===================================================================

class TupleKeyWithoutCondition::_Internal {
 public:
};

TupleKeyWithoutCondition::TupleKeyWithoutCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.TupleKeyWithoutCondition)
}
TupleKeyWithoutCondition::TupleKeyWithoutCondition(const TupleKeyWithoutCondition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TupleKeyWithoutCondition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.user_){}
    , decltype(_impl_.relation_){}
    , decltype(_impl_.object_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user().empty()) {
    _this->_impl_.user_.Set(from._internal_user(), 
      _this->GetArenaForAllocation());
  }
  _impl_.relation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_relation().empty()) {
    _this->_impl_.relation_.Set(from._internal_relation(), 
      _this->GetArenaForAllocation());
  }
  _impl_.object_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.object_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_object().empty()) {
    _this->_impl_.object_.Set(from._internal_object(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.TupleKeyWithoutCondition)
}

inline void TupleKeyWithoutCondition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.user_){}
    , decltype(_impl_.relation_){}
    , decltype(_impl_.object_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.relation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.object_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.object_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TupleKeyWithoutCondition::~TupleKeyWithoutCondition() {
  // @@protoc_insertion_point(destructor:openfga.v1.TupleKeyWithoutCondition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TupleKeyWithoutCondition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_.Destroy();
  _impl_.relation_.Destroy();
  _impl_.object_.Destroy();
}

void TupleKeyWithoutCondition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TupleKeyWithoutCondition::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.TupleKeyWithoutCondition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_.ClearToEmpty();
  _impl_.relation_.ClearToEmpty();
  _impl_.object_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TupleKeyWithoutCondition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string user = 1 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.TupleKeyWithoutCondition.user"));
        } else
          goto handle_unusual;
        continue;
      // string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_relation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.TupleKeyWithoutCondition.relation"));
        } else
          goto handle_unusual;
        continue;
      // string object = 3 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_object();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.TupleKeyWithoutCondition.object"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TupleKeyWithoutCondition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.TupleKeyWithoutCondition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string user = 1 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_user().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user().data(), static_cast<int>(this->_internal_user().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.TupleKeyWithoutCondition.user");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user(), target);
  }

  // string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_relation().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_relation().data(), static_cast<int>(this->_internal_relation().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.TupleKeyWithoutCondition.relation");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_relation(), target);
  }

  // string object = 3 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_object().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_object().data(), static_cast<int>(this->_internal_object().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.TupleKeyWithoutCondition.object");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_object(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.TupleKeyWithoutCondition)
  return target;
}

size_t TupleKeyWithoutCondition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.TupleKeyWithoutCondition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string user = 1 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_user().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user());
  }

  // string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_relation().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_relation());
  }

  // string object = 3 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_object().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_object());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TupleKeyWithoutCondition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TupleKeyWithoutCondition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TupleKeyWithoutCondition::GetClassData() const { return &_class_data_; }


void TupleKeyWithoutCondition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TupleKeyWithoutCondition*>(&to_msg);
  auto& from = static_cast<const TupleKeyWithoutCondition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.TupleKeyWithoutCondition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_user().empty()) {
    _this->_internal_set_user(from._internal_user());
  }
  if (!from._internal_relation().empty()) {
    _this->_internal_set_relation(from._internal_relation());
  }
  if (!from._internal_object().empty()) {
    _this->_internal_set_object(from._internal_object());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TupleKeyWithoutCondition::CopyFrom(const TupleKeyWithoutCondition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.TupleKeyWithoutCondition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TupleKeyWithoutCondition::IsInitialized() const {
  return true;
}

void TupleKeyWithoutCondition::InternalSwap(TupleKeyWithoutCondition* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_, lhs_arena,
      &other->_impl_.user_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.relation_, lhs_arena,
      &other->_impl_.relation_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.object_, lhs_arena,
      &other->_impl_.object_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata TupleKeyWithoutCondition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_2eproto[4]);
}

// ===================================================================

class TypedWildcard::_Internal {
 public:
};

TypedWildcard::TypedWildcard(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.TypedWildcard)
}
TypedWildcard::TypedWildcard(const TypedWildcard& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TypedWildcard* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type().empty()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.TypedWildcard)
}

inline void TypedWildcard::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TypedWildcard::~TypedWildcard() {
  // @@protoc_insertion_point(destructor:openfga.v1.TypedWildcard)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TypedWildcard::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.type_.Destroy();
}

void TypedWildcard::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TypedWildcard::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.TypedWildcard)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.type_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TypedWildcard::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type = 1 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.TypedWildcard.type"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TypedWildcard::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.TypedWildcard)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type = 1 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.TypedWildcard.type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.TypedWildcard)
  return target;
}

size_t TypedWildcard::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.TypedWildcard)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string type = 1 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TypedWildcard::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TypedWildcard::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TypedWildcard::GetClassData() const { return &_class_data_; }


void TypedWildcard::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TypedWildcard*>(&to_msg);
  auto& from = static_cast<const TypedWildcard&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.TypedWildcard)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_type().empty()) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TypedWildcard::CopyFrom(const TypedWildcard& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.TypedWildcard)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TypedWildcard::IsInitialized() const {
  return true;
}

void TypedWildcard::InternalSwap(TypedWildcard* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata TypedWildcard::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_2eproto[5]);
}

// ===================================================================

class TupleKey::_Internal {
 public:
  static const ::openfga::v1::RelationshipCondition& condition(const TupleKey* msg);
};

const ::openfga::v1::RelationshipCondition&
TupleKey::_Internal::condition(const TupleKey* msg) {
  return *msg->_impl_.condition_;
}
TupleKey::TupleKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.TupleKey)
}
TupleKey::TupleKey(const TupleKey& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TupleKey* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.user_){}
    , decltype(_impl_.relation_){}
    , decltype(_impl_.object_){}
    , decltype(_impl_.condition_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user().empty()) {
    _this->_impl_.user_.Set(from._internal_user(), 
      _this->GetArenaForAllocation());
  }
  _impl_.relation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_relation().empty()) {
    _this->_impl_.relation_.Set(from._internal_relation(), 
      _this->GetArenaForAllocation());
  }
  _impl_.object_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.object_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_object().empty()) {
    _this->_impl_.object_.Set(from._internal_object(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_condition()) {
    _this->_impl_.condition_ = new ::openfga::v1::RelationshipCondition(*from._impl_.condition_);
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.TupleKey)
}

inline void TupleKey::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.user_){}
    , decltype(_impl_.relation_){}
    , decltype(_impl_.object_){}
    , decltype(_impl_.condition_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.relation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.object_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.object_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TupleKey::~TupleKey() {
  // @@protoc_insertion_point(destructor:openfga.v1.TupleKey)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TupleKey::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_.Destroy();
  _impl_.relation_.Destroy();
  _impl_.object_.Destroy();
  if (this != internal_default_instance()) delete _impl_.condition_;
}

void TupleKey::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TupleKey::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.TupleKey)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_.ClearToEmpty();
  _impl_.relation_.ClearToEmpty();
  _impl_.object_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.condition_ != nullptr) {
    delete _impl_.condition_;
  }
  _impl_.condition_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TupleKey::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string user = 1 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.TupleKey.user"));
        } else
          goto handle_unusual;
        continue;
      // string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_relation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.TupleKey.relation"));
        } else
          goto handle_unusual;
        continue;
      // string object = 3 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_object();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.TupleKey.object"));
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.RelationshipCondition condition = 4 [json_name = "condition"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_condition(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TupleKey::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.TupleKey)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string user = 1 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_user().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user().data(), static_cast<int>(this->_internal_user().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.TupleKey.user");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user(), target);
  }

  // string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_relation().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_relation().data(), static_cast<int>(this->_internal_relation().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.TupleKey.relation");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_relation(), target);
  }

  // string object = 3 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_object().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_object().data(), static_cast<int>(this->_internal_object().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.TupleKey.object");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_object(), target);
  }

  // .openfga.v1.RelationshipCondition condition = 4 [json_name = "condition"];
  if (this->_internal_has_condition()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::condition(this),
        _Internal::condition(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.TupleKey)
  return target;
}

size_t TupleKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.TupleKey)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string user = 1 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_user().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user());
  }

  // string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_relation().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_relation());
  }

  // string object = 3 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_object().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_object());
  }

  // .openfga.v1.RelationshipCondition condition = 4 [json_name = "condition"];
  if (this->_internal_has_condition()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.condition_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TupleKey::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TupleKey::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TupleKey::GetClassData() const { return &_class_data_; }


void TupleKey::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TupleKey*>(&to_msg);
  auto& from = static_cast<const TupleKey&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.TupleKey)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_user().empty()) {
    _this->_internal_set_user(from._internal_user());
  }
  if (!from._internal_relation().empty()) {
    _this->_internal_set_relation(from._internal_relation());
  }
  if (!from._internal_object().empty()) {
    _this->_internal_set_object(from._internal_object());
  }
  if (from._internal_has_condition()) {
    _this->_internal_mutable_condition()->::openfga::v1::RelationshipCondition::MergeFrom(
        from._internal_condition());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TupleKey::CopyFrom(const TupleKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.TupleKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TupleKey::IsInitialized() const {
  return true;
}

void TupleKey::InternalSwap(TupleKey* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_, lhs_arena,
      &other->_impl_.user_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.relation_, lhs_arena,
      &other->_impl_.relation_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.object_, lhs_arena,
      &other->_impl_.object_, rhs_arena
  );
  swap(_impl_.condition_, other->_impl_.condition_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TupleKey::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_2eproto[6]);
}

// ===================================================================

class Tuple::_Internal {
 public:
  static const ::openfga::v1::TupleKey& key(const Tuple* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp(const Tuple* msg);
};

const ::openfga::v1::TupleKey&
Tuple::_Internal::key(const Tuple* msg) {
  return *msg->_impl_.key_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
Tuple::_Internal::timestamp(const Tuple* msg) {
  return *msg->_impl_.timestamp_;
}
void Tuple::clear_timestamp() {
  if (GetArenaForAllocation() == nullptr && _impl_.timestamp_ != nullptr) {
    delete _impl_.timestamp_;
  }
  _impl_.timestamp_ = nullptr;
}
Tuple::Tuple(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.Tuple)
}
Tuple::Tuple(const Tuple& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Tuple* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){nullptr}
    , decltype(_impl_.timestamp_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_key()) {
    _this->_impl_.key_ = new ::openfga::v1::TupleKey(*from._impl_.key_);
  }
  if (from._internal_has_timestamp()) {
    _this->_impl_.timestamp_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.timestamp_);
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.Tuple)
}

inline void Tuple::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){nullptr}
    , decltype(_impl_.timestamp_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Tuple::~Tuple() {
  // @@protoc_insertion_point(destructor:openfga.v1.Tuple)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Tuple::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.key_;
  if (this != internal_default_instance()) delete _impl_.timestamp_;
}

void Tuple::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Tuple::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.Tuple)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.key_ != nullptr) {
    delete _impl_.key_;
  }
  _impl_.key_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.timestamp_ != nullptr) {
    delete _impl_.timestamp_;
  }
  _impl_.timestamp_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Tuple::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .openfga.v1.TupleKey key = 1 [json_name = "key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp timestamp = 2 [json_name = "timestamp", (.google.api.field_behavior) = REQUIRED];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Tuple::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.Tuple)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .openfga.v1.TupleKey key = 1 [json_name = "key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (this->_internal_has_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::key(this),
        _Internal::key(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Timestamp timestamp = 2 [json_name = "timestamp", (.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_timestamp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::timestamp(this),
        _Internal::timestamp(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.Tuple)
  return target;
}

size_t Tuple::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.Tuple)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .openfga.v1.TupleKey key = 1 [json_name = "key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (this->_internal_has_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.key_);
  }

  // .google.protobuf.Timestamp timestamp = 2 [json_name = "timestamp", (.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_timestamp()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.timestamp_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Tuple::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Tuple::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Tuple::GetClassData() const { return &_class_data_; }


void Tuple::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Tuple*>(&to_msg);
  auto& from = static_cast<const Tuple&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.Tuple)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_key()) {
    _this->_internal_mutable_key()->::openfga::v1::TupleKey::MergeFrom(
        from._internal_key());
  }
  if (from._internal_has_timestamp()) {
    _this->_internal_mutable_timestamp()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_timestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Tuple::CopyFrom(const Tuple& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.Tuple)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Tuple::IsInitialized() const {
  return true;
}

void Tuple::InternalSwap(Tuple* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Tuple, _impl_.timestamp_)
      + sizeof(Tuple::_impl_.timestamp_)
      - PROTOBUF_FIELD_OFFSET(Tuple, _impl_.key_)>(
          reinterpret_cast<char*>(&_impl_.key_),
          reinterpret_cast<char*>(&other->_impl_.key_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Tuple::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_2eproto[7]);
}

// ===================================================================

class TupleKeys::_Internal {
 public:
};

TupleKeys::TupleKeys(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.TupleKeys)
}
TupleKeys::TupleKeys(const TupleKeys& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TupleKeys* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tuple_keys_){from._impl_.tuple_keys_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:openfga.v1.TupleKeys)
}

inline void TupleKeys::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tuple_keys_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TupleKeys::~TupleKeys() {
  // @@protoc_insertion_point(destructor:openfga.v1.TupleKeys)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TupleKeys::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tuple_keys_.~RepeatedPtrField();
}

void TupleKeys::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TupleKeys::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.TupleKeys)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tuple_keys_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TupleKeys::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .openfga.v1.TupleKey tuple_keys = 1 [json_name = "tuple_keys", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tuple_keys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TupleKeys::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.TupleKeys)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .openfga.v1.TupleKey tuple_keys = 1 [json_name = "tuple_keys", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tuple_keys_size()); i < n; i++) {
    const auto& repfield = this->_internal_tuple_keys(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.TupleKeys)
  return target;
}

size_t TupleKeys::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.TupleKeys)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .openfga.v1.TupleKey tuple_keys = 1 [json_name = "tuple_keys", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  total_size += 1UL * this->_internal_tuple_keys_size();
  for (const auto& msg : this->_impl_.tuple_keys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TupleKeys::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TupleKeys::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TupleKeys::GetClassData() const { return &_class_data_; }


void TupleKeys::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TupleKeys*>(&to_msg);
  auto& from = static_cast<const TupleKeys&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.TupleKeys)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tuple_keys_.MergeFrom(from._impl_.tuple_keys_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TupleKeys::CopyFrom(const TupleKeys& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.TupleKeys)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TupleKeys::IsInitialized() const {
  return true;
}

void TupleKeys::InternalSwap(TupleKeys* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tuple_keys_.InternalSwap(&other->_impl_.tuple_keys_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TupleKeys::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_2eproto[8]);
}

// ===================================================================

class ContextualTupleKeys::_Internal {
 public:
};

ContextualTupleKeys::ContextualTupleKeys(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.ContextualTupleKeys)
}
ContextualTupleKeys::ContextualTupleKeys(const ContextualTupleKeys& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContextualTupleKeys* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tuple_keys_){from._impl_.tuple_keys_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:openfga.v1.ContextualTupleKeys)
}

inline void ContextualTupleKeys::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tuple_keys_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ContextualTupleKeys::~ContextualTupleKeys() {
  // @@protoc_insertion_point(destructor:openfga.v1.ContextualTupleKeys)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContextualTupleKeys::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tuple_keys_.~RepeatedPtrField();
}

void ContextualTupleKeys::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContextualTupleKeys::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.ContextualTupleKeys)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tuple_keys_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContextualTupleKeys::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .openfga.v1.TupleKey tuple_keys = 1 [json_name = "tuple_keys", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tuple_keys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContextualTupleKeys::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.ContextualTupleKeys)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .openfga.v1.TupleKey tuple_keys = 1 [json_name = "tuple_keys", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tuple_keys_size()); i < n; i++) {
    const auto& repfield = this->_internal_tuple_keys(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.ContextualTupleKeys)
  return target;
}

size_t ContextualTupleKeys::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.ContextualTupleKeys)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .openfga.v1.TupleKey tuple_keys = 1 [json_name = "tuple_keys", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  total_size += 1UL * this->_internal_tuple_keys_size();
  for (const auto& msg : this->_impl_.tuple_keys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContextualTupleKeys::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContextualTupleKeys::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContextualTupleKeys::GetClassData() const { return &_class_data_; }


void ContextualTupleKeys::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContextualTupleKeys*>(&to_msg);
  auto& from = static_cast<const ContextualTupleKeys&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.ContextualTupleKeys)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tuple_keys_.MergeFrom(from._impl_.tuple_keys_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContextualTupleKeys::CopyFrom(const ContextualTupleKeys& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.ContextualTupleKeys)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContextualTupleKeys::IsInitialized() const {
  return true;
}

void ContextualTupleKeys::InternalSwap(ContextualTupleKeys* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tuple_keys_.InternalSwap(&other->_impl_.tuple_keys_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ContextualTupleKeys::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_2eproto[9]);
}

// ===================================================================

class UsersetTree_Leaf::_Internal {
 public:
  static const ::openfga::v1::UsersetTree_Users& users(const UsersetTree_Leaf* msg);
  static const ::openfga::v1::UsersetTree_Computed& computed(const UsersetTree_Leaf* msg);
  static const ::openfga::v1::UsersetTree_TupleToUserset& tuple_to_userset(const UsersetTree_Leaf* msg);
};

const ::openfga::v1::UsersetTree_Users&
UsersetTree_Leaf::_Internal::users(const UsersetTree_Leaf* msg) {
  return *msg->_impl_.value_.users_;
}
const ::openfga::v1::UsersetTree_Computed&
UsersetTree_Leaf::_Internal::computed(const UsersetTree_Leaf* msg) {
  return *msg->_impl_.value_.computed_;
}
const ::openfga::v1::UsersetTree_TupleToUserset&
UsersetTree_Leaf::_Internal::tuple_to_userset(const UsersetTree_Leaf* msg) {
  return *msg->_impl_.value_.tuple_to_userset_;
}
void UsersetTree_Leaf::set_allocated_users(::openfga::v1::UsersetTree_Users* users) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (users) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(users);
    if (message_arena != submessage_arena) {
      users = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, users, submessage_arena);
    }
    set_has_users();
    _impl_.value_.users_ = users;
  }
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.UsersetTree.Leaf.users)
}
void UsersetTree_Leaf::set_allocated_computed(::openfga::v1::UsersetTree_Computed* computed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (computed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(computed);
    if (message_arena != submessage_arena) {
      computed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, computed, submessage_arena);
    }
    set_has_computed();
    _impl_.value_.computed_ = computed;
  }
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.UsersetTree.Leaf.computed)
}
void UsersetTree_Leaf::set_allocated_tuple_to_userset(::openfga::v1::UsersetTree_TupleToUserset* tuple_to_userset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (tuple_to_userset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tuple_to_userset);
    if (message_arena != submessage_arena) {
      tuple_to_userset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tuple_to_userset, submessage_arena);
    }
    set_has_tuple_to_userset();
    _impl_.value_.tuple_to_userset_ = tuple_to_userset;
  }
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.UsersetTree.Leaf.tuple_to_userset)
}
UsersetTree_Leaf::UsersetTree_Leaf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.UsersetTree.Leaf)
}
UsersetTree_Leaf::UsersetTree_Leaf(const UsersetTree_Leaf& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UsersetTree_Leaf* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_value();
  switch (from.value_case()) {
    case kUsers: {
      _this->_internal_mutable_users()->::openfga::v1::UsersetTree_Users::MergeFrom(
          from._internal_users());
      break;
    }
    case kComputed: {
      _this->_internal_mutable_computed()->::openfga::v1::UsersetTree_Computed::MergeFrom(
          from._internal_computed());
      break;
    }
    case kTupleToUserset: {
      _this->_internal_mutable_tuple_to_userset()->::openfga::v1::UsersetTree_TupleToUserset::MergeFrom(
          from._internal_tuple_to_userset());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.UsersetTree.Leaf)
}

inline void UsersetTree_Leaf::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_value();
}

UsersetTree_Leaf::~UsersetTree_Leaf() {
  // @@protoc_insertion_point(destructor:openfga.v1.UsersetTree.Leaf)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UsersetTree_Leaf::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_value()) {
    clear_value();
  }
}

void UsersetTree_Leaf::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UsersetTree_Leaf::clear_value() {
// @@protoc_insertion_point(one_of_clear_start:openfga.v1.UsersetTree.Leaf)
  switch (value_case()) {
    case kUsers: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.value_.users_;
      }
      break;
    }
    case kComputed: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.value_.computed_;
      }
      break;
    }
    case kTupleToUserset: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.value_.tuple_to_userset_;
      }
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}


void UsersetTree_Leaf::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.UsersetTree.Leaf)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_value();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UsersetTree_Leaf::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .openfga.v1.UsersetTree.Users users = 1 [json_name = "users"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_users(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.UsersetTree.Computed computed = 2 [json_name = "computed"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_computed(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.UsersetTree.TupleToUserset tuple_to_userset = 3 [json_name = "tupleToUserset"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_tuple_to_userset(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UsersetTree_Leaf::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.UsersetTree.Leaf)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .openfga.v1.UsersetTree.Users users = 1 [json_name = "users"];
  if (_internal_has_users()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::users(this),
        _Internal::users(this).GetCachedSize(), target, stream);
  }

  // .openfga.v1.UsersetTree.Computed computed = 2 [json_name = "computed"];
  if (_internal_has_computed()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::computed(this),
        _Internal::computed(this).GetCachedSize(), target, stream);
  }

  // .openfga.v1.UsersetTree.TupleToUserset tuple_to_userset = 3 [json_name = "tupleToUserset"];
  if (_internal_has_tuple_to_userset()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::tuple_to_userset(this),
        _Internal::tuple_to_userset(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.UsersetTree.Leaf)
  return target;
}

size_t UsersetTree_Leaf::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.UsersetTree.Leaf)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (value_case()) {
    // .openfga.v1.UsersetTree.Users users = 1 [json_name = "users"];
    case kUsers: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.value_.users_);
      break;
    }
    // .openfga.v1.UsersetTree.Computed computed = 2 [json_name = "computed"];
    case kComputed: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.value_.computed_);
      break;
    }
    // .openfga.v1.UsersetTree.TupleToUserset tuple_to_userset = 3 [json_name = "tupleToUserset"];
    case kTupleToUserset: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.value_.tuple_to_userset_);
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UsersetTree_Leaf::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UsersetTree_Leaf::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UsersetTree_Leaf::GetClassData() const { return &_class_data_; }


void UsersetTree_Leaf::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UsersetTree_Leaf*>(&to_msg);
  auto& from = static_cast<const UsersetTree_Leaf&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.UsersetTree.Leaf)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.value_case()) {
    case kUsers: {
      _this->_internal_mutable_users()->::openfga::v1::UsersetTree_Users::MergeFrom(
          from._internal_users());
      break;
    }
    case kComputed: {
      _this->_internal_mutable_computed()->::openfga::v1::UsersetTree_Computed::MergeFrom(
          from._internal_computed());
      break;
    }
    case kTupleToUserset: {
      _this->_internal_mutable_tuple_to_userset()->::openfga::v1::UsersetTree_TupleToUserset::MergeFrom(
          from._internal_tuple_to_userset());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UsersetTree_Leaf::CopyFrom(const UsersetTree_Leaf& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.UsersetTree.Leaf)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsersetTree_Leaf::IsInitialized() const {
  return true;
}

void UsersetTree_Leaf::InternalSwap(UsersetTree_Leaf* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsersetTree_Leaf::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_2eproto[10]);
}

// ===================================================================

class UsersetTree_Nodes::_Internal {
 public:
};

UsersetTree_Nodes::UsersetTree_Nodes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.UsersetTree.Nodes)
}
UsersetTree_Nodes::UsersetTree_Nodes(const UsersetTree_Nodes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UsersetTree_Nodes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nodes_){from._impl_.nodes_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:openfga.v1.UsersetTree.Nodes)
}

inline void UsersetTree_Nodes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nodes_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UsersetTree_Nodes::~UsersetTree_Nodes() {
  // @@protoc_insertion_point(destructor:openfga.v1.UsersetTree.Nodes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UsersetTree_Nodes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nodes_.~RepeatedPtrField();
}

void UsersetTree_Nodes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UsersetTree_Nodes::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.UsersetTree.Nodes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nodes_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UsersetTree_Nodes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .openfga.v1.UsersetTree.Node nodes = 1 [json_name = "nodes", (.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UsersetTree_Nodes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.UsersetTree.Nodes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .openfga.v1.UsersetTree.Node nodes = 1 [json_name = "nodes", (.google.api.field_behavior) = REQUIRED];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nodes_size()); i < n; i++) {
    const auto& repfield = this->_internal_nodes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.UsersetTree.Nodes)
  return target;
}

size_t UsersetTree_Nodes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.UsersetTree.Nodes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .openfga.v1.UsersetTree.Node nodes = 1 [json_name = "nodes", (.google.api.field_behavior) = REQUIRED];
  total_size += 1UL * this->_internal_nodes_size();
  for (const auto& msg : this->_impl_.nodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UsersetTree_Nodes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UsersetTree_Nodes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UsersetTree_Nodes::GetClassData() const { return &_class_data_; }


void UsersetTree_Nodes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UsersetTree_Nodes*>(&to_msg);
  auto& from = static_cast<const UsersetTree_Nodes&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.UsersetTree.Nodes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nodes_.MergeFrom(from._impl_.nodes_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UsersetTree_Nodes::CopyFrom(const UsersetTree_Nodes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.UsersetTree.Nodes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsersetTree_Nodes::IsInitialized() const {
  return true;
}

void UsersetTree_Nodes::InternalSwap(UsersetTree_Nodes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.nodes_.InternalSwap(&other->_impl_.nodes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsersetTree_Nodes::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_2eproto[11]);
}

// ===================================================================

class UsersetTree_Users::_Internal {
 public:
};

UsersetTree_Users::UsersetTree_Users(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.UsersetTree.Users)
}
UsersetTree_Users::UsersetTree_Users(const UsersetTree_Users& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UsersetTree_Users* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.users_){from._impl_.users_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:openfga.v1.UsersetTree.Users)
}

inline void UsersetTree_Users::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.users_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UsersetTree_Users::~UsersetTree_Users() {
  // @@protoc_insertion_point(destructor:openfga.v1.UsersetTree.Users)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UsersetTree_Users::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.users_.~RepeatedPtrField();
}

void UsersetTree_Users::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UsersetTree_Users::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.UsersetTree.Users)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.users_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UsersetTree_Users::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string users = 1 [json_name = "users", (.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_users();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.UsersetTree.Users.users"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UsersetTree_Users::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.UsersetTree.Users)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string users = 1 [json_name = "users", (.google.api.field_behavior) = REQUIRED];
  for (int i = 0, n = this->_internal_users_size(); i < n; i++) {
    const auto& s = this->_internal_users(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.UsersetTree.Users.users");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.UsersetTree.Users)
  return target;
}

size_t UsersetTree_Users::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.UsersetTree.Users)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string users = 1 [json_name = "users", (.google.api.field_behavior) = REQUIRED];
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.users_.size());
  for (int i = 0, n = _impl_.users_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.users_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UsersetTree_Users::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UsersetTree_Users::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UsersetTree_Users::GetClassData() const { return &_class_data_; }


void UsersetTree_Users::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UsersetTree_Users*>(&to_msg);
  auto& from = static_cast<const UsersetTree_Users&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.UsersetTree.Users)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.users_.MergeFrom(from._impl_.users_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UsersetTree_Users::CopyFrom(const UsersetTree_Users& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.UsersetTree.Users)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsersetTree_Users::IsInitialized() const {
  return true;
}

void UsersetTree_Users::InternalSwap(UsersetTree_Users* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.users_.InternalSwap(&other->_impl_.users_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsersetTree_Users::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_2eproto[12]);
}

// ===================================================================

class UsersetTree_Computed::_Internal {
 public:
};

UsersetTree_Computed::UsersetTree_Computed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.UsersetTree.Computed)
}
UsersetTree_Computed::UsersetTree_Computed(const UsersetTree_Computed& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UsersetTree_Computed* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.userset_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.userset_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userset_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_userset().empty()) {
    _this->_impl_.userset_.Set(from._internal_userset(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.UsersetTree.Computed)
}

inline void UsersetTree_Computed::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.userset_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.userset_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userset_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UsersetTree_Computed::~UsersetTree_Computed() {
  // @@protoc_insertion_point(destructor:openfga.v1.UsersetTree.Computed)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UsersetTree_Computed::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.userset_.Destroy();
}

void UsersetTree_Computed::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UsersetTree_Computed::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.UsersetTree.Computed)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.userset_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UsersetTree_Computed::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string userset = 1 [json_name = "userset", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_userset();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.UsersetTree.Computed.userset"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UsersetTree_Computed::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.UsersetTree.Computed)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string userset = 1 [json_name = "userset", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (!this->_internal_userset().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_userset().data(), static_cast<int>(this->_internal_userset().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.UsersetTree.Computed.userset");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_userset(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.UsersetTree.Computed)
  return target;
}

size_t UsersetTree_Computed::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.UsersetTree.Computed)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string userset = 1 [json_name = "userset", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (!this->_internal_userset().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_userset());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UsersetTree_Computed::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UsersetTree_Computed::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UsersetTree_Computed::GetClassData() const { return &_class_data_; }


void UsersetTree_Computed::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UsersetTree_Computed*>(&to_msg);
  auto& from = static_cast<const UsersetTree_Computed&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.UsersetTree.Computed)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_userset().empty()) {
    _this->_internal_set_userset(from._internal_userset());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UsersetTree_Computed::CopyFrom(const UsersetTree_Computed& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.UsersetTree.Computed)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsersetTree_Computed::IsInitialized() const {
  return true;
}

void UsersetTree_Computed::InternalSwap(UsersetTree_Computed* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.userset_, lhs_arena,
      &other->_impl_.userset_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata UsersetTree_Computed::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_2eproto[13]);
}

// ===================================================================

class UsersetTree_TupleToUserset::_Internal {
 public:
};

UsersetTree_TupleToUserset::UsersetTree_TupleToUserset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.UsersetTree.TupleToUserset)
}
UsersetTree_TupleToUserset::UsersetTree_TupleToUserset(const UsersetTree_TupleToUserset& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UsersetTree_TupleToUserset* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.computed_){from._impl_.computed_}
    , decltype(_impl_.tupleset_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.tupleset_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tupleset_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_tupleset().empty()) {
    _this->_impl_.tupleset_.Set(from._internal_tupleset(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.UsersetTree.TupleToUserset)
}

inline void UsersetTree_TupleToUserset::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.computed_){arena}
    , decltype(_impl_.tupleset_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.tupleset_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tupleset_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UsersetTree_TupleToUserset::~UsersetTree_TupleToUserset() {
  // @@protoc_insertion_point(destructor:openfga.v1.UsersetTree.TupleToUserset)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UsersetTree_TupleToUserset::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.computed_.~RepeatedPtrField();
  _impl_.tupleset_.Destroy();
}

void UsersetTree_TupleToUserset::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UsersetTree_TupleToUserset::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.UsersetTree.TupleToUserset)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.computed_.Clear();
  _impl_.tupleset_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UsersetTree_TupleToUserset::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string tupleset = 1 [json_name = "tupleset", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_tupleset();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.UsersetTree.TupleToUserset.tupleset"));
        } else
          goto handle_unusual;
        continue;
      // repeated .openfga.v1.UsersetTree.Computed computed = 2 [json_name = "computed", (.google.api.field_behavior) = REQUIRED];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_computed(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UsersetTree_TupleToUserset::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.UsersetTree.TupleToUserset)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string tupleset = 1 [json_name = "tupleset", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (!this->_internal_tupleset().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_tupleset().data(), static_cast<int>(this->_internal_tupleset().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.UsersetTree.TupleToUserset.tupleset");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_tupleset(), target);
  }

  // repeated .openfga.v1.UsersetTree.Computed computed = 2 [json_name = "computed", (.google.api.field_behavior) = REQUIRED];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_computed_size()); i < n; i++) {
    const auto& repfield = this->_internal_computed(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.UsersetTree.TupleToUserset)
  return target;
}

size_t UsersetTree_TupleToUserset::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.UsersetTree.TupleToUserset)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .openfga.v1.UsersetTree.Computed computed = 2 [json_name = "computed", (.google.api.field_behavior) = REQUIRED];
  total_size += 1UL * this->_internal_computed_size();
  for (const auto& msg : this->_impl_.computed_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string tupleset = 1 [json_name = "tupleset", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (!this->_internal_tupleset().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_tupleset());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UsersetTree_TupleToUserset::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UsersetTree_TupleToUserset::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UsersetTree_TupleToUserset::GetClassData() const { return &_class_data_; }


void UsersetTree_TupleToUserset::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UsersetTree_TupleToUserset*>(&to_msg);
  auto& from = static_cast<const UsersetTree_TupleToUserset&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.UsersetTree.TupleToUserset)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.computed_.MergeFrom(from._impl_.computed_);
  if (!from._internal_tupleset().empty()) {
    _this->_internal_set_tupleset(from._internal_tupleset());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UsersetTree_TupleToUserset::CopyFrom(const UsersetTree_TupleToUserset& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.UsersetTree.TupleToUserset)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsersetTree_TupleToUserset::IsInitialized() const {
  return true;
}

void UsersetTree_TupleToUserset::InternalSwap(UsersetTree_TupleToUserset* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.computed_.InternalSwap(&other->_impl_.computed_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tupleset_, lhs_arena,
      &other->_impl_.tupleset_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata UsersetTree_TupleToUserset::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_2eproto[14]);
}

// ===================================================================

class UsersetTree_Difference::_Internal {
 public:
  static const ::openfga::v1::UsersetTree_Node& base(const UsersetTree_Difference* msg);
  static const ::openfga::v1::UsersetTree_Node& subtract(const UsersetTree_Difference* msg);
};

const ::openfga::v1::UsersetTree_Node&
UsersetTree_Difference::_Internal::base(const UsersetTree_Difference* msg) {
  return *msg->_impl_.base_;
}
const ::openfga::v1::UsersetTree_Node&
UsersetTree_Difference::_Internal::subtract(const UsersetTree_Difference* msg) {
  return *msg->_impl_.subtract_;
}
UsersetTree_Difference::UsersetTree_Difference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.UsersetTree.Difference)
}
UsersetTree_Difference::UsersetTree_Difference(const UsersetTree_Difference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UsersetTree_Difference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.base_){nullptr}
    , decltype(_impl_.subtract_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::openfga::v1::UsersetTree_Node(*from._impl_.base_);
  }
  if (from._internal_has_subtract()) {
    _this->_impl_.subtract_ = new ::openfga::v1::UsersetTree_Node(*from._impl_.subtract_);
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.UsersetTree.Difference)
}

inline void UsersetTree_Difference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.base_){nullptr}
    , decltype(_impl_.subtract_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UsersetTree_Difference::~UsersetTree_Difference() {
  // @@protoc_insertion_point(destructor:openfga.v1.UsersetTree.Difference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UsersetTree_Difference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.base_;
  if (this != internal_default_instance()) delete _impl_.subtract_;
}

void UsersetTree_Difference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UsersetTree_Difference::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.UsersetTree.Difference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.subtract_ != nullptr) {
    delete _impl_.subtract_;
  }
  _impl_.subtract_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UsersetTree_Difference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .openfga.v1.UsersetTree.Node base = 1 [json_name = "base", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.UsersetTree.Node subtract = 2 [json_name = "subtract", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_subtract(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UsersetTree_Difference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.UsersetTree.Difference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .openfga.v1.UsersetTree.Node base = 1 [json_name = "base", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (this->_internal_has_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // .openfga.v1.UsersetTree.Node subtract = 2 [json_name = "subtract", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (this->_internal_has_subtract()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::subtract(this),
        _Internal::subtract(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.UsersetTree.Difference)
  return target;
}

size_t UsersetTree_Difference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.UsersetTree.Difference)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .openfga.v1.UsersetTree.Node base = 1 [json_name = "base", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (this->_internal_has_base()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.base_);
  }

  // .openfga.v1.UsersetTree.Node subtract = 2 [json_name = "subtract", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (this->_internal_has_subtract()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.subtract_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UsersetTree_Difference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UsersetTree_Difference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UsersetTree_Difference::GetClassData() const { return &_class_data_; }


void UsersetTree_Difference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UsersetTree_Difference*>(&to_msg);
  auto& from = static_cast<const UsersetTree_Difference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.UsersetTree.Difference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_base()) {
    _this->_internal_mutable_base()->::openfga::v1::UsersetTree_Node::MergeFrom(
        from._internal_base());
  }
  if (from._internal_has_subtract()) {
    _this->_internal_mutable_subtract()->::openfga::v1::UsersetTree_Node::MergeFrom(
        from._internal_subtract());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UsersetTree_Difference::CopyFrom(const UsersetTree_Difference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.UsersetTree.Difference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsersetTree_Difference::IsInitialized() const {
  return true;
}

void UsersetTree_Difference::InternalSwap(UsersetTree_Difference* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UsersetTree_Difference, _impl_.subtract_)
      + sizeof(UsersetTree_Difference::_impl_.subtract_)
      - PROTOBUF_FIELD_OFFSET(UsersetTree_Difference, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UsersetTree_Difference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_2eproto[15]);
}

// ===================================================================

class UsersetTree_Node::_Internal {
 public:
  static const ::openfga::v1::UsersetTree_Leaf& leaf(const UsersetTree_Node* msg);
  static const ::openfga::v1::UsersetTree_Difference& difference(const UsersetTree_Node* msg);
  static const ::openfga::v1::UsersetTree_Nodes& union_(const UsersetTree_Node* msg);
  static const ::openfga::v1::UsersetTree_Nodes& intersection(const UsersetTree_Node* msg);
};

const ::openfga::v1::UsersetTree_Leaf&
UsersetTree_Node::_Internal::leaf(const UsersetTree_Node* msg) {
  return *msg->_impl_.value_.leaf_;
}
const ::openfga::v1::UsersetTree_Difference&
UsersetTree_Node::_Internal::difference(const UsersetTree_Node* msg) {
  return *msg->_impl_.value_.difference_;
}
const ::openfga::v1::UsersetTree_Nodes&
UsersetTree_Node::_Internal::union_(const UsersetTree_Node* msg) {
  return *msg->_impl_.value_.union__;
}
const ::openfga::v1::UsersetTree_Nodes&
UsersetTree_Node::_Internal::intersection(const UsersetTree_Node* msg) {
  return *msg->_impl_.value_.intersection_;
}
void UsersetTree_Node::set_allocated_leaf(::openfga::v1::UsersetTree_Leaf* leaf) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (leaf) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(leaf);
    if (message_arena != submessage_arena) {
      leaf = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leaf, submessage_arena);
    }
    set_has_leaf();
    _impl_.value_.leaf_ = leaf;
  }
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.UsersetTree.Node.leaf)
}
void UsersetTree_Node::set_allocated_difference(::openfga::v1::UsersetTree_Difference* difference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (difference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(difference);
    if (message_arena != submessage_arena) {
      difference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, difference, submessage_arena);
    }
    set_has_difference();
    _impl_.value_.difference_ = difference;
  }
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.UsersetTree.Node.difference)
}
void UsersetTree_Node::set_allocated_union_(::openfga::v1::UsersetTree_Nodes* union_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (union_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(union_);
    if (message_arena != submessage_arena) {
      union_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, union_, submessage_arena);
    }
    set_has_union_();
    _impl_.value_.union__ = union_;
  }
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.UsersetTree.Node.union)
}
void UsersetTree_Node::set_allocated_intersection(::openfga::v1::UsersetTree_Nodes* intersection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (intersection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(intersection);
    if (message_arena != submessage_arena) {
      intersection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, intersection, submessage_arena);
    }
    set_has_intersection();
    _impl_.value_.intersection_ = intersection;
  }
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.UsersetTree.Node.intersection)
}
UsersetTree_Node::UsersetTree_Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.UsersetTree.Node)
}
UsersetTree_Node::UsersetTree_Node(const UsersetTree_Node& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UsersetTree_Node* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  clear_has_value();
  switch (from.value_case()) {
    case kLeaf: {
      _this->_internal_mutable_leaf()->::openfga::v1::UsersetTree_Leaf::MergeFrom(
          from._internal_leaf());
      break;
    }
    case kDifference: {
      _this->_internal_mutable_difference()->::openfga::v1::UsersetTree_Difference::MergeFrom(
          from._internal_difference());
      break;
    }
    case kUnion: {
      _this->_internal_mutable_union_()->::openfga::v1::UsersetTree_Nodes::MergeFrom(
          from._internal_union_());
      break;
    }
    case kIntersection: {
      _this->_internal_mutable_intersection()->::openfga::v1::UsersetTree_Nodes::MergeFrom(
          from._internal_intersection());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.UsersetTree.Node)
}

inline void UsersetTree_Node::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_value();
}

UsersetTree_Node::~UsersetTree_Node() {
  // @@protoc_insertion_point(destructor:openfga.v1.UsersetTree.Node)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UsersetTree_Node::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (has_value()) {
    clear_value();
  }
}

void UsersetTree_Node::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UsersetTree_Node::clear_value() {
// @@protoc_insertion_point(one_of_clear_start:openfga.v1.UsersetTree.Node)
  switch (value_case()) {
    case kLeaf: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.value_.leaf_;
      }
      break;
    }
    case kDifference: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.value_.difference_;
      }
      break;
    }
    case kUnion: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.value_.union__;
      }
      break;
    }
    case kIntersection: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.value_.intersection_;
      }
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}


void UsersetTree_Node::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.UsersetTree.Node)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  clear_value();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UsersetTree_Node::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [json_name = "name", (.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.UsersetTree.Node.name"));
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.UsersetTree.Leaf leaf = 2 [json_name = "leaf"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_leaf(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.UsersetTree.Difference difference = 5 [json_name = "difference"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_difference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.UsersetTree.Nodes union = 6 [json_name = "union"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_union_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.UsersetTree.Nodes intersection = 7 [json_name = "intersection"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_intersection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UsersetTree_Node::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.UsersetTree.Node)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [json_name = "name", (.google.api.field_behavior) = REQUIRED];
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.UsersetTree.Node.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .openfga.v1.UsersetTree.Leaf leaf = 2 [json_name = "leaf"];
  if (_internal_has_leaf()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::leaf(this),
        _Internal::leaf(this).GetCachedSize(), target, stream);
  }

  // .openfga.v1.UsersetTree.Difference difference = 5 [json_name = "difference"];
  if (_internal_has_difference()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::difference(this),
        _Internal::difference(this).GetCachedSize(), target, stream);
  }

  // .openfga.v1.UsersetTree.Nodes union = 6 [json_name = "union"];
  if (_internal_has_union_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::union_(this),
        _Internal::union_(this).GetCachedSize(), target, stream);
  }

  // .openfga.v1.UsersetTree.Nodes intersection = 7 [json_name = "intersection"];
  if (_internal_has_intersection()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::intersection(this),
        _Internal::intersection(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.UsersetTree.Node)
  return target;
}

size_t UsersetTree_Node::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.UsersetTree.Node)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [json_name = "name", (.google.api.field_behavior) = REQUIRED];
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  switch (value_case()) {
    // .openfga.v1.UsersetTree.Leaf leaf = 2 [json_name = "leaf"];
    case kLeaf: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.value_.leaf_);
      break;
    }
    // .openfga.v1.UsersetTree.Difference difference = 5 [json_name = "difference"];
    case kDifference: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.value_.difference_);
      break;
    }
    // .openfga.v1.UsersetTree.Nodes union = 6 [json_name = "union"];
    case kUnion: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.value_.union__);
      break;
    }
    // .openfga.v1.UsersetTree.Nodes intersection = 7 [json_name = "intersection"];
    case kIntersection: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.value_.intersection_);
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UsersetTree_Node::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UsersetTree_Node::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UsersetTree_Node::GetClassData() const { return &_class_data_; }


void UsersetTree_Node::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UsersetTree_Node*>(&to_msg);
  auto& from = static_cast<const UsersetTree_Node&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.UsersetTree.Node)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  switch (from.value_case()) {
    case kLeaf: {
      _this->_internal_mutable_leaf()->::openfga::v1::UsersetTree_Leaf::MergeFrom(
          from._internal_leaf());
      break;
    }
    case kDifference: {
      _this->_internal_mutable_difference()->::openfga::v1::UsersetTree_Difference::MergeFrom(
          from._internal_difference());
      break;
    }
    case kUnion: {
      _this->_internal_mutable_union_()->::openfga::v1::UsersetTree_Nodes::MergeFrom(
          from._internal_union_());
      break;
    }
    case kIntersection: {
      _this->_internal_mutable_intersection()->::openfga::v1::UsersetTree_Nodes::MergeFrom(
          from._internal_intersection());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UsersetTree_Node::CopyFrom(const UsersetTree_Node& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.UsersetTree.Node)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsersetTree_Node::IsInitialized() const {
  return true;
}

void UsersetTree_Node::InternalSwap(UsersetTree_Node* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.value_, other->_impl_.value_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsersetTree_Node::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_2eproto[16]);
}

// ===================================================================

class UsersetTree::_Internal {
 public:
  static const ::openfga::v1::UsersetTree_Node& root(const UsersetTree* msg);
};

const ::openfga::v1::UsersetTree_Node&
UsersetTree::_Internal::root(const UsersetTree* msg) {
  return *msg->_impl_.root_;
}
UsersetTree::UsersetTree(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.UsersetTree)
}
UsersetTree::UsersetTree(const UsersetTree& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UsersetTree* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.root_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_root()) {
    _this->_impl_.root_ = new ::openfga::v1::UsersetTree_Node(*from._impl_.root_);
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.UsersetTree)
}

inline void UsersetTree::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.root_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UsersetTree::~UsersetTree() {
  // @@protoc_insertion_point(destructor:openfga.v1.UsersetTree)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UsersetTree::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.root_;
}

void UsersetTree::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UsersetTree::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.UsersetTree)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.root_ != nullptr) {
    delete _impl_.root_;
  }
  _impl_.root_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UsersetTree::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .openfga.v1.UsersetTree.Node root = 1 [json_name = "root"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_root(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UsersetTree::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.UsersetTree)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .openfga.v1.UsersetTree.Node root = 1 [json_name = "root"];
  if (this->_internal_has_root()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::root(this),
        _Internal::root(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.UsersetTree)
  return target;
}

size_t UsersetTree::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.UsersetTree)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .openfga.v1.UsersetTree.Node root = 1 [json_name = "root"];
  if (this->_internal_has_root()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.root_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UsersetTree::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UsersetTree::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UsersetTree::GetClassData() const { return &_class_data_; }


void UsersetTree::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UsersetTree*>(&to_msg);
  auto& from = static_cast<const UsersetTree&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.UsersetTree)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_root()) {
    _this->_internal_mutable_root()->::openfga::v1::UsersetTree_Node::MergeFrom(
        from._internal_root());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UsersetTree::CopyFrom(const UsersetTree& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.UsersetTree)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsersetTree::IsInitialized() const {
  return true;
}

void UsersetTree::InternalSwap(UsersetTree* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.root_, other->_impl_.root_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UsersetTree::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_2eproto[17]);
}

// ===================================================================

class TupleChange::_Internal {
 public:
  static const ::openfga::v1::TupleKey& tuple_key(const TupleChange* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp(const TupleChange* msg);
};

const ::openfga::v1::TupleKey&
TupleChange::_Internal::tuple_key(const TupleChange* msg) {
  return *msg->_impl_.tuple_key_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
TupleChange::_Internal::timestamp(const TupleChange* msg) {
  return *msg->_impl_.timestamp_;
}
void TupleChange::clear_timestamp() {
  if (GetArenaForAllocation() == nullptr && _impl_.timestamp_ != nullptr) {
    delete _impl_.timestamp_;
  }
  _impl_.timestamp_ = nullptr;
}
TupleChange::TupleChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.TupleChange)
}
TupleChange::TupleChange(const TupleChange& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TupleChange* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tuple_key_){nullptr}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.operation_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_tuple_key()) {
    _this->_impl_.tuple_key_ = new ::openfga::v1::TupleKey(*from._impl_.tuple_key_);
  }
  if (from._internal_has_timestamp()) {
    _this->_impl_.timestamp_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.timestamp_);
  }
  _this->_impl_.operation_ = from._impl_.operation_;
  // @@protoc_insertion_point(copy_constructor:openfga.v1.TupleChange)
}

inline void TupleChange::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tuple_key_){nullptr}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.operation_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TupleChange::~TupleChange() {
  // @@protoc_insertion_point(destructor:openfga.v1.TupleChange)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TupleChange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.tuple_key_;
  if (this != internal_default_instance()) delete _impl_.timestamp_;
}

void TupleChange::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TupleChange::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.TupleChange)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.tuple_key_ != nullptr) {
    delete _impl_.tuple_key_;
  }
  _impl_.tuple_key_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.timestamp_ != nullptr) {
    delete _impl_.timestamp_;
  }
  _impl_.timestamp_ = nullptr;
  _impl_.operation_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TupleChange::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .openfga.v1.TupleKey tuple_key = 1 [json_name = "tuple_key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_tuple_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.TupleOperation operation = 2 [json_name = "operation", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_operation(static_cast<::openfga::v1::TupleOperation>(val));
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp timestamp = 3 [json_name = "timestamp", (.google.api.field_behavior) = REQUIRED];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TupleChange::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.TupleChange)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .openfga.v1.TupleKey tuple_key = 1 [json_name = "tuple_key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (this->_internal_has_tuple_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::tuple_key(this),
        _Internal::tuple_key(this).GetCachedSize(), target, stream);
  }

  // .openfga.v1.TupleOperation operation = 2 [json_name = "operation", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (this->_internal_operation() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_operation(), target);
  }

  // .google.protobuf.Timestamp timestamp = 3 [json_name = "timestamp", (.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_timestamp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::timestamp(this),
        _Internal::timestamp(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.TupleChange)
  return target;
}

size_t TupleChange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.TupleChange)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .openfga.v1.TupleKey tuple_key = 1 [json_name = "tuple_key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (this->_internal_has_tuple_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tuple_key_);
  }

  // .google.protobuf.Timestamp timestamp = 3 [json_name = "timestamp", (.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_timestamp()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.timestamp_);
  }

  // .openfga.v1.TupleOperation operation = 2 [json_name = "operation", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (this->_internal_operation() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_operation());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TupleChange::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TupleChange::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TupleChange::GetClassData() const { return &_class_data_; }


void TupleChange::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TupleChange*>(&to_msg);
  auto& from = static_cast<const TupleChange&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.TupleChange)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tuple_key()) {
    _this->_internal_mutable_tuple_key()->::openfga::v1::TupleKey::MergeFrom(
        from._internal_tuple_key());
  }
  if (from._internal_has_timestamp()) {
    _this->_internal_mutable_timestamp()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_timestamp());
  }
  if (from._internal_operation() != 0) {
    _this->_internal_set_operation(from._internal_operation());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TupleChange::CopyFrom(const TupleChange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.TupleChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TupleChange::IsInitialized() const {
  return true;
}

void TupleChange::InternalSwap(TupleChange* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TupleChange, _impl_.operation_)
      + sizeof(TupleChange::_impl_.operation_)
      - PROTOBUF_FIELD_OFFSET(TupleChange, _impl_.tuple_key_)>(
          reinterpret_cast<char*>(&_impl_.tuple_key_),
          reinterpret_cast<char*>(&other->_impl_.tuple_key_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TupleChange::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_2eproto[18]);
}

// ===================================================================

class Store::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at(const Store* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& updated_at(const Store* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& deleted_at(const Store* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
Store::_Internal::created_at(const Store* msg) {
  return *msg->_impl_.created_at_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
Store::_Internal::updated_at(const Store* msg) {
  return *msg->_impl_.updated_at_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
Store::_Internal::deleted_at(const Store* msg) {
  return *msg->_impl_.deleted_at_;
}
void Store::clear_created_at() {
  if (GetArenaForAllocation() == nullptr && _impl_.created_at_ != nullptr) {
    delete _impl_.created_at_;
  }
  _impl_.created_at_ = nullptr;
}
void Store::clear_updated_at() {
  if (GetArenaForAllocation() == nullptr && _impl_.updated_at_ != nullptr) {
    delete _impl_.updated_at_;
  }
  _impl_.updated_at_ = nullptr;
}
void Store::clear_deleted_at() {
  if (GetArenaForAllocation() == nullptr && _impl_.deleted_at_ != nullptr) {
    delete _impl_.deleted_at_;
  }
  _impl_.deleted_at_ = nullptr;
}
Store::Store(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.Store)
}
Store::Store(const Store& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Store* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.created_at_){nullptr}
    , decltype(_impl_.updated_at_){nullptr}
    , decltype(_impl_.deleted_at_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_created_at()) {
    _this->_impl_.created_at_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.created_at_);
  }
  if (from._internal_has_updated_at()) {
    _this->_impl_.updated_at_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.updated_at_);
  }
  if (from._internal_has_deleted_at()) {
    _this->_impl_.deleted_at_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.deleted_at_);
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.Store)
}

inline void Store::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.created_at_){nullptr}
    , decltype(_impl_.updated_at_){nullptr}
    , decltype(_impl_.deleted_at_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Store::~Store() {
  // @@protoc_insertion_point(destructor:openfga.v1.Store)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Store::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.created_at_;
  if (this != internal_default_instance()) delete _impl_.updated_at_;
  if (this != internal_default_instance()) delete _impl_.deleted_at_;
}

void Store::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Store::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.Store)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.created_at_ != nullptr) {
    delete _impl_.created_at_;
  }
  _impl_.created_at_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.updated_at_ != nullptr) {
    delete _impl_.updated_at_;
  }
  _impl_.updated_at_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.deleted_at_ != nullptr) {
    delete _impl_.deleted_at_;
  }
  _impl_.deleted_at_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Store::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1 [json_name = "id", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.Store.id"));
        } else
          goto handle_unusual;
        continue;
      // string name = 2 [json_name = "name", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.Store.name"));
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp created_at = 3 [json_name = "created_at", (.google.api.field_behavior) = REQUIRED];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_created_at(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp updated_at = 4 [json_name = "updated_at", (.google.api.field_behavior) = REQUIRED];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_updated_at(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp deleted_at = 5 [json_name = "deleted_at"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_deleted_at(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Store::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.Store)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1 [json_name = "id", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.Store.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // string name = 2 [json_name = "name", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.Store.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // .google.protobuf.Timestamp created_at = 3 [json_name = "created_at", (.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_created_at()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::created_at(this),
        _Internal::created_at(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Timestamp updated_at = 4 [json_name = "updated_at", (.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_updated_at()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::updated_at(this),
        _Internal::updated_at(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Timestamp deleted_at = 5 [json_name = "deleted_at"];
  if (this->_internal_has_deleted_at()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::deleted_at(this),
        _Internal::deleted_at(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.Store)
  return target;
}

size_t Store::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.Store)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string id = 1 [json_name = "id", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // string name = 2 [json_name = "name", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .google.protobuf.Timestamp created_at = 3 [json_name = "created_at", (.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_created_at()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.created_at_);
  }

  // .google.protobuf.Timestamp updated_at = 4 [json_name = "updated_at", (.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_updated_at()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.updated_at_);
  }

  // .google.protobuf.Timestamp deleted_at = 5 [json_name = "deleted_at"];
  if (this->_internal_has_deleted_at()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.deleted_at_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Store::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Store::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Store::GetClassData() const { return &_class_data_; }


void Store::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Store*>(&to_msg);
  auto& from = static_cast<const Store&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.Store)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_created_at()) {
    _this->_internal_mutable_created_at()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_created_at());
  }
  if (from._internal_has_updated_at()) {
    _this->_internal_mutable_updated_at()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_updated_at());
  }
  if (from._internal_has_deleted_at()) {
    _this->_internal_mutable_deleted_at()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_deleted_at());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Store::CopyFrom(const Store& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.Store)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Store::IsInitialized() const {
  return true;
}

void Store::InternalSwap(Store* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Store, _impl_.deleted_at_)
      + sizeof(Store::_impl_.deleted_at_)
      - PROTOBUF_FIELD_OFFSET(Store, _impl_.created_at_)>(
          reinterpret_cast<char*>(&_impl_.created_at_),
          reinterpret_cast<char*>(&other->_impl_.created_at_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Store::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_2eproto[19]);
}

// ===================================================================

class UserTypeFilter::_Internal {
 public:
};

UserTypeFilter::UserTypeFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.UserTypeFilter)
}
UserTypeFilter::UserTypeFilter(const UserTypeFilter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UserTypeFilter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){}
    , decltype(_impl_.relation_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type().empty()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.relation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_relation().empty()) {
    _this->_impl_.relation_.Set(from._internal_relation(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.UserTypeFilter)
}

inline void UserTypeFilter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.type_){}
    , decltype(_impl_.relation_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.relation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UserTypeFilter::~UserTypeFilter() {
  // @@protoc_insertion_point(destructor:openfga.v1.UserTypeFilter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserTypeFilter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.type_.Destroy();
  _impl_.relation_.Destroy();
}

void UserTypeFilter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UserTypeFilter::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.UserTypeFilter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.type_.ClearToEmpty();
  _impl_.relation_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UserTypeFilter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type = 1 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.UserTypeFilter.type"));
        } else
          goto handle_unusual;
        continue;
      // string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_relation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.UserTypeFilter.relation"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserTypeFilter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.UserTypeFilter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type = 1 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.UserTypeFilter.type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type(), target);
  }

  // string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_relation().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_relation().data(), static_cast<int>(this->_internal_relation().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.UserTypeFilter.relation");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_relation(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.UserTypeFilter)
  return target;
}

size_t UserTypeFilter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.UserTypeFilter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string type = 1 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());
  }

  // string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_relation().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_relation());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UserTypeFilter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UserTypeFilter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UserTypeFilter::GetClassData() const { return &_class_data_; }


void UserTypeFilter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UserTypeFilter*>(&to_msg);
  auto& from = static_cast<const UserTypeFilter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.UserTypeFilter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_type().empty()) {
    _this->_internal_set_type(from._internal_type());
  }
  if (!from._internal_relation().empty()) {
    _this->_internal_set_relation(from._internal_relation());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UserTypeFilter::CopyFrom(const UserTypeFilter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.UserTypeFilter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserTypeFilter::IsInitialized() const {
  return true;
}

void UserTypeFilter::InternalSwap(UserTypeFilter* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.relation_, lhs_arena,
      &other->_impl_.relation_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata UserTypeFilter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_2eproto[20]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace openfga
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::openfga::v1::Object*
Arena::CreateMaybeMessage< ::openfga::v1::Object >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::Object >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::User*
Arena::CreateMaybeMessage< ::openfga::v1::User >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::User >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::UsersetUser*
Arena::CreateMaybeMessage< ::openfga::v1::UsersetUser >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::UsersetUser >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::RelationshipCondition*
Arena::CreateMaybeMessage< ::openfga::v1::RelationshipCondition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::RelationshipCondition >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::TupleKeyWithoutCondition*
Arena::CreateMaybeMessage< ::openfga::v1::TupleKeyWithoutCondition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::TupleKeyWithoutCondition >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::TypedWildcard*
Arena::CreateMaybeMessage< ::openfga::v1::TypedWildcard >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::TypedWildcard >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::TupleKey*
Arena::CreateMaybeMessage< ::openfga::v1::TupleKey >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::TupleKey >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::Tuple*
Arena::CreateMaybeMessage< ::openfga::v1::Tuple >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::Tuple >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::TupleKeys*
Arena::CreateMaybeMessage< ::openfga::v1::TupleKeys >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::TupleKeys >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::ContextualTupleKeys*
Arena::CreateMaybeMessage< ::openfga::v1::ContextualTupleKeys >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::ContextualTupleKeys >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::UsersetTree_Leaf*
Arena::CreateMaybeMessage< ::openfga::v1::UsersetTree_Leaf >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::UsersetTree_Leaf >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::UsersetTree_Nodes*
Arena::CreateMaybeMessage< ::openfga::v1::UsersetTree_Nodes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::UsersetTree_Nodes >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::UsersetTree_Users*
Arena::CreateMaybeMessage< ::openfga::v1::UsersetTree_Users >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::UsersetTree_Users >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::UsersetTree_Computed*
Arena::CreateMaybeMessage< ::openfga::v1::UsersetTree_Computed >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::UsersetTree_Computed >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::UsersetTree_TupleToUserset*
Arena::CreateMaybeMessage< ::openfga::v1::UsersetTree_TupleToUserset >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::UsersetTree_TupleToUserset >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::UsersetTree_Difference*
Arena::CreateMaybeMessage< ::openfga::v1::UsersetTree_Difference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::UsersetTree_Difference >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::UsersetTree_Node*
Arena::CreateMaybeMessage< ::openfga::v1::UsersetTree_Node >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::UsersetTree_Node >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::UsersetTree*
Arena::CreateMaybeMessage< ::openfga::v1::UsersetTree >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::UsersetTree >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::TupleChange*
Arena::CreateMaybeMessage< ::openfga::v1::TupleChange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::TupleChange >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::Store*
Arena::CreateMaybeMessage< ::openfga::v1::Store >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::Store >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::UserTypeFilter*
Arena::CreateMaybeMessage< ::openfga::v1::UserTypeFilter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::UserTypeFilter >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
