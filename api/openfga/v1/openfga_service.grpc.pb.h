// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: openfga/v1/openfga_service.proto
#ifndef GRPC_openfga_2fv1_2fopenfga_5fservice_2eproto__INCLUDED
#define GRPC_openfga_2fv1_2fopenfga_5fservice_2eproto__INCLUDED

#include "openfga/v1/openfga_service.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace openfga {
namespace v1 {

class OpenFGAService final {
 public:
  static constexpr char const* service_full_name() {
    return "openfga.v1.OpenFGAService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Read(::grpc::ClientContext* context, const ::openfga::v1::ReadRequest& request, ::openfga::v1::ReadResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadResponse>> AsyncRead(::grpc::ClientContext* context, const ::openfga::v1::ReadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadResponse>>(AsyncReadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadResponse>> PrepareAsyncRead(::grpc::ClientContext* context, const ::openfga::v1::ReadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadResponse>>(PrepareAsyncReadRaw(context, request, cq));
    }
    virtual ::grpc::Status Write(::grpc::ClientContext* context, const ::openfga::v1::WriteRequest& request, ::openfga::v1::WriteResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::WriteResponse>> AsyncWrite(::grpc::ClientContext* context, const ::openfga::v1::WriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::WriteResponse>>(AsyncWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::WriteResponse>> PrepareAsyncWrite(::grpc::ClientContext* context, const ::openfga::v1::WriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::WriteResponse>>(PrepareAsyncWriteRaw(context, request, cq));
    }
    virtual ::grpc::Status Check(::grpc::ClientContext* context, const ::openfga::v1::CheckRequest& request, ::openfga::v1::CheckResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::CheckResponse>> AsyncCheck(::grpc::ClientContext* context, const ::openfga::v1::CheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::CheckResponse>>(AsyncCheckRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::CheckResponse>> PrepareAsyncCheck(::grpc::ClientContext* context, const ::openfga::v1::CheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::CheckResponse>>(PrepareAsyncCheckRaw(context, request, cq));
    }
    virtual ::grpc::Status BatchCheck(::grpc::ClientContext* context, const ::openfga::v1::BatchCheckRequest& request, ::openfga::v1::BatchCheckResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::BatchCheckResponse>> AsyncBatchCheck(::grpc::ClientContext* context, const ::openfga::v1::BatchCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::BatchCheckResponse>>(AsyncBatchCheckRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::BatchCheckResponse>> PrepareAsyncBatchCheck(::grpc::ClientContext* context, const ::openfga::v1::BatchCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::BatchCheckResponse>>(PrepareAsyncBatchCheckRaw(context, request, cq));
    }
    virtual ::grpc::Status Expand(::grpc::ClientContext* context, const ::openfga::v1::ExpandRequest& request, ::openfga::v1::ExpandResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ExpandResponse>> AsyncExpand(::grpc::ClientContext* context, const ::openfga::v1::ExpandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ExpandResponse>>(AsyncExpandRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ExpandResponse>> PrepareAsyncExpand(::grpc::ClientContext* context, const ::openfga::v1::ExpandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ExpandResponse>>(PrepareAsyncExpandRaw(context, request, cq));
    }
    virtual ::grpc::Status ReadAuthorizationModels(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelsRequest& request, ::openfga::v1::ReadAuthorizationModelsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadAuthorizationModelsResponse>> AsyncReadAuthorizationModels(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadAuthorizationModelsResponse>>(AsyncReadAuthorizationModelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadAuthorizationModelsResponse>> PrepareAsyncReadAuthorizationModels(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadAuthorizationModelsResponse>>(PrepareAsyncReadAuthorizationModelsRaw(context, request, cq));
    }
    virtual ::grpc::Status ReadAuthorizationModel(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelRequest& request, ::openfga::v1::ReadAuthorizationModelResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadAuthorizationModelResponse>> AsyncReadAuthorizationModel(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadAuthorizationModelResponse>>(AsyncReadAuthorizationModelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadAuthorizationModelResponse>> PrepareAsyncReadAuthorizationModel(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadAuthorizationModelResponse>>(PrepareAsyncReadAuthorizationModelRaw(context, request, cq));
    }
    virtual ::grpc::Status WriteAuthorizationModel(::grpc::ClientContext* context, const ::openfga::v1::WriteAuthorizationModelRequest& request, ::openfga::v1::WriteAuthorizationModelResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::WriteAuthorizationModelResponse>> AsyncWriteAuthorizationModel(::grpc::ClientContext* context, const ::openfga::v1::WriteAuthorizationModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::WriteAuthorizationModelResponse>>(AsyncWriteAuthorizationModelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::WriteAuthorizationModelResponse>> PrepareAsyncWriteAuthorizationModel(::grpc::ClientContext* context, const ::openfga::v1::WriteAuthorizationModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::WriteAuthorizationModelResponse>>(PrepareAsyncWriteAuthorizationModelRaw(context, request, cq));
    }
    virtual ::grpc::Status WriteAssertions(::grpc::ClientContext* context, const ::openfga::v1::WriteAssertionsRequest& request, ::openfga::v1::WriteAssertionsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::WriteAssertionsResponse>> AsyncWriteAssertions(::grpc::ClientContext* context, const ::openfga::v1::WriteAssertionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::WriteAssertionsResponse>>(AsyncWriteAssertionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::WriteAssertionsResponse>> PrepareAsyncWriteAssertions(::grpc::ClientContext* context, const ::openfga::v1::WriteAssertionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::WriteAssertionsResponse>>(PrepareAsyncWriteAssertionsRaw(context, request, cq));
    }
    virtual ::grpc::Status ReadAssertions(::grpc::ClientContext* context, const ::openfga::v1::ReadAssertionsRequest& request, ::openfga::v1::ReadAssertionsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadAssertionsResponse>> AsyncReadAssertions(::grpc::ClientContext* context, const ::openfga::v1::ReadAssertionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadAssertionsResponse>>(AsyncReadAssertionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadAssertionsResponse>> PrepareAsyncReadAssertions(::grpc::ClientContext* context, const ::openfga::v1::ReadAssertionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadAssertionsResponse>>(PrepareAsyncReadAssertionsRaw(context, request, cq));
    }
    virtual ::grpc::Status ReadChanges(::grpc::ClientContext* context, const ::openfga::v1::ReadChangesRequest& request, ::openfga::v1::ReadChangesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadChangesResponse>> AsyncReadChanges(::grpc::ClientContext* context, const ::openfga::v1::ReadChangesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadChangesResponse>>(AsyncReadChangesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadChangesResponse>> PrepareAsyncReadChanges(::grpc::ClientContext* context, const ::openfga::v1::ReadChangesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadChangesResponse>>(PrepareAsyncReadChangesRaw(context, request, cq));
    }
    virtual ::grpc::Status CreateStore(::grpc::ClientContext* context, const ::openfga::v1::CreateStoreRequest& request, ::openfga::v1::CreateStoreResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::CreateStoreResponse>> AsyncCreateStore(::grpc::ClientContext* context, const ::openfga::v1::CreateStoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::CreateStoreResponse>>(AsyncCreateStoreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::CreateStoreResponse>> PrepareAsyncCreateStore(::grpc::ClientContext* context, const ::openfga::v1::CreateStoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::CreateStoreResponse>>(PrepareAsyncCreateStoreRaw(context, request, cq));
    }
    virtual ::grpc::Status UpdateStore(::grpc::ClientContext* context, const ::openfga::v1::UpdateStoreRequest& request, ::openfga::v1::UpdateStoreResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::UpdateStoreResponse>> AsyncUpdateStore(::grpc::ClientContext* context, const ::openfga::v1::UpdateStoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::UpdateStoreResponse>>(AsyncUpdateStoreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::UpdateStoreResponse>> PrepareAsyncUpdateStore(::grpc::ClientContext* context, const ::openfga::v1::UpdateStoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::UpdateStoreResponse>>(PrepareAsyncUpdateStoreRaw(context, request, cq));
    }
    virtual ::grpc::Status DeleteStore(::grpc::ClientContext* context, const ::openfga::v1::DeleteStoreRequest& request, ::openfga::v1::DeleteStoreResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::DeleteStoreResponse>> AsyncDeleteStore(::grpc::ClientContext* context, const ::openfga::v1::DeleteStoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::DeleteStoreResponse>>(AsyncDeleteStoreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::DeleteStoreResponse>> PrepareAsyncDeleteStore(::grpc::ClientContext* context, const ::openfga::v1::DeleteStoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::DeleteStoreResponse>>(PrepareAsyncDeleteStoreRaw(context, request, cq));
    }
    virtual ::grpc::Status GetStore(::grpc::ClientContext* context, const ::openfga::v1::GetStoreRequest& request, ::openfga::v1::GetStoreResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::GetStoreResponse>> AsyncGetStore(::grpc::ClientContext* context, const ::openfga::v1::GetStoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::GetStoreResponse>>(AsyncGetStoreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::GetStoreResponse>> PrepareAsyncGetStore(::grpc::ClientContext* context, const ::openfga::v1::GetStoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::GetStoreResponse>>(PrepareAsyncGetStoreRaw(context, request, cq));
    }
    virtual ::grpc::Status ListStores(::grpc::ClientContext* context, const ::openfga::v1::ListStoresRequest& request, ::openfga::v1::ListStoresResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ListStoresResponse>> AsyncListStores(::grpc::ClientContext* context, const ::openfga::v1::ListStoresRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ListStoresResponse>>(AsyncListStoresRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ListStoresResponse>> PrepareAsyncListStores(::grpc::ClientContext* context, const ::openfga::v1::ListStoresRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ListStoresResponse>>(PrepareAsyncListStoresRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::openfga::v1::StreamedListObjectsResponse>> StreamedListObjects(::grpc::ClientContext* context, const ::openfga::v1::StreamedListObjectsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::openfga::v1::StreamedListObjectsResponse>>(StreamedListObjectsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::openfga::v1::StreamedListObjectsResponse>> AsyncStreamedListObjects(::grpc::ClientContext* context, const ::openfga::v1::StreamedListObjectsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::openfga::v1::StreamedListObjectsResponse>>(AsyncStreamedListObjectsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::openfga::v1::StreamedListObjectsResponse>> PrepareAsyncStreamedListObjects(::grpc::ClientContext* context, const ::openfga::v1::StreamedListObjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::openfga::v1::StreamedListObjectsResponse>>(PrepareAsyncStreamedListObjectsRaw(context, request, cq));
    }
    virtual ::grpc::Status ListObjects(::grpc::ClientContext* context, const ::openfga::v1::ListObjectsRequest& request, ::openfga::v1::ListObjectsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ListObjectsResponse>> AsyncListObjects(::grpc::ClientContext* context, const ::openfga::v1::ListObjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ListObjectsResponse>>(AsyncListObjectsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ListObjectsResponse>> PrepareAsyncListObjects(::grpc::ClientContext* context, const ::openfga::v1::ListObjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ListObjectsResponse>>(PrepareAsyncListObjectsRaw(context, request, cq));
    }
    virtual ::grpc::Status ListUsers(::grpc::ClientContext* context, const ::openfga::v1::ListUsersRequest& request, ::openfga::v1::ListUsersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ListUsersResponse>> AsyncListUsers(::grpc::ClientContext* context, const ::openfga::v1::ListUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ListUsersResponse>>(AsyncListUsersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ListUsersResponse>> PrepareAsyncListUsers(::grpc::ClientContext* context, const ::openfga::v1::ListUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ListUsersResponse>>(PrepareAsyncListUsersRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void Read(::grpc::ClientContext* context, const ::openfga::v1::ReadRequest* request, ::openfga::v1::ReadResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Read(::grpc::ClientContext* context, const ::openfga::v1::ReadRequest* request, ::openfga::v1::ReadResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Write(::grpc::ClientContext* context, const ::openfga::v1::WriteRequest* request, ::openfga::v1::WriteResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Write(::grpc::ClientContext* context, const ::openfga::v1::WriteRequest* request, ::openfga::v1::WriteResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Check(::grpc::ClientContext* context, const ::openfga::v1::CheckRequest* request, ::openfga::v1::CheckResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Check(::grpc::ClientContext* context, const ::openfga::v1::CheckRequest* request, ::openfga::v1::CheckResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void BatchCheck(::grpc::ClientContext* context, const ::openfga::v1::BatchCheckRequest* request, ::openfga::v1::BatchCheckResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BatchCheck(::grpc::ClientContext* context, const ::openfga::v1::BatchCheckRequest* request, ::openfga::v1::BatchCheckResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Expand(::grpc::ClientContext* context, const ::openfga::v1::ExpandRequest* request, ::openfga::v1::ExpandResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Expand(::grpc::ClientContext* context, const ::openfga::v1::ExpandRequest* request, ::openfga::v1::ExpandResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ReadAuthorizationModels(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelsRequest* request, ::openfga::v1::ReadAuthorizationModelsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ReadAuthorizationModels(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelsRequest* request, ::openfga::v1::ReadAuthorizationModelsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ReadAuthorizationModel(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelRequest* request, ::openfga::v1::ReadAuthorizationModelResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ReadAuthorizationModel(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelRequest* request, ::openfga::v1::ReadAuthorizationModelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void WriteAuthorizationModel(::grpc::ClientContext* context, const ::openfga::v1::WriteAuthorizationModelRequest* request, ::openfga::v1::WriteAuthorizationModelResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WriteAuthorizationModel(::grpc::ClientContext* context, const ::openfga::v1::WriteAuthorizationModelRequest* request, ::openfga::v1::WriteAuthorizationModelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void WriteAssertions(::grpc::ClientContext* context, const ::openfga::v1::WriteAssertionsRequest* request, ::openfga::v1::WriteAssertionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WriteAssertions(::grpc::ClientContext* context, const ::openfga::v1::WriteAssertionsRequest* request, ::openfga::v1::WriteAssertionsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ReadAssertions(::grpc::ClientContext* context, const ::openfga::v1::ReadAssertionsRequest* request, ::openfga::v1::ReadAssertionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ReadAssertions(::grpc::ClientContext* context, const ::openfga::v1::ReadAssertionsRequest* request, ::openfga::v1::ReadAssertionsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ReadChanges(::grpc::ClientContext* context, const ::openfga::v1::ReadChangesRequest* request, ::openfga::v1::ReadChangesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ReadChanges(::grpc::ClientContext* context, const ::openfga::v1::ReadChangesRequest* request, ::openfga::v1::ReadChangesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void CreateStore(::grpc::ClientContext* context, const ::openfga::v1::CreateStoreRequest* request, ::openfga::v1::CreateStoreResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateStore(::grpc::ClientContext* context, const ::openfga::v1::CreateStoreRequest* request, ::openfga::v1::CreateStoreResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void UpdateStore(::grpc::ClientContext* context, const ::openfga::v1::UpdateStoreRequest* request, ::openfga::v1::UpdateStoreResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateStore(::grpc::ClientContext* context, const ::openfga::v1::UpdateStoreRequest* request, ::openfga::v1::UpdateStoreResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DeleteStore(::grpc::ClientContext* context, const ::openfga::v1::DeleteStoreRequest* request, ::openfga::v1::DeleteStoreResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteStore(::grpc::ClientContext* context, const ::openfga::v1::DeleteStoreRequest* request, ::openfga::v1::DeleteStoreResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetStore(::grpc::ClientContext* context, const ::openfga::v1::GetStoreRequest* request, ::openfga::v1::GetStoreResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetStore(::grpc::ClientContext* context, const ::openfga::v1::GetStoreRequest* request, ::openfga::v1::GetStoreResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ListStores(::grpc::ClientContext* context, const ::openfga::v1::ListStoresRequest* request, ::openfga::v1::ListStoresResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListStores(::grpc::ClientContext* context, const ::openfga::v1::ListStoresRequest* request, ::openfga::v1::ListStoresResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void StreamedListObjects(::grpc::ClientContext* context, const ::openfga::v1::StreamedListObjectsRequest* request, ::grpc::ClientReadReactor< ::openfga::v1::StreamedListObjectsResponse>* reactor) = 0;
      virtual void ListObjects(::grpc::ClientContext* context, const ::openfga::v1::ListObjectsRequest* request, ::openfga::v1::ListObjectsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListObjects(::grpc::ClientContext* context, const ::openfga::v1::ListObjectsRequest* request, ::openfga::v1::ListObjectsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ListUsers(::grpc::ClientContext* context, const ::openfga::v1::ListUsersRequest* request, ::openfga::v1::ListUsersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListUsers(::grpc::ClientContext* context, const ::openfga::v1::ListUsersRequest* request, ::openfga::v1::ListUsersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadResponse>* AsyncReadRaw(::grpc::ClientContext* context, const ::openfga::v1::ReadRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadResponse>* PrepareAsyncReadRaw(::grpc::ClientContext* context, const ::openfga::v1::ReadRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::WriteResponse>* AsyncWriteRaw(::grpc::ClientContext* context, const ::openfga::v1::WriteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::WriteResponse>* PrepareAsyncWriteRaw(::grpc::ClientContext* context, const ::openfga::v1::WriteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::CheckResponse>* AsyncCheckRaw(::grpc::ClientContext* context, const ::openfga::v1::CheckRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::CheckResponse>* PrepareAsyncCheckRaw(::grpc::ClientContext* context, const ::openfga::v1::CheckRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::BatchCheckResponse>* AsyncBatchCheckRaw(::grpc::ClientContext* context, const ::openfga::v1::BatchCheckRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::BatchCheckResponse>* PrepareAsyncBatchCheckRaw(::grpc::ClientContext* context, const ::openfga::v1::BatchCheckRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ExpandResponse>* AsyncExpandRaw(::grpc::ClientContext* context, const ::openfga::v1::ExpandRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ExpandResponse>* PrepareAsyncExpandRaw(::grpc::ClientContext* context, const ::openfga::v1::ExpandRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadAuthorizationModelsResponse>* AsyncReadAuthorizationModelsRaw(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadAuthorizationModelsResponse>* PrepareAsyncReadAuthorizationModelsRaw(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadAuthorizationModelResponse>* AsyncReadAuthorizationModelRaw(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadAuthorizationModelResponse>* PrepareAsyncReadAuthorizationModelRaw(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::WriteAuthorizationModelResponse>* AsyncWriteAuthorizationModelRaw(::grpc::ClientContext* context, const ::openfga::v1::WriteAuthorizationModelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::WriteAuthorizationModelResponse>* PrepareAsyncWriteAuthorizationModelRaw(::grpc::ClientContext* context, const ::openfga::v1::WriteAuthorizationModelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::WriteAssertionsResponse>* AsyncWriteAssertionsRaw(::grpc::ClientContext* context, const ::openfga::v1::WriteAssertionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::WriteAssertionsResponse>* PrepareAsyncWriteAssertionsRaw(::grpc::ClientContext* context, const ::openfga::v1::WriteAssertionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadAssertionsResponse>* AsyncReadAssertionsRaw(::grpc::ClientContext* context, const ::openfga::v1::ReadAssertionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadAssertionsResponse>* PrepareAsyncReadAssertionsRaw(::grpc::ClientContext* context, const ::openfga::v1::ReadAssertionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadChangesResponse>* AsyncReadChangesRaw(::grpc::ClientContext* context, const ::openfga::v1::ReadChangesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ReadChangesResponse>* PrepareAsyncReadChangesRaw(::grpc::ClientContext* context, const ::openfga::v1::ReadChangesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::CreateStoreResponse>* AsyncCreateStoreRaw(::grpc::ClientContext* context, const ::openfga::v1::CreateStoreRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::CreateStoreResponse>* PrepareAsyncCreateStoreRaw(::grpc::ClientContext* context, const ::openfga::v1::CreateStoreRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::UpdateStoreResponse>* AsyncUpdateStoreRaw(::grpc::ClientContext* context, const ::openfga::v1::UpdateStoreRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::UpdateStoreResponse>* PrepareAsyncUpdateStoreRaw(::grpc::ClientContext* context, const ::openfga::v1::UpdateStoreRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::DeleteStoreResponse>* AsyncDeleteStoreRaw(::grpc::ClientContext* context, const ::openfga::v1::DeleteStoreRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::DeleteStoreResponse>* PrepareAsyncDeleteStoreRaw(::grpc::ClientContext* context, const ::openfga::v1::DeleteStoreRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::GetStoreResponse>* AsyncGetStoreRaw(::grpc::ClientContext* context, const ::openfga::v1::GetStoreRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::GetStoreResponse>* PrepareAsyncGetStoreRaw(::grpc::ClientContext* context, const ::openfga::v1::GetStoreRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ListStoresResponse>* AsyncListStoresRaw(::grpc::ClientContext* context, const ::openfga::v1::ListStoresRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ListStoresResponse>* PrepareAsyncListStoresRaw(::grpc::ClientContext* context, const ::openfga::v1::ListStoresRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::openfga::v1::StreamedListObjectsResponse>* StreamedListObjectsRaw(::grpc::ClientContext* context, const ::openfga::v1::StreamedListObjectsRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::openfga::v1::StreamedListObjectsResponse>* AsyncStreamedListObjectsRaw(::grpc::ClientContext* context, const ::openfga::v1::StreamedListObjectsRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::openfga::v1::StreamedListObjectsResponse>* PrepareAsyncStreamedListObjectsRaw(::grpc::ClientContext* context, const ::openfga::v1::StreamedListObjectsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ListObjectsResponse>* AsyncListObjectsRaw(::grpc::ClientContext* context, const ::openfga::v1::ListObjectsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ListObjectsResponse>* PrepareAsyncListObjectsRaw(::grpc::ClientContext* context, const ::openfga::v1::ListObjectsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ListUsersResponse>* AsyncListUsersRaw(::grpc::ClientContext* context, const ::openfga::v1::ListUsersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::openfga::v1::ListUsersResponse>* PrepareAsyncListUsersRaw(::grpc::ClientContext* context, const ::openfga::v1::ListUsersRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Read(::grpc::ClientContext* context, const ::openfga::v1::ReadRequest& request, ::openfga::v1::ReadResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadResponse>> AsyncRead(::grpc::ClientContext* context, const ::openfga::v1::ReadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadResponse>>(AsyncReadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadResponse>> PrepareAsyncRead(::grpc::ClientContext* context, const ::openfga::v1::ReadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadResponse>>(PrepareAsyncReadRaw(context, request, cq));
    }
    ::grpc::Status Write(::grpc::ClientContext* context, const ::openfga::v1::WriteRequest& request, ::openfga::v1::WriteResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::WriteResponse>> AsyncWrite(::grpc::ClientContext* context, const ::openfga::v1::WriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::WriteResponse>>(AsyncWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::WriteResponse>> PrepareAsyncWrite(::grpc::ClientContext* context, const ::openfga::v1::WriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::WriteResponse>>(PrepareAsyncWriteRaw(context, request, cq));
    }
    ::grpc::Status Check(::grpc::ClientContext* context, const ::openfga::v1::CheckRequest& request, ::openfga::v1::CheckResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::CheckResponse>> AsyncCheck(::grpc::ClientContext* context, const ::openfga::v1::CheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::CheckResponse>>(AsyncCheckRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::CheckResponse>> PrepareAsyncCheck(::grpc::ClientContext* context, const ::openfga::v1::CheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::CheckResponse>>(PrepareAsyncCheckRaw(context, request, cq));
    }
    ::grpc::Status BatchCheck(::grpc::ClientContext* context, const ::openfga::v1::BatchCheckRequest& request, ::openfga::v1::BatchCheckResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::BatchCheckResponse>> AsyncBatchCheck(::grpc::ClientContext* context, const ::openfga::v1::BatchCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::BatchCheckResponse>>(AsyncBatchCheckRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::BatchCheckResponse>> PrepareAsyncBatchCheck(::grpc::ClientContext* context, const ::openfga::v1::BatchCheckRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::BatchCheckResponse>>(PrepareAsyncBatchCheckRaw(context, request, cq));
    }
    ::grpc::Status Expand(::grpc::ClientContext* context, const ::openfga::v1::ExpandRequest& request, ::openfga::v1::ExpandResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ExpandResponse>> AsyncExpand(::grpc::ClientContext* context, const ::openfga::v1::ExpandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ExpandResponse>>(AsyncExpandRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ExpandResponse>> PrepareAsyncExpand(::grpc::ClientContext* context, const ::openfga::v1::ExpandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ExpandResponse>>(PrepareAsyncExpandRaw(context, request, cq));
    }
    ::grpc::Status ReadAuthorizationModels(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelsRequest& request, ::openfga::v1::ReadAuthorizationModelsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadAuthorizationModelsResponse>> AsyncReadAuthorizationModels(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadAuthorizationModelsResponse>>(AsyncReadAuthorizationModelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadAuthorizationModelsResponse>> PrepareAsyncReadAuthorizationModels(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadAuthorizationModelsResponse>>(PrepareAsyncReadAuthorizationModelsRaw(context, request, cq));
    }
    ::grpc::Status ReadAuthorizationModel(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelRequest& request, ::openfga::v1::ReadAuthorizationModelResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadAuthorizationModelResponse>> AsyncReadAuthorizationModel(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadAuthorizationModelResponse>>(AsyncReadAuthorizationModelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadAuthorizationModelResponse>> PrepareAsyncReadAuthorizationModel(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadAuthorizationModelResponse>>(PrepareAsyncReadAuthorizationModelRaw(context, request, cq));
    }
    ::grpc::Status WriteAuthorizationModel(::grpc::ClientContext* context, const ::openfga::v1::WriteAuthorizationModelRequest& request, ::openfga::v1::WriteAuthorizationModelResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::WriteAuthorizationModelResponse>> AsyncWriteAuthorizationModel(::grpc::ClientContext* context, const ::openfga::v1::WriteAuthorizationModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::WriteAuthorizationModelResponse>>(AsyncWriteAuthorizationModelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::WriteAuthorizationModelResponse>> PrepareAsyncWriteAuthorizationModel(::grpc::ClientContext* context, const ::openfga::v1::WriteAuthorizationModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::WriteAuthorizationModelResponse>>(PrepareAsyncWriteAuthorizationModelRaw(context, request, cq));
    }
    ::grpc::Status WriteAssertions(::grpc::ClientContext* context, const ::openfga::v1::WriteAssertionsRequest& request, ::openfga::v1::WriteAssertionsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::WriteAssertionsResponse>> AsyncWriteAssertions(::grpc::ClientContext* context, const ::openfga::v1::WriteAssertionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::WriteAssertionsResponse>>(AsyncWriteAssertionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::WriteAssertionsResponse>> PrepareAsyncWriteAssertions(::grpc::ClientContext* context, const ::openfga::v1::WriteAssertionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::WriteAssertionsResponse>>(PrepareAsyncWriteAssertionsRaw(context, request, cq));
    }
    ::grpc::Status ReadAssertions(::grpc::ClientContext* context, const ::openfga::v1::ReadAssertionsRequest& request, ::openfga::v1::ReadAssertionsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadAssertionsResponse>> AsyncReadAssertions(::grpc::ClientContext* context, const ::openfga::v1::ReadAssertionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadAssertionsResponse>>(AsyncReadAssertionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadAssertionsResponse>> PrepareAsyncReadAssertions(::grpc::ClientContext* context, const ::openfga::v1::ReadAssertionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadAssertionsResponse>>(PrepareAsyncReadAssertionsRaw(context, request, cq));
    }
    ::grpc::Status ReadChanges(::grpc::ClientContext* context, const ::openfga::v1::ReadChangesRequest& request, ::openfga::v1::ReadChangesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadChangesResponse>> AsyncReadChanges(::grpc::ClientContext* context, const ::openfga::v1::ReadChangesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadChangesResponse>>(AsyncReadChangesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadChangesResponse>> PrepareAsyncReadChanges(::grpc::ClientContext* context, const ::openfga::v1::ReadChangesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadChangesResponse>>(PrepareAsyncReadChangesRaw(context, request, cq));
    }
    ::grpc::Status CreateStore(::grpc::ClientContext* context, const ::openfga::v1::CreateStoreRequest& request, ::openfga::v1::CreateStoreResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::CreateStoreResponse>> AsyncCreateStore(::grpc::ClientContext* context, const ::openfga::v1::CreateStoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::CreateStoreResponse>>(AsyncCreateStoreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::CreateStoreResponse>> PrepareAsyncCreateStore(::grpc::ClientContext* context, const ::openfga::v1::CreateStoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::CreateStoreResponse>>(PrepareAsyncCreateStoreRaw(context, request, cq));
    }
    ::grpc::Status UpdateStore(::grpc::ClientContext* context, const ::openfga::v1::UpdateStoreRequest& request, ::openfga::v1::UpdateStoreResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::UpdateStoreResponse>> AsyncUpdateStore(::grpc::ClientContext* context, const ::openfga::v1::UpdateStoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::UpdateStoreResponse>>(AsyncUpdateStoreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::UpdateStoreResponse>> PrepareAsyncUpdateStore(::grpc::ClientContext* context, const ::openfga::v1::UpdateStoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::UpdateStoreResponse>>(PrepareAsyncUpdateStoreRaw(context, request, cq));
    }
    ::grpc::Status DeleteStore(::grpc::ClientContext* context, const ::openfga::v1::DeleteStoreRequest& request, ::openfga::v1::DeleteStoreResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::DeleteStoreResponse>> AsyncDeleteStore(::grpc::ClientContext* context, const ::openfga::v1::DeleteStoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::DeleteStoreResponse>>(AsyncDeleteStoreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::DeleteStoreResponse>> PrepareAsyncDeleteStore(::grpc::ClientContext* context, const ::openfga::v1::DeleteStoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::DeleteStoreResponse>>(PrepareAsyncDeleteStoreRaw(context, request, cq));
    }
    ::grpc::Status GetStore(::grpc::ClientContext* context, const ::openfga::v1::GetStoreRequest& request, ::openfga::v1::GetStoreResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::GetStoreResponse>> AsyncGetStore(::grpc::ClientContext* context, const ::openfga::v1::GetStoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::GetStoreResponse>>(AsyncGetStoreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::GetStoreResponse>> PrepareAsyncGetStore(::grpc::ClientContext* context, const ::openfga::v1::GetStoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::GetStoreResponse>>(PrepareAsyncGetStoreRaw(context, request, cq));
    }
    ::grpc::Status ListStores(::grpc::ClientContext* context, const ::openfga::v1::ListStoresRequest& request, ::openfga::v1::ListStoresResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ListStoresResponse>> AsyncListStores(::grpc::ClientContext* context, const ::openfga::v1::ListStoresRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ListStoresResponse>>(AsyncListStoresRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ListStoresResponse>> PrepareAsyncListStores(::grpc::ClientContext* context, const ::openfga::v1::ListStoresRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ListStoresResponse>>(PrepareAsyncListStoresRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::openfga::v1::StreamedListObjectsResponse>> StreamedListObjects(::grpc::ClientContext* context, const ::openfga::v1::StreamedListObjectsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::openfga::v1::StreamedListObjectsResponse>>(StreamedListObjectsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::openfga::v1::StreamedListObjectsResponse>> AsyncStreamedListObjects(::grpc::ClientContext* context, const ::openfga::v1::StreamedListObjectsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::openfga::v1::StreamedListObjectsResponse>>(AsyncStreamedListObjectsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::openfga::v1::StreamedListObjectsResponse>> PrepareAsyncStreamedListObjects(::grpc::ClientContext* context, const ::openfga::v1::StreamedListObjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::openfga::v1::StreamedListObjectsResponse>>(PrepareAsyncStreamedListObjectsRaw(context, request, cq));
    }
    ::grpc::Status ListObjects(::grpc::ClientContext* context, const ::openfga::v1::ListObjectsRequest& request, ::openfga::v1::ListObjectsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ListObjectsResponse>> AsyncListObjects(::grpc::ClientContext* context, const ::openfga::v1::ListObjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ListObjectsResponse>>(AsyncListObjectsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ListObjectsResponse>> PrepareAsyncListObjects(::grpc::ClientContext* context, const ::openfga::v1::ListObjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ListObjectsResponse>>(PrepareAsyncListObjectsRaw(context, request, cq));
    }
    ::grpc::Status ListUsers(::grpc::ClientContext* context, const ::openfga::v1::ListUsersRequest& request, ::openfga::v1::ListUsersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ListUsersResponse>> AsyncListUsers(::grpc::ClientContext* context, const ::openfga::v1::ListUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ListUsersResponse>>(AsyncListUsersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ListUsersResponse>> PrepareAsyncListUsers(::grpc::ClientContext* context, const ::openfga::v1::ListUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::openfga::v1::ListUsersResponse>>(PrepareAsyncListUsersRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Read(::grpc::ClientContext* context, const ::openfga::v1::ReadRequest* request, ::openfga::v1::ReadResponse* response, std::function<void(::grpc::Status)>) override;
      void Read(::grpc::ClientContext* context, const ::openfga::v1::ReadRequest* request, ::openfga::v1::ReadResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Write(::grpc::ClientContext* context, const ::openfga::v1::WriteRequest* request, ::openfga::v1::WriteResponse* response, std::function<void(::grpc::Status)>) override;
      void Write(::grpc::ClientContext* context, const ::openfga::v1::WriteRequest* request, ::openfga::v1::WriteResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Check(::grpc::ClientContext* context, const ::openfga::v1::CheckRequest* request, ::openfga::v1::CheckResponse* response, std::function<void(::grpc::Status)>) override;
      void Check(::grpc::ClientContext* context, const ::openfga::v1::CheckRequest* request, ::openfga::v1::CheckResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void BatchCheck(::grpc::ClientContext* context, const ::openfga::v1::BatchCheckRequest* request, ::openfga::v1::BatchCheckResponse* response, std::function<void(::grpc::Status)>) override;
      void BatchCheck(::grpc::ClientContext* context, const ::openfga::v1::BatchCheckRequest* request, ::openfga::v1::BatchCheckResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Expand(::grpc::ClientContext* context, const ::openfga::v1::ExpandRequest* request, ::openfga::v1::ExpandResponse* response, std::function<void(::grpc::Status)>) override;
      void Expand(::grpc::ClientContext* context, const ::openfga::v1::ExpandRequest* request, ::openfga::v1::ExpandResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ReadAuthorizationModels(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelsRequest* request, ::openfga::v1::ReadAuthorizationModelsResponse* response, std::function<void(::grpc::Status)>) override;
      void ReadAuthorizationModels(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelsRequest* request, ::openfga::v1::ReadAuthorizationModelsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ReadAuthorizationModel(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelRequest* request, ::openfga::v1::ReadAuthorizationModelResponse* response, std::function<void(::grpc::Status)>) override;
      void ReadAuthorizationModel(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelRequest* request, ::openfga::v1::ReadAuthorizationModelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void WriteAuthorizationModel(::grpc::ClientContext* context, const ::openfga::v1::WriteAuthorizationModelRequest* request, ::openfga::v1::WriteAuthorizationModelResponse* response, std::function<void(::grpc::Status)>) override;
      void WriteAuthorizationModel(::grpc::ClientContext* context, const ::openfga::v1::WriteAuthorizationModelRequest* request, ::openfga::v1::WriteAuthorizationModelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void WriteAssertions(::grpc::ClientContext* context, const ::openfga::v1::WriteAssertionsRequest* request, ::openfga::v1::WriteAssertionsResponse* response, std::function<void(::grpc::Status)>) override;
      void WriteAssertions(::grpc::ClientContext* context, const ::openfga::v1::WriteAssertionsRequest* request, ::openfga::v1::WriteAssertionsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ReadAssertions(::grpc::ClientContext* context, const ::openfga::v1::ReadAssertionsRequest* request, ::openfga::v1::ReadAssertionsResponse* response, std::function<void(::grpc::Status)>) override;
      void ReadAssertions(::grpc::ClientContext* context, const ::openfga::v1::ReadAssertionsRequest* request, ::openfga::v1::ReadAssertionsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ReadChanges(::grpc::ClientContext* context, const ::openfga::v1::ReadChangesRequest* request, ::openfga::v1::ReadChangesResponse* response, std::function<void(::grpc::Status)>) override;
      void ReadChanges(::grpc::ClientContext* context, const ::openfga::v1::ReadChangesRequest* request, ::openfga::v1::ReadChangesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CreateStore(::grpc::ClientContext* context, const ::openfga::v1::CreateStoreRequest* request, ::openfga::v1::CreateStoreResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateStore(::grpc::ClientContext* context, const ::openfga::v1::CreateStoreRequest* request, ::openfga::v1::CreateStoreResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UpdateStore(::grpc::ClientContext* context, const ::openfga::v1::UpdateStoreRequest* request, ::openfga::v1::UpdateStoreResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateStore(::grpc::ClientContext* context, const ::openfga::v1::UpdateStoreRequest* request, ::openfga::v1::UpdateStoreResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DeleteStore(::grpc::ClientContext* context, const ::openfga::v1::DeleteStoreRequest* request, ::openfga::v1::DeleteStoreResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteStore(::grpc::ClientContext* context, const ::openfga::v1::DeleteStoreRequest* request, ::openfga::v1::DeleteStoreResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetStore(::grpc::ClientContext* context, const ::openfga::v1::GetStoreRequest* request, ::openfga::v1::GetStoreResponse* response, std::function<void(::grpc::Status)>) override;
      void GetStore(::grpc::ClientContext* context, const ::openfga::v1::GetStoreRequest* request, ::openfga::v1::GetStoreResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ListStores(::grpc::ClientContext* context, const ::openfga::v1::ListStoresRequest* request, ::openfga::v1::ListStoresResponse* response, std::function<void(::grpc::Status)>) override;
      void ListStores(::grpc::ClientContext* context, const ::openfga::v1::ListStoresRequest* request, ::openfga::v1::ListStoresResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StreamedListObjects(::grpc::ClientContext* context, const ::openfga::v1::StreamedListObjectsRequest* request, ::grpc::ClientReadReactor< ::openfga::v1::StreamedListObjectsResponse>* reactor) override;
      void ListObjects(::grpc::ClientContext* context, const ::openfga::v1::ListObjectsRequest* request, ::openfga::v1::ListObjectsResponse* response, std::function<void(::grpc::Status)>) override;
      void ListObjects(::grpc::ClientContext* context, const ::openfga::v1::ListObjectsRequest* request, ::openfga::v1::ListObjectsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ListUsers(::grpc::ClientContext* context, const ::openfga::v1::ListUsersRequest* request, ::openfga::v1::ListUsersResponse* response, std::function<void(::grpc::Status)>) override;
      void ListUsers(::grpc::ClientContext* context, const ::openfga::v1::ListUsersRequest* request, ::openfga::v1::ListUsersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadResponse>* AsyncReadRaw(::grpc::ClientContext* context, const ::openfga::v1::ReadRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadResponse>* PrepareAsyncReadRaw(::grpc::ClientContext* context, const ::openfga::v1::ReadRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::WriteResponse>* AsyncWriteRaw(::grpc::ClientContext* context, const ::openfga::v1::WriteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::WriteResponse>* PrepareAsyncWriteRaw(::grpc::ClientContext* context, const ::openfga::v1::WriteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::CheckResponse>* AsyncCheckRaw(::grpc::ClientContext* context, const ::openfga::v1::CheckRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::CheckResponse>* PrepareAsyncCheckRaw(::grpc::ClientContext* context, const ::openfga::v1::CheckRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::BatchCheckResponse>* AsyncBatchCheckRaw(::grpc::ClientContext* context, const ::openfga::v1::BatchCheckRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::BatchCheckResponse>* PrepareAsyncBatchCheckRaw(::grpc::ClientContext* context, const ::openfga::v1::BatchCheckRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::ExpandResponse>* AsyncExpandRaw(::grpc::ClientContext* context, const ::openfga::v1::ExpandRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::ExpandResponse>* PrepareAsyncExpandRaw(::grpc::ClientContext* context, const ::openfga::v1::ExpandRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadAuthorizationModelsResponse>* AsyncReadAuthorizationModelsRaw(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadAuthorizationModelsResponse>* PrepareAsyncReadAuthorizationModelsRaw(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadAuthorizationModelResponse>* AsyncReadAuthorizationModelRaw(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadAuthorizationModelResponse>* PrepareAsyncReadAuthorizationModelRaw(::grpc::ClientContext* context, const ::openfga::v1::ReadAuthorizationModelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::WriteAuthorizationModelResponse>* AsyncWriteAuthorizationModelRaw(::grpc::ClientContext* context, const ::openfga::v1::WriteAuthorizationModelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::WriteAuthorizationModelResponse>* PrepareAsyncWriteAuthorizationModelRaw(::grpc::ClientContext* context, const ::openfga::v1::WriteAuthorizationModelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::WriteAssertionsResponse>* AsyncWriteAssertionsRaw(::grpc::ClientContext* context, const ::openfga::v1::WriteAssertionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::WriteAssertionsResponse>* PrepareAsyncWriteAssertionsRaw(::grpc::ClientContext* context, const ::openfga::v1::WriteAssertionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadAssertionsResponse>* AsyncReadAssertionsRaw(::grpc::ClientContext* context, const ::openfga::v1::ReadAssertionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadAssertionsResponse>* PrepareAsyncReadAssertionsRaw(::grpc::ClientContext* context, const ::openfga::v1::ReadAssertionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadChangesResponse>* AsyncReadChangesRaw(::grpc::ClientContext* context, const ::openfga::v1::ReadChangesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::ReadChangesResponse>* PrepareAsyncReadChangesRaw(::grpc::ClientContext* context, const ::openfga::v1::ReadChangesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::CreateStoreResponse>* AsyncCreateStoreRaw(::grpc::ClientContext* context, const ::openfga::v1::CreateStoreRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::CreateStoreResponse>* PrepareAsyncCreateStoreRaw(::grpc::ClientContext* context, const ::openfga::v1::CreateStoreRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::UpdateStoreResponse>* AsyncUpdateStoreRaw(::grpc::ClientContext* context, const ::openfga::v1::UpdateStoreRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::UpdateStoreResponse>* PrepareAsyncUpdateStoreRaw(::grpc::ClientContext* context, const ::openfga::v1::UpdateStoreRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::DeleteStoreResponse>* AsyncDeleteStoreRaw(::grpc::ClientContext* context, const ::openfga::v1::DeleteStoreRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::DeleteStoreResponse>* PrepareAsyncDeleteStoreRaw(::grpc::ClientContext* context, const ::openfga::v1::DeleteStoreRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::GetStoreResponse>* AsyncGetStoreRaw(::grpc::ClientContext* context, const ::openfga::v1::GetStoreRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::GetStoreResponse>* PrepareAsyncGetStoreRaw(::grpc::ClientContext* context, const ::openfga::v1::GetStoreRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::ListStoresResponse>* AsyncListStoresRaw(::grpc::ClientContext* context, const ::openfga::v1::ListStoresRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::ListStoresResponse>* PrepareAsyncListStoresRaw(::grpc::ClientContext* context, const ::openfga::v1::ListStoresRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::openfga::v1::StreamedListObjectsResponse>* StreamedListObjectsRaw(::grpc::ClientContext* context, const ::openfga::v1::StreamedListObjectsRequest& request) override;
    ::grpc::ClientAsyncReader< ::openfga::v1::StreamedListObjectsResponse>* AsyncStreamedListObjectsRaw(::grpc::ClientContext* context, const ::openfga::v1::StreamedListObjectsRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::openfga::v1::StreamedListObjectsResponse>* PrepareAsyncStreamedListObjectsRaw(::grpc::ClientContext* context, const ::openfga::v1::StreamedListObjectsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::ListObjectsResponse>* AsyncListObjectsRaw(::grpc::ClientContext* context, const ::openfga::v1::ListObjectsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::ListObjectsResponse>* PrepareAsyncListObjectsRaw(::grpc::ClientContext* context, const ::openfga::v1::ListObjectsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::ListUsersResponse>* AsyncListUsersRaw(::grpc::ClientContext* context, const ::openfga::v1::ListUsersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::openfga::v1::ListUsersResponse>* PrepareAsyncListUsersRaw(::grpc::ClientContext* context, const ::openfga::v1::ListUsersRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Read_;
    const ::grpc::internal::RpcMethod rpcmethod_Write_;
    const ::grpc::internal::RpcMethod rpcmethod_Check_;
    const ::grpc::internal::RpcMethod rpcmethod_BatchCheck_;
    const ::grpc::internal::RpcMethod rpcmethod_Expand_;
    const ::grpc::internal::RpcMethod rpcmethod_ReadAuthorizationModels_;
    const ::grpc::internal::RpcMethod rpcmethod_ReadAuthorizationModel_;
    const ::grpc::internal::RpcMethod rpcmethod_WriteAuthorizationModel_;
    const ::grpc::internal::RpcMethod rpcmethod_WriteAssertions_;
    const ::grpc::internal::RpcMethod rpcmethod_ReadAssertions_;
    const ::grpc::internal::RpcMethod rpcmethod_ReadChanges_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateStore_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateStore_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteStore_;
    const ::grpc::internal::RpcMethod rpcmethod_GetStore_;
    const ::grpc::internal::RpcMethod rpcmethod_ListStores_;
    const ::grpc::internal::RpcMethod rpcmethod_StreamedListObjects_;
    const ::grpc::internal::RpcMethod rpcmethod_ListObjects_;
    const ::grpc::internal::RpcMethod rpcmethod_ListUsers_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Read(::grpc::ServerContext* context, const ::openfga::v1::ReadRequest* request, ::openfga::v1::ReadResponse* response);
    virtual ::grpc::Status Write(::grpc::ServerContext* context, const ::openfga::v1::WriteRequest* request, ::openfga::v1::WriteResponse* response);
    virtual ::grpc::Status Check(::grpc::ServerContext* context, const ::openfga::v1::CheckRequest* request, ::openfga::v1::CheckResponse* response);
    virtual ::grpc::Status BatchCheck(::grpc::ServerContext* context, const ::openfga::v1::BatchCheckRequest* request, ::openfga::v1::BatchCheckResponse* response);
    virtual ::grpc::Status Expand(::grpc::ServerContext* context, const ::openfga::v1::ExpandRequest* request, ::openfga::v1::ExpandResponse* response);
    virtual ::grpc::Status ReadAuthorizationModels(::grpc::ServerContext* context, const ::openfga::v1::ReadAuthorizationModelsRequest* request, ::openfga::v1::ReadAuthorizationModelsResponse* response);
    virtual ::grpc::Status ReadAuthorizationModel(::grpc::ServerContext* context, const ::openfga::v1::ReadAuthorizationModelRequest* request, ::openfga::v1::ReadAuthorizationModelResponse* response);
    virtual ::grpc::Status WriteAuthorizationModel(::grpc::ServerContext* context, const ::openfga::v1::WriteAuthorizationModelRequest* request, ::openfga::v1::WriteAuthorizationModelResponse* response);
    virtual ::grpc::Status WriteAssertions(::grpc::ServerContext* context, const ::openfga::v1::WriteAssertionsRequest* request, ::openfga::v1::WriteAssertionsResponse* response);
    virtual ::grpc::Status ReadAssertions(::grpc::ServerContext* context, const ::openfga::v1::ReadAssertionsRequest* request, ::openfga::v1::ReadAssertionsResponse* response);
    virtual ::grpc::Status ReadChanges(::grpc::ServerContext* context, const ::openfga::v1::ReadChangesRequest* request, ::openfga::v1::ReadChangesResponse* response);
    virtual ::grpc::Status CreateStore(::grpc::ServerContext* context, const ::openfga::v1::CreateStoreRequest* request, ::openfga::v1::CreateStoreResponse* response);
    virtual ::grpc::Status UpdateStore(::grpc::ServerContext* context, const ::openfga::v1::UpdateStoreRequest* request, ::openfga::v1::UpdateStoreResponse* response);
    virtual ::grpc::Status DeleteStore(::grpc::ServerContext* context, const ::openfga::v1::DeleteStoreRequest* request, ::openfga::v1::DeleteStoreResponse* response);
    virtual ::grpc::Status GetStore(::grpc::ServerContext* context, const ::openfga::v1::GetStoreRequest* request, ::openfga::v1::GetStoreResponse* response);
    virtual ::grpc::Status ListStores(::grpc::ServerContext* context, const ::openfga::v1::ListStoresRequest* request, ::openfga::v1::ListStoresResponse* response);
    virtual ::grpc::Status StreamedListObjects(::grpc::ServerContext* context, const ::openfga::v1::StreamedListObjectsRequest* request, ::grpc::ServerWriter< ::openfga::v1::StreamedListObjectsResponse>* writer);
    virtual ::grpc::Status ListObjects(::grpc::ServerContext* context, const ::openfga::v1::ListObjectsRequest* request, ::openfga::v1::ListObjectsResponse* response);
    virtual ::grpc::Status ListUsers(::grpc::ServerContext* context, const ::openfga::v1::ListUsersRequest* request, ::openfga::v1::ListUsersResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Read() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Read(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadRequest* /*request*/, ::openfga::v1::ReadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRead(::grpc::ServerContext* context, ::openfga::v1::ReadRequest* request, ::grpc::ServerAsyncResponseWriter< ::openfga::v1::ReadResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Write() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Write(::grpc::ServerContext* /*context*/, const ::openfga::v1::WriteRequest* /*request*/, ::openfga::v1::WriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWrite(::grpc::ServerContext* context, ::openfga::v1::WriteRequest* request, ::grpc::ServerAsyncResponseWriter< ::openfga::v1::WriteResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Check() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::openfga::v1::CheckRequest* /*request*/, ::openfga::v1::CheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheck(::grpc::ServerContext* context, ::openfga::v1::CheckRequest* request, ::grpc::ServerAsyncResponseWriter< ::openfga::v1::CheckResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BatchCheck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BatchCheck() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_BatchCheck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCheck(::grpc::ServerContext* /*context*/, const ::openfga::v1::BatchCheckRequest* /*request*/, ::openfga::v1::BatchCheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchCheck(::grpc::ServerContext* context, ::openfga::v1::BatchCheckRequest* request, ::grpc::ServerAsyncResponseWriter< ::openfga::v1::BatchCheckResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Expand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Expand() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_Expand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Expand(::grpc::ServerContext* /*context*/, const ::openfga::v1::ExpandRequest* /*request*/, ::openfga::v1::ExpandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExpand(::grpc::ServerContext* context, ::openfga::v1::ExpandRequest* request, ::grpc::ServerAsyncResponseWriter< ::openfga::v1::ExpandResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ReadAuthorizationModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReadAuthorizationModels() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_ReadAuthorizationModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadAuthorizationModels(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadAuthorizationModelsRequest* /*request*/, ::openfga::v1::ReadAuthorizationModelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadAuthorizationModels(::grpc::ServerContext* context, ::openfga::v1::ReadAuthorizationModelsRequest* request, ::grpc::ServerAsyncResponseWriter< ::openfga::v1::ReadAuthorizationModelsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ReadAuthorizationModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReadAuthorizationModel() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_ReadAuthorizationModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadAuthorizationModel(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadAuthorizationModelRequest* /*request*/, ::openfga::v1::ReadAuthorizationModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadAuthorizationModel(::grpc::ServerContext* context, ::openfga::v1::ReadAuthorizationModelRequest* request, ::grpc::ServerAsyncResponseWriter< ::openfga::v1::ReadAuthorizationModelResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WriteAuthorizationModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WriteAuthorizationModel() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_WriteAuthorizationModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteAuthorizationModel(::grpc::ServerContext* /*context*/, const ::openfga::v1::WriteAuthorizationModelRequest* /*request*/, ::openfga::v1::WriteAuthorizationModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWriteAuthorizationModel(::grpc::ServerContext* context, ::openfga::v1::WriteAuthorizationModelRequest* request, ::grpc::ServerAsyncResponseWriter< ::openfga::v1::WriteAuthorizationModelResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WriteAssertions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WriteAssertions() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_WriteAssertions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteAssertions(::grpc::ServerContext* /*context*/, const ::openfga::v1::WriteAssertionsRequest* /*request*/, ::openfga::v1::WriteAssertionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWriteAssertions(::grpc::ServerContext* context, ::openfga::v1::WriteAssertionsRequest* request, ::grpc::ServerAsyncResponseWriter< ::openfga::v1::WriteAssertionsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ReadAssertions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReadAssertions() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_ReadAssertions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadAssertions(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadAssertionsRequest* /*request*/, ::openfga::v1::ReadAssertionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadAssertions(::grpc::ServerContext* context, ::openfga::v1::ReadAssertionsRequest* request, ::grpc::ServerAsyncResponseWriter< ::openfga::v1::ReadAssertionsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ReadChanges : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReadChanges() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_ReadChanges() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadChanges(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadChangesRequest* /*request*/, ::openfga::v1::ReadChangesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadChanges(::grpc::ServerContext* context, ::openfga::v1::ReadChangesRequest* request, ::grpc::ServerAsyncResponseWriter< ::openfga::v1::ReadChangesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateStore() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_CreateStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateStore(::grpc::ServerContext* /*context*/, const ::openfga::v1::CreateStoreRequest* /*request*/, ::openfga::v1::CreateStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateStore(::grpc::ServerContext* context, ::openfga::v1::CreateStoreRequest* request, ::grpc::ServerAsyncResponseWriter< ::openfga::v1::CreateStoreResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateStore() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_UpdateStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateStore(::grpc::ServerContext* /*context*/, const ::openfga::v1::UpdateStoreRequest* /*request*/, ::openfga::v1::UpdateStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateStore(::grpc::ServerContext* context, ::openfga::v1::UpdateStoreRequest* request, ::grpc::ServerAsyncResponseWriter< ::openfga::v1::UpdateStoreResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteStore() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_DeleteStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteStore(::grpc::ServerContext* /*context*/, const ::openfga::v1::DeleteStoreRequest* /*request*/, ::openfga::v1::DeleteStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteStore(::grpc::ServerContext* context, ::openfga::v1::DeleteStoreRequest* request, ::grpc::ServerAsyncResponseWriter< ::openfga::v1::DeleteStoreResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetStore() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_GetStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStore(::grpc::ServerContext* /*context*/, const ::openfga::v1::GetStoreRequest* /*request*/, ::openfga::v1::GetStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStore(::grpc::ServerContext* context, ::openfga::v1::GetStoreRequest* request, ::grpc::ServerAsyncResponseWriter< ::openfga::v1::GetStoreResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListStores : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListStores() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_ListStores() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListStores(::grpc::ServerContext* /*context*/, const ::openfga::v1::ListStoresRequest* /*request*/, ::openfga::v1::ListStoresResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListStores(::grpc::ServerContext* context, ::openfga::v1::ListStoresRequest* request, ::grpc::ServerAsyncResponseWriter< ::openfga::v1::ListStoresResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StreamedListObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StreamedListObjects() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_StreamedListObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamedListObjects(::grpc::ServerContext* /*context*/, const ::openfga::v1::StreamedListObjectsRequest* /*request*/, ::grpc::ServerWriter< ::openfga::v1::StreamedListObjectsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamedListObjects(::grpc::ServerContext* context, ::openfga::v1::StreamedListObjectsRequest* request, ::grpc::ServerAsyncWriter< ::openfga::v1::StreamedListObjectsResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(16, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListObjects() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_ListObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListObjects(::grpc::ServerContext* /*context*/, const ::openfga::v1::ListObjectsRequest* /*request*/, ::openfga::v1::ListObjectsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListObjects(::grpc::ServerContext* context, ::openfga::v1::ListObjectsRequest* request, ::grpc::ServerAsyncResponseWriter< ::openfga::v1::ListObjectsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListUsers() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_ListUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListUsers(::grpc::ServerContext* /*context*/, const ::openfga::v1::ListUsersRequest* /*request*/, ::openfga::v1::ListUsersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListUsers(::grpc::ServerContext* context, ::openfga::v1::ListUsersRequest* request, ::grpc::ServerAsyncResponseWriter< ::openfga::v1::ListUsersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Read<WithAsyncMethod_Write<WithAsyncMethod_Check<WithAsyncMethod_BatchCheck<WithAsyncMethod_Expand<WithAsyncMethod_ReadAuthorizationModels<WithAsyncMethod_ReadAuthorizationModel<WithAsyncMethod_WriteAuthorizationModel<WithAsyncMethod_WriteAssertions<WithAsyncMethod_ReadAssertions<WithAsyncMethod_ReadChanges<WithAsyncMethod_CreateStore<WithAsyncMethod_UpdateStore<WithAsyncMethod_DeleteStore<WithAsyncMethod_GetStore<WithAsyncMethod_ListStores<WithAsyncMethod_StreamedListObjects<WithAsyncMethod_ListObjects<WithAsyncMethod_ListUsers<Service > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Read() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::openfga::v1::ReadRequest, ::openfga::v1::ReadResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::openfga::v1::ReadRequest* request, ::openfga::v1::ReadResponse* response) { return this->Read(context, request, response); }));}
    void SetMessageAllocatorFor_Read(
        ::grpc::MessageAllocator< ::openfga::v1::ReadRequest, ::openfga::v1::ReadResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::openfga::v1::ReadRequest, ::openfga::v1::ReadResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Read(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadRequest* /*request*/, ::openfga::v1::ReadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Read(
      ::grpc::CallbackServerContext* /*context*/, const ::openfga::v1::ReadRequest* /*request*/, ::openfga::v1::ReadResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Write() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::openfga::v1::WriteRequest, ::openfga::v1::WriteResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::openfga::v1::WriteRequest* request, ::openfga::v1::WriteResponse* response) { return this->Write(context, request, response); }));}
    void SetMessageAllocatorFor_Write(
        ::grpc::MessageAllocator< ::openfga::v1::WriteRequest, ::openfga::v1::WriteResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::openfga::v1::WriteRequest, ::openfga::v1::WriteResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Write(::grpc::ServerContext* /*context*/, const ::openfga::v1::WriteRequest* /*request*/, ::openfga::v1::WriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Write(
      ::grpc::CallbackServerContext* /*context*/, const ::openfga::v1::WriteRequest* /*request*/, ::openfga::v1::WriteResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Check() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::openfga::v1::CheckRequest, ::openfga::v1::CheckResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::openfga::v1::CheckRequest* request, ::openfga::v1::CheckResponse* response) { return this->Check(context, request, response); }));}
    void SetMessageAllocatorFor_Check(
        ::grpc::MessageAllocator< ::openfga::v1::CheckRequest, ::openfga::v1::CheckResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::openfga::v1::CheckRequest, ::openfga::v1::CheckResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::openfga::v1::CheckRequest* /*request*/, ::openfga::v1::CheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Check(
      ::grpc::CallbackServerContext* /*context*/, const ::openfga::v1::CheckRequest* /*request*/, ::openfga::v1::CheckResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_BatchCheck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_BatchCheck() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::openfga::v1::BatchCheckRequest, ::openfga::v1::BatchCheckResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::openfga::v1::BatchCheckRequest* request, ::openfga::v1::BatchCheckResponse* response) { return this->BatchCheck(context, request, response); }));}
    void SetMessageAllocatorFor_BatchCheck(
        ::grpc::MessageAllocator< ::openfga::v1::BatchCheckRequest, ::openfga::v1::BatchCheckResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::openfga::v1::BatchCheckRequest, ::openfga::v1::BatchCheckResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_BatchCheck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCheck(::grpc::ServerContext* /*context*/, const ::openfga::v1::BatchCheckRequest* /*request*/, ::openfga::v1::BatchCheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BatchCheck(
      ::grpc::CallbackServerContext* /*context*/, const ::openfga::v1::BatchCheckRequest* /*request*/, ::openfga::v1::BatchCheckResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Expand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Expand() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::openfga::v1::ExpandRequest, ::openfga::v1::ExpandResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::openfga::v1::ExpandRequest* request, ::openfga::v1::ExpandResponse* response) { return this->Expand(context, request, response); }));}
    void SetMessageAllocatorFor_Expand(
        ::grpc::MessageAllocator< ::openfga::v1::ExpandRequest, ::openfga::v1::ExpandResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::openfga::v1::ExpandRequest, ::openfga::v1::ExpandResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Expand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Expand(::grpc::ServerContext* /*context*/, const ::openfga::v1::ExpandRequest* /*request*/, ::openfga::v1::ExpandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Expand(
      ::grpc::CallbackServerContext* /*context*/, const ::openfga::v1::ExpandRequest* /*request*/, ::openfga::v1::ExpandResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ReadAuthorizationModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ReadAuthorizationModels() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::openfga::v1::ReadAuthorizationModelsRequest, ::openfga::v1::ReadAuthorizationModelsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::openfga::v1::ReadAuthorizationModelsRequest* request, ::openfga::v1::ReadAuthorizationModelsResponse* response) { return this->ReadAuthorizationModels(context, request, response); }));}
    void SetMessageAllocatorFor_ReadAuthorizationModels(
        ::grpc::MessageAllocator< ::openfga::v1::ReadAuthorizationModelsRequest, ::openfga::v1::ReadAuthorizationModelsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::openfga::v1::ReadAuthorizationModelsRequest, ::openfga::v1::ReadAuthorizationModelsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ReadAuthorizationModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadAuthorizationModels(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadAuthorizationModelsRequest* /*request*/, ::openfga::v1::ReadAuthorizationModelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReadAuthorizationModels(
      ::grpc::CallbackServerContext* /*context*/, const ::openfga::v1::ReadAuthorizationModelsRequest* /*request*/, ::openfga::v1::ReadAuthorizationModelsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ReadAuthorizationModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ReadAuthorizationModel() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::openfga::v1::ReadAuthorizationModelRequest, ::openfga::v1::ReadAuthorizationModelResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::openfga::v1::ReadAuthorizationModelRequest* request, ::openfga::v1::ReadAuthorizationModelResponse* response) { return this->ReadAuthorizationModel(context, request, response); }));}
    void SetMessageAllocatorFor_ReadAuthorizationModel(
        ::grpc::MessageAllocator< ::openfga::v1::ReadAuthorizationModelRequest, ::openfga::v1::ReadAuthorizationModelResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::openfga::v1::ReadAuthorizationModelRequest, ::openfga::v1::ReadAuthorizationModelResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ReadAuthorizationModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadAuthorizationModel(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadAuthorizationModelRequest* /*request*/, ::openfga::v1::ReadAuthorizationModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReadAuthorizationModel(
      ::grpc::CallbackServerContext* /*context*/, const ::openfga::v1::ReadAuthorizationModelRequest* /*request*/, ::openfga::v1::ReadAuthorizationModelResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_WriteAuthorizationModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_WriteAuthorizationModel() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::openfga::v1::WriteAuthorizationModelRequest, ::openfga::v1::WriteAuthorizationModelResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::openfga::v1::WriteAuthorizationModelRequest* request, ::openfga::v1::WriteAuthorizationModelResponse* response) { return this->WriteAuthorizationModel(context, request, response); }));}
    void SetMessageAllocatorFor_WriteAuthorizationModel(
        ::grpc::MessageAllocator< ::openfga::v1::WriteAuthorizationModelRequest, ::openfga::v1::WriteAuthorizationModelResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::openfga::v1::WriteAuthorizationModelRequest, ::openfga::v1::WriteAuthorizationModelResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_WriteAuthorizationModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteAuthorizationModel(::grpc::ServerContext* /*context*/, const ::openfga::v1::WriteAuthorizationModelRequest* /*request*/, ::openfga::v1::WriteAuthorizationModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WriteAuthorizationModel(
      ::grpc::CallbackServerContext* /*context*/, const ::openfga::v1::WriteAuthorizationModelRequest* /*request*/, ::openfga::v1::WriteAuthorizationModelResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_WriteAssertions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_WriteAssertions() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::openfga::v1::WriteAssertionsRequest, ::openfga::v1::WriteAssertionsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::openfga::v1::WriteAssertionsRequest* request, ::openfga::v1::WriteAssertionsResponse* response) { return this->WriteAssertions(context, request, response); }));}
    void SetMessageAllocatorFor_WriteAssertions(
        ::grpc::MessageAllocator< ::openfga::v1::WriteAssertionsRequest, ::openfga::v1::WriteAssertionsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::openfga::v1::WriteAssertionsRequest, ::openfga::v1::WriteAssertionsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_WriteAssertions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteAssertions(::grpc::ServerContext* /*context*/, const ::openfga::v1::WriteAssertionsRequest* /*request*/, ::openfga::v1::WriteAssertionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WriteAssertions(
      ::grpc::CallbackServerContext* /*context*/, const ::openfga::v1::WriteAssertionsRequest* /*request*/, ::openfga::v1::WriteAssertionsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ReadAssertions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ReadAssertions() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::openfga::v1::ReadAssertionsRequest, ::openfga::v1::ReadAssertionsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::openfga::v1::ReadAssertionsRequest* request, ::openfga::v1::ReadAssertionsResponse* response) { return this->ReadAssertions(context, request, response); }));}
    void SetMessageAllocatorFor_ReadAssertions(
        ::grpc::MessageAllocator< ::openfga::v1::ReadAssertionsRequest, ::openfga::v1::ReadAssertionsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::openfga::v1::ReadAssertionsRequest, ::openfga::v1::ReadAssertionsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ReadAssertions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadAssertions(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadAssertionsRequest* /*request*/, ::openfga::v1::ReadAssertionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReadAssertions(
      ::grpc::CallbackServerContext* /*context*/, const ::openfga::v1::ReadAssertionsRequest* /*request*/, ::openfga::v1::ReadAssertionsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ReadChanges : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ReadChanges() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::openfga::v1::ReadChangesRequest, ::openfga::v1::ReadChangesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::openfga::v1::ReadChangesRequest* request, ::openfga::v1::ReadChangesResponse* response) { return this->ReadChanges(context, request, response); }));}
    void SetMessageAllocatorFor_ReadChanges(
        ::grpc::MessageAllocator< ::openfga::v1::ReadChangesRequest, ::openfga::v1::ReadChangesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::openfga::v1::ReadChangesRequest, ::openfga::v1::ReadChangesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ReadChanges() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadChanges(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadChangesRequest* /*request*/, ::openfga::v1::ReadChangesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReadChanges(
      ::grpc::CallbackServerContext* /*context*/, const ::openfga::v1::ReadChangesRequest* /*request*/, ::openfga::v1::ReadChangesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CreateStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CreateStore() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::openfga::v1::CreateStoreRequest, ::openfga::v1::CreateStoreResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::openfga::v1::CreateStoreRequest* request, ::openfga::v1::CreateStoreResponse* response) { return this->CreateStore(context, request, response); }));}
    void SetMessageAllocatorFor_CreateStore(
        ::grpc::MessageAllocator< ::openfga::v1::CreateStoreRequest, ::openfga::v1::CreateStoreResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::openfga::v1::CreateStoreRequest, ::openfga::v1::CreateStoreResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CreateStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateStore(::grpc::ServerContext* /*context*/, const ::openfga::v1::CreateStoreRequest* /*request*/, ::openfga::v1::CreateStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateStore(
      ::grpc::CallbackServerContext* /*context*/, const ::openfga::v1::CreateStoreRequest* /*request*/, ::openfga::v1::CreateStoreResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UpdateStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UpdateStore() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::openfga::v1::UpdateStoreRequest, ::openfga::v1::UpdateStoreResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::openfga::v1::UpdateStoreRequest* request, ::openfga::v1::UpdateStoreResponse* response) { return this->UpdateStore(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateStore(
        ::grpc::MessageAllocator< ::openfga::v1::UpdateStoreRequest, ::openfga::v1::UpdateStoreResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::openfga::v1::UpdateStoreRequest, ::openfga::v1::UpdateStoreResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UpdateStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateStore(::grpc::ServerContext* /*context*/, const ::openfga::v1::UpdateStoreRequest* /*request*/, ::openfga::v1::UpdateStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateStore(
      ::grpc::CallbackServerContext* /*context*/, const ::openfga::v1::UpdateStoreRequest* /*request*/, ::openfga::v1::UpdateStoreResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DeleteStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DeleteStore() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::openfga::v1::DeleteStoreRequest, ::openfga::v1::DeleteStoreResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::openfga::v1::DeleteStoreRequest* request, ::openfga::v1::DeleteStoreResponse* response) { return this->DeleteStore(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteStore(
        ::grpc::MessageAllocator< ::openfga::v1::DeleteStoreRequest, ::openfga::v1::DeleteStoreResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::openfga::v1::DeleteStoreRequest, ::openfga::v1::DeleteStoreResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DeleteStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteStore(::grpc::ServerContext* /*context*/, const ::openfga::v1::DeleteStoreRequest* /*request*/, ::openfga::v1::DeleteStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteStore(
      ::grpc::CallbackServerContext* /*context*/, const ::openfga::v1::DeleteStoreRequest* /*request*/, ::openfga::v1::DeleteStoreResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetStore() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::openfga::v1::GetStoreRequest, ::openfga::v1::GetStoreResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::openfga::v1::GetStoreRequest* request, ::openfga::v1::GetStoreResponse* response) { return this->GetStore(context, request, response); }));}
    void SetMessageAllocatorFor_GetStore(
        ::grpc::MessageAllocator< ::openfga::v1::GetStoreRequest, ::openfga::v1::GetStoreResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::openfga::v1::GetStoreRequest, ::openfga::v1::GetStoreResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStore(::grpc::ServerContext* /*context*/, const ::openfga::v1::GetStoreRequest* /*request*/, ::openfga::v1::GetStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetStore(
      ::grpc::CallbackServerContext* /*context*/, const ::openfga::v1::GetStoreRequest* /*request*/, ::openfga::v1::GetStoreResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListStores : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListStores() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::openfga::v1::ListStoresRequest, ::openfga::v1::ListStoresResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::openfga::v1::ListStoresRequest* request, ::openfga::v1::ListStoresResponse* response) { return this->ListStores(context, request, response); }));}
    void SetMessageAllocatorFor_ListStores(
        ::grpc::MessageAllocator< ::openfga::v1::ListStoresRequest, ::openfga::v1::ListStoresResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::openfga::v1::ListStoresRequest, ::openfga::v1::ListStoresResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListStores() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListStores(::grpc::ServerContext* /*context*/, const ::openfga::v1::ListStoresRequest* /*request*/, ::openfga::v1::ListStoresResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListStores(
      ::grpc::CallbackServerContext* /*context*/, const ::openfga::v1::ListStoresRequest* /*request*/, ::openfga::v1::ListStoresResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StreamedListObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StreamedListObjects() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackServerStreamingHandler< ::openfga::v1::StreamedListObjectsRequest, ::openfga::v1::StreamedListObjectsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::openfga::v1::StreamedListObjectsRequest* request) { return this->StreamedListObjects(context, request); }));
    }
    ~WithCallbackMethod_StreamedListObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamedListObjects(::grpc::ServerContext* /*context*/, const ::openfga::v1::StreamedListObjectsRequest* /*request*/, ::grpc::ServerWriter< ::openfga::v1::StreamedListObjectsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::openfga::v1::StreamedListObjectsResponse>* StreamedListObjects(
      ::grpc::CallbackServerContext* /*context*/, const ::openfga::v1::StreamedListObjectsRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListObjects() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::openfga::v1::ListObjectsRequest, ::openfga::v1::ListObjectsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::openfga::v1::ListObjectsRequest* request, ::openfga::v1::ListObjectsResponse* response) { return this->ListObjects(context, request, response); }));}
    void SetMessageAllocatorFor_ListObjects(
        ::grpc::MessageAllocator< ::openfga::v1::ListObjectsRequest, ::openfga::v1::ListObjectsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::openfga::v1::ListObjectsRequest, ::openfga::v1::ListObjectsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListObjects(::grpc::ServerContext* /*context*/, const ::openfga::v1::ListObjectsRequest* /*request*/, ::openfga::v1::ListObjectsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListObjects(
      ::grpc::CallbackServerContext* /*context*/, const ::openfga::v1::ListObjectsRequest* /*request*/, ::openfga::v1::ListObjectsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListUsers() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::openfga::v1::ListUsersRequest, ::openfga::v1::ListUsersResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::openfga::v1::ListUsersRequest* request, ::openfga::v1::ListUsersResponse* response) { return this->ListUsers(context, request, response); }));}
    void SetMessageAllocatorFor_ListUsers(
        ::grpc::MessageAllocator< ::openfga::v1::ListUsersRequest, ::openfga::v1::ListUsersResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::openfga::v1::ListUsersRequest, ::openfga::v1::ListUsersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListUsers(::grpc::ServerContext* /*context*/, const ::openfga::v1::ListUsersRequest* /*request*/, ::openfga::v1::ListUsersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListUsers(
      ::grpc::CallbackServerContext* /*context*/, const ::openfga::v1::ListUsersRequest* /*request*/, ::openfga::v1::ListUsersResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Read<WithCallbackMethod_Write<WithCallbackMethod_Check<WithCallbackMethod_BatchCheck<WithCallbackMethod_Expand<WithCallbackMethod_ReadAuthorizationModels<WithCallbackMethod_ReadAuthorizationModel<WithCallbackMethod_WriteAuthorizationModel<WithCallbackMethod_WriteAssertions<WithCallbackMethod_ReadAssertions<WithCallbackMethod_ReadChanges<WithCallbackMethod_CreateStore<WithCallbackMethod_UpdateStore<WithCallbackMethod_DeleteStore<WithCallbackMethod_GetStore<WithCallbackMethod_ListStores<WithCallbackMethod_StreamedListObjects<WithCallbackMethod_ListObjects<WithCallbackMethod_ListUsers<Service > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Read() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Read(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadRequest* /*request*/, ::openfga::v1::ReadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Write() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Write(::grpc::ServerContext* /*context*/, const ::openfga::v1::WriteRequest* /*request*/, ::openfga::v1::WriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Check() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::openfga::v1::CheckRequest* /*request*/, ::openfga::v1::CheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BatchCheck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BatchCheck() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_BatchCheck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCheck(::grpc::ServerContext* /*context*/, const ::openfga::v1::BatchCheckRequest* /*request*/, ::openfga::v1::BatchCheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Expand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Expand() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_Expand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Expand(::grpc::ServerContext* /*context*/, const ::openfga::v1::ExpandRequest* /*request*/, ::openfga::v1::ExpandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ReadAuthorizationModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReadAuthorizationModels() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_ReadAuthorizationModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadAuthorizationModels(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadAuthorizationModelsRequest* /*request*/, ::openfga::v1::ReadAuthorizationModelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ReadAuthorizationModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReadAuthorizationModel() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_ReadAuthorizationModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadAuthorizationModel(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadAuthorizationModelRequest* /*request*/, ::openfga::v1::ReadAuthorizationModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WriteAuthorizationModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WriteAuthorizationModel() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_WriteAuthorizationModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteAuthorizationModel(::grpc::ServerContext* /*context*/, const ::openfga::v1::WriteAuthorizationModelRequest* /*request*/, ::openfga::v1::WriteAuthorizationModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WriteAssertions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WriteAssertions() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_WriteAssertions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteAssertions(::grpc::ServerContext* /*context*/, const ::openfga::v1::WriteAssertionsRequest* /*request*/, ::openfga::v1::WriteAssertionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ReadAssertions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReadAssertions() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_ReadAssertions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadAssertions(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadAssertionsRequest* /*request*/, ::openfga::v1::ReadAssertionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ReadChanges : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReadChanges() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_ReadChanges() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadChanges(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadChangesRequest* /*request*/, ::openfga::v1::ReadChangesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateStore() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_CreateStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateStore(::grpc::ServerContext* /*context*/, const ::openfga::v1::CreateStoreRequest* /*request*/, ::openfga::v1::CreateStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateStore() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_UpdateStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateStore(::grpc::ServerContext* /*context*/, const ::openfga::v1::UpdateStoreRequest* /*request*/, ::openfga::v1::UpdateStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteStore() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_DeleteStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteStore(::grpc::ServerContext* /*context*/, const ::openfga::v1::DeleteStoreRequest* /*request*/, ::openfga::v1::DeleteStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetStore() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_GetStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStore(::grpc::ServerContext* /*context*/, const ::openfga::v1::GetStoreRequest* /*request*/, ::openfga::v1::GetStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListStores : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListStores() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_ListStores() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListStores(::grpc::ServerContext* /*context*/, const ::openfga::v1::ListStoresRequest* /*request*/, ::openfga::v1::ListStoresResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StreamedListObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StreamedListObjects() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_StreamedListObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamedListObjects(::grpc::ServerContext* /*context*/, const ::openfga::v1::StreamedListObjectsRequest* /*request*/, ::grpc::ServerWriter< ::openfga::v1::StreamedListObjectsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListObjects() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_ListObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListObjects(::grpc::ServerContext* /*context*/, const ::openfga::v1::ListObjectsRequest* /*request*/, ::openfga::v1::ListObjectsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListUsers() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_ListUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListUsers(::grpc::ServerContext* /*context*/, const ::openfga::v1::ListUsersRequest* /*request*/, ::openfga::v1::ListUsersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Read() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Read(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadRequest* /*request*/, ::openfga::v1::ReadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRead(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Write() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Write(::grpc::ServerContext* /*context*/, const ::openfga::v1::WriteRequest* /*request*/, ::openfga::v1::WriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWrite(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Check() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::openfga::v1::CheckRequest* /*request*/, ::openfga::v1::CheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheck(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BatchCheck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BatchCheck() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_BatchCheck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCheck(::grpc::ServerContext* /*context*/, const ::openfga::v1::BatchCheckRequest* /*request*/, ::openfga::v1::BatchCheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchCheck(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Expand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Expand() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_Expand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Expand(::grpc::ServerContext* /*context*/, const ::openfga::v1::ExpandRequest* /*request*/, ::openfga::v1::ExpandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExpand(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReadAuthorizationModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReadAuthorizationModels() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_ReadAuthorizationModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadAuthorizationModels(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadAuthorizationModelsRequest* /*request*/, ::openfga::v1::ReadAuthorizationModelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadAuthorizationModels(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReadAuthorizationModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReadAuthorizationModel() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_ReadAuthorizationModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadAuthorizationModel(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadAuthorizationModelRequest* /*request*/, ::openfga::v1::ReadAuthorizationModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadAuthorizationModel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WriteAuthorizationModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WriteAuthorizationModel() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_WriteAuthorizationModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteAuthorizationModel(::grpc::ServerContext* /*context*/, const ::openfga::v1::WriteAuthorizationModelRequest* /*request*/, ::openfga::v1::WriteAuthorizationModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWriteAuthorizationModel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WriteAssertions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WriteAssertions() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_WriteAssertions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteAssertions(::grpc::ServerContext* /*context*/, const ::openfga::v1::WriteAssertionsRequest* /*request*/, ::openfga::v1::WriteAssertionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWriteAssertions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReadAssertions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReadAssertions() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_ReadAssertions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadAssertions(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadAssertionsRequest* /*request*/, ::openfga::v1::ReadAssertionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadAssertions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReadChanges : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReadChanges() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_ReadChanges() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadChanges(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadChangesRequest* /*request*/, ::openfga::v1::ReadChangesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadChanges(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateStore() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_CreateStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateStore(::grpc::ServerContext* /*context*/, const ::openfga::v1::CreateStoreRequest* /*request*/, ::openfga::v1::CreateStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateStore(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateStore() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_UpdateStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateStore(::grpc::ServerContext* /*context*/, const ::openfga::v1::UpdateStoreRequest* /*request*/, ::openfga::v1::UpdateStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateStore(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteStore() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_DeleteStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteStore(::grpc::ServerContext* /*context*/, const ::openfga::v1::DeleteStoreRequest* /*request*/, ::openfga::v1::DeleteStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteStore(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetStore() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_GetStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStore(::grpc::ServerContext* /*context*/, const ::openfga::v1::GetStoreRequest* /*request*/, ::openfga::v1::GetStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStore(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListStores : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListStores() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_ListStores() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListStores(::grpc::ServerContext* /*context*/, const ::openfga::v1::ListStoresRequest* /*request*/, ::openfga::v1::ListStoresResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListStores(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StreamedListObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StreamedListObjects() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_StreamedListObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamedListObjects(::grpc::ServerContext* /*context*/, const ::openfga::v1::StreamedListObjectsRequest* /*request*/, ::grpc::ServerWriter< ::openfga::v1::StreamedListObjectsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamedListObjects(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(16, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListObjects() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_ListObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListObjects(::grpc::ServerContext* /*context*/, const ::openfga::v1::ListObjectsRequest* /*request*/, ::openfga::v1::ListObjectsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListObjects(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListUsers() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_ListUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListUsers(::grpc::ServerContext* /*context*/, const ::openfga::v1::ListUsersRequest* /*request*/, ::openfga::v1::ListUsersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListUsers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Read() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Read(context, request, response); }));
    }
    ~WithRawCallbackMethod_Read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Read(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadRequest* /*request*/, ::openfga::v1::ReadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Read(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Write() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Write(context, request, response); }));
    }
    ~WithRawCallbackMethod_Write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Write(::grpc::ServerContext* /*context*/, const ::openfga::v1::WriteRequest* /*request*/, ::openfga::v1::WriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Write(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Check() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Check(context, request, response); }));
    }
    ~WithRawCallbackMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::openfga::v1::CheckRequest* /*request*/, ::openfga::v1::CheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Check(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_BatchCheck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_BatchCheck() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BatchCheck(context, request, response); }));
    }
    ~WithRawCallbackMethod_BatchCheck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchCheck(::grpc::ServerContext* /*context*/, const ::openfga::v1::BatchCheckRequest* /*request*/, ::openfga::v1::BatchCheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BatchCheck(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Expand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Expand() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Expand(context, request, response); }));
    }
    ~WithRawCallbackMethod_Expand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Expand(::grpc::ServerContext* /*context*/, const ::openfga::v1::ExpandRequest* /*request*/, ::openfga::v1::ExpandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Expand(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ReadAuthorizationModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ReadAuthorizationModels() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReadAuthorizationModels(context, request, response); }));
    }
    ~WithRawCallbackMethod_ReadAuthorizationModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadAuthorizationModels(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadAuthorizationModelsRequest* /*request*/, ::openfga::v1::ReadAuthorizationModelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReadAuthorizationModels(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ReadAuthorizationModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ReadAuthorizationModel() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReadAuthorizationModel(context, request, response); }));
    }
    ~WithRawCallbackMethod_ReadAuthorizationModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadAuthorizationModel(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadAuthorizationModelRequest* /*request*/, ::openfga::v1::ReadAuthorizationModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReadAuthorizationModel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_WriteAuthorizationModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_WriteAuthorizationModel() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WriteAuthorizationModel(context, request, response); }));
    }
    ~WithRawCallbackMethod_WriteAuthorizationModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteAuthorizationModel(::grpc::ServerContext* /*context*/, const ::openfga::v1::WriteAuthorizationModelRequest* /*request*/, ::openfga::v1::WriteAuthorizationModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WriteAuthorizationModel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_WriteAssertions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_WriteAssertions() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WriteAssertions(context, request, response); }));
    }
    ~WithRawCallbackMethod_WriteAssertions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteAssertions(::grpc::ServerContext* /*context*/, const ::openfga::v1::WriteAssertionsRequest* /*request*/, ::openfga::v1::WriteAssertionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WriteAssertions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ReadAssertions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ReadAssertions() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReadAssertions(context, request, response); }));
    }
    ~WithRawCallbackMethod_ReadAssertions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadAssertions(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadAssertionsRequest* /*request*/, ::openfga::v1::ReadAssertionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReadAssertions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ReadChanges : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ReadChanges() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReadChanges(context, request, response); }));
    }
    ~WithRawCallbackMethod_ReadChanges() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadChanges(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadChangesRequest* /*request*/, ::openfga::v1::ReadChangesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReadChanges(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CreateStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CreateStore() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateStore(context, request, response); }));
    }
    ~WithRawCallbackMethod_CreateStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateStore(::grpc::ServerContext* /*context*/, const ::openfga::v1::CreateStoreRequest* /*request*/, ::openfga::v1::CreateStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateStore(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UpdateStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UpdateStore() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateStore(context, request, response); }));
    }
    ~WithRawCallbackMethod_UpdateStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateStore(::grpc::ServerContext* /*context*/, const ::openfga::v1::UpdateStoreRequest* /*request*/, ::openfga::v1::UpdateStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateStore(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DeleteStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DeleteStore() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteStore(context, request, response); }));
    }
    ~WithRawCallbackMethod_DeleteStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteStore(::grpc::ServerContext* /*context*/, const ::openfga::v1::DeleteStoreRequest* /*request*/, ::openfga::v1::DeleteStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteStore(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetStore() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetStore(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStore(::grpc::ServerContext* /*context*/, const ::openfga::v1::GetStoreRequest* /*request*/, ::openfga::v1::GetStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetStore(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListStores : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListStores() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListStores(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListStores() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListStores(::grpc::ServerContext* /*context*/, const ::openfga::v1::ListStoresRequest* /*request*/, ::openfga::v1::ListStoresResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListStores(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StreamedListObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StreamedListObjects() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->StreamedListObjects(context, request); }));
    }
    ~WithRawCallbackMethod_StreamedListObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamedListObjects(::grpc::ServerContext* /*context*/, const ::openfga::v1::StreamedListObjectsRequest* /*request*/, ::grpc::ServerWriter< ::openfga::v1::StreamedListObjectsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* StreamedListObjects(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListObjects() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListObjects(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListObjects(::grpc::ServerContext* /*context*/, const ::openfga::v1::ListObjectsRequest* /*request*/, ::openfga::v1::ListObjectsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListObjects(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListUsers() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListUsers(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListUsers(::grpc::ServerContext* /*context*/, const ::openfga::v1::ListUsersRequest* /*request*/, ::openfga::v1::ListUsersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListUsers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Read() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::openfga::v1::ReadRequest, ::openfga::v1::ReadResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::openfga::v1::ReadRequest, ::openfga::v1::ReadResponse>* streamer) {
                       return this->StreamedRead(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Read(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadRequest* /*request*/, ::openfga::v1::ReadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRead(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::openfga::v1::ReadRequest,::openfga::v1::ReadResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Write : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Write() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::openfga::v1::WriteRequest, ::openfga::v1::WriteResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::openfga::v1::WriteRequest, ::openfga::v1::WriteResponse>* streamer) {
                       return this->StreamedWrite(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Write() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Write(::grpc::ServerContext* /*context*/, const ::openfga::v1::WriteRequest* /*request*/, ::openfga::v1::WriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWrite(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::openfga::v1::WriteRequest,::openfga::v1::WriteResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Check() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::openfga::v1::CheckRequest, ::openfga::v1::CheckResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::openfga::v1::CheckRequest, ::openfga::v1::CheckResponse>* streamer) {
                       return this->StreamedCheck(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::openfga::v1::CheckRequest* /*request*/, ::openfga::v1::CheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCheck(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::openfga::v1::CheckRequest,::openfga::v1::CheckResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BatchCheck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BatchCheck() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::openfga::v1::BatchCheckRequest, ::openfga::v1::BatchCheckResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::openfga::v1::BatchCheckRequest, ::openfga::v1::BatchCheckResponse>* streamer) {
                       return this->StreamedBatchCheck(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BatchCheck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BatchCheck(::grpc::ServerContext* /*context*/, const ::openfga::v1::BatchCheckRequest* /*request*/, ::openfga::v1::BatchCheckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBatchCheck(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::openfga::v1::BatchCheckRequest,::openfga::v1::BatchCheckResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Expand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Expand() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::openfga::v1::ExpandRequest, ::openfga::v1::ExpandResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::openfga::v1::ExpandRequest, ::openfga::v1::ExpandResponse>* streamer) {
                       return this->StreamedExpand(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Expand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Expand(::grpc::ServerContext* /*context*/, const ::openfga::v1::ExpandRequest* /*request*/, ::openfga::v1::ExpandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExpand(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::openfga::v1::ExpandRequest,::openfga::v1::ExpandResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReadAuthorizationModels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReadAuthorizationModels() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::openfga::v1::ReadAuthorizationModelsRequest, ::openfga::v1::ReadAuthorizationModelsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::openfga::v1::ReadAuthorizationModelsRequest, ::openfga::v1::ReadAuthorizationModelsResponse>* streamer) {
                       return this->StreamedReadAuthorizationModels(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReadAuthorizationModels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReadAuthorizationModels(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadAuthorizationModelsRequest* /*request*/, ::openfga::v1::ReadAuthorizationModelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReadAuthorizationModels(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::openfga::v1::ReadAuthorizationModelsRequest,::openfga::v1::ReadAuthorizationModelsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReadAuthorizationModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReadAuthorizationModel() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::openfga::v1::ReadAuthorizationModelRequest, ::openfga::v1::ReadAuthorizationModelResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::openfga::v1::ReadAuthorizationModelRequest, ::openfga::v1::ReadAuthorizationModelResponse>* streamer) {
                       return this->StreamedReadAuthorizationModel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReadAuthorizationModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReadAuthorizationModel(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadAuthorizationModelRequest* /*request*/, ::openfga::v1::ReadAuthorizationModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReadAuthorizationModel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::openfga::v1::ReadAuthorizationModelRequest,::openfga::v1::ReadAuthorizationModelResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WriteAuthorizationModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WriteAuthorizationModel() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::openfga::v1::WriteAuthorizationModelRequest, ::openfga::v1::WriteAuthorizationModelResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::openfga::v1::WriteAuthorizationModelRequest, ::openfga::v1::WriteAuthorizationModelResponse>* streamer) {
                       return this->StreamedWriteAuthorizationModel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WriteAuthorizationModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WriteAuthorizationModel(::grpc::ServerContext* /*context*/, const ::openfga::v1::WriteAuthorizationModelRequest* /*request*/, ::openfga::v1::WriteAuthorizationModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWriteAuthorizationModel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::openfga::v1::WriteAuthorizationModelRequest,::openfga::v1::WriteAuthorizationModelResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WriteAssertions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WriteAssertions() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::openfga::v1::WriteAssertionsRequest, ::openfga::v1::WriteAssertionsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::openfga::v1::WriteAssertionsRequest, ::openfga::v1::WriteAssertionsResponse>* streamer) {
                       return this->StreamedWriteAssertions(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WriteAssertions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WriteAssertions(::grpc::ServerContext* /*context*/, const ::openfga::v1::WriteAssertionsRequest* /*request*/, ::openfga::v1::WriteAssertionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWriteAssertions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::openfga::v1::WriteAssertionsRequest,::openfga::v1::WriteAssertionsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReadAssertions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReadAssertions() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::openfga::v1::ReadAssertionsRequest, ::openfga::v1::ReadAssertionsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::openfga::v1::ReadAssertionsRequest, ::openfga::v1::ReadAssertionsResponse>* streamer) {
                       return this->StreamedReadAssertions(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReadAssertions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReadAssertions(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadAssertionsRequest* /*request*/, ::openfga::v1::ReadAssertionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReadAssertions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::openfga::v1::ReadAssertionsRequest,::openfga::v1::ReadAssertionsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReadChanges : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReadChanges() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::openfga::v1::ReadChangesRequest, ::openfga::v1::ReadChangesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::openfga::v1::ReadChangesRequest, ::openfga::v1::ReadChangesResponse>* streamer) {
                       return this->StreamedReadChanges(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReadChanges() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReadChanges(::grpc::ServerContext* /*context*/, const ::openfga::v1::ReadChangesRequest* /*request*/, ::openfga::v1::ReadChangesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReadChanges(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::openfga::v1::ReadChangesRequest,::openfga::v1::ReadChangesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateStore() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::openfga::v1::CreateStoreRequest, ::openfga::v1::CreateStoreResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::openfga::v1::CreateStoreRequest, ::openfga::v1::CreateStoreResponse>* streamer) {
                       return this->StreamedCreateStore(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateStore(::grpc::ServerContext* /*context*/, const ::openfga::v1::CreateStoreRequest* /*request*/, ::openfga::v1::CreateStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateStore(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::openfga::v1::CreateStoreRequest,::openfga::v1::CreateStoreResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateStore() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::openfga::v1::UpdateStoreRequest, ::openfga::v1::UpdateStoreResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::openfga::v1::UpdateStoreRequest, ::openfga::v1::UpdateStoreResponse>* streamer) {
                       return this->StreamedUpdateStore(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateStore(::grpc::ServerContext* /*context*/, const ::openfga::v1::UpdateStoreRequest* /*request*/, ::openfga::v1::UpdateStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateStore(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::openfga::v1::UpdateStoreRequest,::openfga::v1::UpdateStoreResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteStore() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::openfga::v1::DeleteStoreRequest, ::openfga::v1::DeleteStoreResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::openfga::v1::DeleteStoreRequest, ::openfga::v1::DeleteStoreResponse>* streamer) {
                       return this->StreamedDeleteStore(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteStore(::grpc::ServerContext* /*context*/, const ::openfga::v1::DeleteStoreRequest* /*request*/, ::openfga::v1::DeleteStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteStore(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::openfga::v1::DeleteStoreRequest,::openfga::v1::DeleteStoreResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetStore() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::openfga::v1::GetStoreRequest, ::openfga::v1::GetStoreResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::openfga::v1::GetStoreRequest, ::openfga::v1::GetStoreResponse>* streamer) {
                       return this->StreamedGetStore(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetStore(::grpc::ServerContext* /*context*/, const ::openfga::v1::GetStoreRequest* /*request*/, ::openfga::v1::GetStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetStore(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::openfga::v1::GetStoreRequest,::openfga::v1::GetStoreResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListStores : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListStores() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::openfga::v1::ListStoresRequest, ::openfga::v1::ListStoresResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::openfga::v1::ListStoresRequest, ::openfga::v1::ListStoresResponse>* streamer) {
                       return this->StreamedListStores(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListStores() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListStores(::grpc::ServerContext* /*context*/, const ::openfga::v1::ListStoresRequest* /*request*/, ::openfga::v1::ListStoresResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListStores(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::openfga::v1::ListStoresRequest,::openfga::v1::ListStoresResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListObjects() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::openfga::v1::ListObjectsRequest, ::openfga::v1::ListObjectsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::openfga::v1::ListObjectsRequest, ::openfga::v1::ListObjectsResponse>* streamer) {
                       return this->StreamedListObjects(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListObjects(::grpc::ServerContext* /*context*/, const ::openfga::v1::ListObjectsRequest* /*request*/, ::openfga::v1::ListObjectsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListObjects(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::openfga::v1::ListObjectsRequest,::openfga::v1::ListObjectsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListUsers() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::openfga::v1::ListUsersRequest, ::openfga::v1::ListUsersResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::openfga::v1::ListUsersRequest, ::openfga::v1::ListUsersResponse>* streamer) {
                       return this->StreamedListUsers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListUsers(::grpc::ServerContext* /*context*/, const ::openfga::v1::ListUsersRequest* /*request*/, ::openfga::v1::ListUsersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListUsers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::openfga::v1::ListUsersRequest,::openfga::v1::ListUsersResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Read<WithStreamedUnaryMethod_Write<WithStreamedUnaryMethod_Check<WithStreamedUnaryMethod_BatchCheck<WithStreamedUnaryMethod_Expand<WithStreamedUnaryMethod_ReadAuthorizationModels<WithStreamedUnaryMethod_ReadAuthorizationModel<WithStreamedUnaryMethod_WriteAuthorizationModel<WithStreamedUnaryMethod_WriteAssertions<WithStreamedUnaryMethod_ReadAssertions<WithStreamedUnaryMethod_ReadChanges<WithStreamedUnaryMethod_CreateStore<WithStreamedUnaryMethod_UpdateStore<WithStreamedUnaryMethod_DeleteStore<WithStreamedUnaryMethod_GetStore<WithStreamedUnaryMethod_ListStores<WithStreamedUnaryMethod_ListObjects<WithStreamedUnaryMethod_ListUsers<Service > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_StreamedListObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_StreamedListObjects() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::openfga::v1::StreamedListObjectsRequest, ::openfga::v1::StreamedListObjectsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::openfga::v1::StreamedListObjectsRequest, ::openfga::v1::StreamedListObjectsResponse>* streamer) {
                       return this->StreamedStreamedListObjects(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_StreamedListObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StreamedListObjects(::grpc::ServerContext* /*context*/, const ::openfga::v1::StreamedListObjectsRequest* /*request*/, ::grpc::ServerWriter< ::openfga::v1::StreamedListObjectsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedStreamedListObjects(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::openfga::v1::StreamedListObjectsRequest,::openfga::v1::StreamedListObjectsResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_StreamedListObjects<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_Read<WithStreamedUnaryMethod_Write<WithStreamedUnaryMethod_Check<WithStreamedUnaryMethod_BatchCheck<WithStreamedUnaryMethod_Expand<WithStreamedUnaryMethod_ReadAuthorizationModels<WithStreamedUnaryMethod_ReadAuthorizationModel<WithStreamedUnaryMethod_WriteAuthorizationModel<WithStreamedUnaryMethod_WriteAssertions<WithStreamedUnaryMethod_ReadAssertions<WithStreamedUnaryMethod_ReadChanges<WithStreamedUnaryMethod_CreateStore<WithStreamedUnaryMethod_UpdateStore<WithStreamedUnaryMethod_DeleteStore<WithStreamedUnaryMethod_GetStore<WithStreamedUnaryMethod_ListStores<WithSplitStreamingMethod_StreamedListObjects<WithStreamedUnaryMethod_ListObjects<WithStreamedUnaryMethod_ListUsers<Service > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace v1
}  // namespace openfga


#endif  // GRPC_openfga_2fv1_2fopenfga_5fservice_2eproto__INCLUDED
