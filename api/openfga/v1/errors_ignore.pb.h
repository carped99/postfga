// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: openfga/v1/errors_ignore.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_openfga_2fv1_2ferrors_5fignore_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_openfga_2fv1_2ferrors_5fignore_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "protoc-gen-openapiv2/options/annotations.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_openfga_2fv1_2ferrors_5fignore_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_openfga_2fv1_2ferrors_5fignore_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_openfga_2fv1_2ferrors_5fignore_2eproto;
namespace openfga {
namespace v1 {
class AbortedMessageResponse;
struct AbortedMessageResponseDefaultTypeInternal;
extern AbortedMessageResponseDefaultTypeInternal _AbortedMessageResponse_default_instance_;
class ErrorMessageRequest;
struct ErrorMessageRequestDefaultTypeInternal;
extern ErrorMessageRequestDefaultTypeInternal _ErrorMessageRequest_default_instance_;
class ForbiddenResponse;
struct ForbiddenResponseDefaultTypeInternal;
extern ForbiddenResponseDefaultTypeInternal _ForbiddenResponse_default_instance_;
class InternalErrorMessageResponse;
struct InternalErrorMessageResponseDefaultTypeInternal;
extern InternalErrorMessageResponseDefaultTypeInternal _InternalErrorMessageResponse_default_instance_;
class PathUnknownErrorMessageResponse;
struct PathUnknownErrorMessageResponseDefaultTypeInternal;
extern PathUnknownErrorMessageResponseDefaultTypeInternal _PathUnknownErrorMessageResponse_default_instance_;
class UnauthenticatedResponse;
struct UnauthenticatedResponseDefaultTypeInternal;
extern UnauthenticatedResponseDefaultTypeInternal _UnauthenticatedResponse_default_instance_;
class UnprocessableContentMessageResponse;
struct UnprocessableContentMessageResponseDefaultTypeInternal;
extern UnprocessableContentMessageResponseDefaultTypeInternal _UnprocessableContentMessageResponse_default_instance_;
class ValidationErrorMessageResponse;
struct ValidationErrorMessageResponseDefaultTypeInternal;
extern ValidationErrorMessageResponseDefaultTypeInternal _ValidationErrorMessageResponse_default_instance_;
}  // namespace v1
}  // namespace openfga
PROTOBUF_NAMESPACE_OPEN
template<> ::openfga::v1::AbortedMessageResponse* Arena::CreateMaybeMessage<::openfga::v1::AbortedMessageResponse>(Arena*);
template<> ::openfga::v1::ErrorMessageRequest* Arena::CreateMaybeMessage<::openfga::v1::ErrorMessageRequest>(Arena*);
template<> ::openfga::v1::ForbiddenResponse* Arena::CreateMaybeMessage<::openfga::v1::ForbiddenResponse>(Arena*);
template<> ::openfga::v1::InternalErrorMessageResponse* Arena::CreateMaybeMessage<::openfga::v1::InternalErrorMessageResponse>(Arena*);
template<> ::openfga::v1::PathUnknownErrorMessageResponse* Arena::CreateMaybeMessage<::openfga::v1::PathUnknownErrorMessageResponse>(Arena*);
template<> ::openfga::v1::UnauthenticatedResponse* Arena::CreateMaybeMessage<::openfga::v1::UnauthenticatedResponse>(Arena*);
template<> ::openfga::v1::UnprocessableContentMessageResponse* Arena::CreateMaybeMessage<::openfga::v1::UnprocessableContentMessageResponse>(Arena*);
template<> ::openfga::v1::ValidationErrorMessageResponse* Arena::CreateMaybeMessage<::openfga::v1::ValidationErrorMessageResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace openfga {
namespace v1 {

enum AuthErrorCode : int {
  no_auth_error = 0,
  auth_failed_invalid_subject = 1001,
  auth_failed_invalid_audience = 1002,
  auth_failed_invalid_issuer = 1003,
  invalid_claims = 1004,
  auth_failed_invalid_bearer_token = 1005,
  bearer_token_missing = 1010,
  unauthenticated = 1500,
  forbidden = 1600,
  AuthErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AuthErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AuthErrorCode_IsValid(int value);
constexpr AuthErrorCode AuthErrorCode_MIN = no_auth_error;
constexpr AuthErrorCode AuthErrorCode_MAX = forbidden;
constexpr int AuthErrorCode_ARRAYSIZE = AuthErrorCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AuthErrorCode_descriptor();
template<typename T>
inline const std::string& AuthErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AuthErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AuthErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AuthErrorCode_descriptor(), enum_t_value);
}
inline bool AuthErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AuthErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AuthErrorCode>(
    AuthErrorCode_descriptor(), name, value);
}
enum ErrorCode : int {
  no_error = 0,
  validation_error = 2000,
  authorization_model_not_found = 2001,
  authorization_model_resolution_too_complex = 2002,
  invalid_write_input = 2003,
  cannot_allow_duplicate_tuples_in_one_request = 2004,
  cannot_allow_duplicate_types_in_one_request = 2005,
  cannot_allow_multiple_references_to_one_relation = 2006,
  invalid_continuation_token = 2007,
  invalid_tuple_set = 2008,
  invalid_check_input = 2009,
  invalid_expand_input = 2010,
  unsupported_user_set = 2011,
  invalid_object_format = 2012,
  write_failed_due_to_invalid_input = 2017,
  authorization_model_assertions_not_found = 2018,
  latest_authorization_model_not_found = 2020,
  type_not_found = 2021,
  relation_not_found = 2022,
  empty_relation_definition = 2023,
  invalid_user = 2025,
  invalid_tuple = 2027,
  unknown_relation = 2028,
  store_id_invalid_length = 2030,
  assertions_too_many_items = 2033,
  id_too_long = 2034,
  authorization_model_id_too_long = 2036,
  tuple_key_value_not_specified = 2037,
  tuple_keys_too_many_or_too_few_items = 2038,
  page_size_invalid = 2039,
  param_missing_value = 2040,
  difference_base_missing_value = 2041,
  subtract_base_missing_value = 2042,
  object_too_long = 2043,
  relation_too_long = 2044,
  type_definitions_too_few_items = 2045,
  type_invalid_length = 2046,
  type_invalid_pattern = 2047,
  relations_too_few_items = 2048,
  relations_too_long = 2049,
  relations_invalid_pattern = 2050,
  object_invalid_pattern = 2051,
  query_string_type_continuation_token_mismatch = 2052,
  exceeded_entity_limit = 2053,
  invalid_contextual_tuple = 2054,
  duplicate_contextual_tuple = 2055,
  invalid_authorization_model = 2056,
  unsupported_schema_version = 2057,
  cancelled = 2058,
  invalid_start_time = 2059,
  ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ErrorCode_IsValid(int value);
constexpr ErrorCode ErrorCode_MIN = no_error;
constexpr ErrorCode ErrorCode_MAX = invalid_start_time;
constexpr int ErrorCode_ARRAYSIZE = ErrorCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ErrorCode_descriptor();
template<typename T>
inline const std::string& ErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ErrorCode_descriptor(), enum_t_value);
}
inline bool ErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ErrorCode>(
    ErrorCode_descriptor(), name, value);
}
enum UnprocessableContentErrorCode : int {
  no_throttled_error_code = 0,
  throttled_timeout_error = 3500,
  UnprocessableContentErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UnprocessableContentErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UnprocessableContentErrorCode_IsValid(int value);
constexpr UnprocessableContentErrorCode UnprocessableContentErrorCode_MIN = no_throttled_error_code;
constexpr UnprocessableContentErrorCode UnprocessableContentErrorCode_MAX = throttled_timeout_error;
constexpr int UnprocessableContentErrorCode_ARRAYSIZE = UnprocessableContentErrorCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UnprocessableContentErrorCode_descriptor();
template<typename T>
inline const std::string& UnprocessableContentErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UnprocessableContentErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UnprocessableContentErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UnprocessableContentErrorCode_descriptor(), enum_t_value);
}
inline bool UnprocessableContentErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UnprocessableContentErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UnprocessableContentErrorCode>(
    UnprocessableContentErrorCode_descriptor(), name, value);
}
enum InternalErrorCode : int {
  no_internal_error = 0,
  internal_error = 4000,
  deadline_exceeded = 4004,
  already_exists = 4005,
  resource_exhausted = 4006,
  failed_precondition = 4007,
  aborted = 4008,
  out_of_range = 4009,
  unavailable = 4010,
  data_loss = 4011,
  InternalErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  InternalErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool InternalErrorCode_IsValid(int value);
constexpr InternalErrorCode InternalErrorCode_MIN = no_internal_error;
constexpr InternalErrorCode InternalErrorCode_MAX = data_loss;
constexpr int InternalErrorCode_ARRAYSIZE = InternalErrorCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InternalErrorCode_descriptor();
template<typename T>
inline const std::string& InternalErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InternalErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InternalErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InternalErrorCode_descriptor(), enum_t_value);
}
inline bool InternalErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InternalErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InternalErrorCode>(
    InternalErrorCode_descriptor(), name, value);
}
enum NotFoundErrorCode : int {
  no_not_found_error = 0,
  undefined_endpoint = 5000,
  store_id_not_found = 5002,
  unimplemented = 5004,
  NotFoundErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NotFoundErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NotFoundErrorCode_IsValid(int value);
constexpr NotFoundErrorCode NotFoundErrorCode_MIN = no_not_found_error;
constexpr NotFoundErrorCode NotFoundErrorCode_MAX = unimplemented;
constexpr int NotFoundErrorCode_ARRAYSIZE = NotFoundErrorCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NotFoundErrorCode_descriptor();
template<typename T>
inline const std::string& NotFoundErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NotFoundErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NotFoundErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NotFoundErrorCode_descriptor(), enum_t_value);
}
inline bool NotFoundErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NotFoundErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NotFoundErrorCode>(
    NotFoundErrorCode_descriptor(), name, value);
}
// ===================================================================

class ValidationErrorMessageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ValidationErrorMessageResponse) */ {
 public:
  inline ValidationErrorMessageResponse() : ValidationErrorMessageResponse(nullptr) {}
  ~ValidationErrorMessageResponse() override;
  explicit PROTOBUF_CONSTEXPR ValidationErrorMessageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidationErrorMessageResponse(const ValidationErrorMessageResponse& from);
  ValidationErrorMessageResponse(ValidationErrorMessageResponse&& from) noexcept
    : ValidationErrorMessageResponse() {
    *this = ::std::move(from);
  }

  inline ValidationErrorMessageResponse& operator=(const ValidationErrorMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidationErrorMessageResponse& operator=(ValidationErrorMessageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidationErrorMessageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidationErrorMessageResponse* internal_default_instance() {
    return reinterpret_cast<const ValidationErrorMessageResponse*>(
               &_ValidationErrorMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ValidationErrorMessageResponse& a, ValidationErrorMessageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidationErrorMessageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidationErrorMessageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidationErrorMessageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidationErrorMessageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidationErrorMessageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValidationErrorMessageResponse& from) {
    ValidationErrorMessageResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidationErrorMessageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ValidationErrorMessageResponse";
  }
  protected:
  explicit ValidationErrorMessageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string message = 2 [json_name = "message"];
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .openfga.v1.ErrorCode code = 1 [json_name = "code"];
  void clear_code();
  ::openfga::v1::ErrorCode code() const;
  void set_code(::openfga::v1::ErrorCode value);
  private:
  ::openfga::v1::ErrorCode _internal_code() const;
  void _internal_set_code(::openfga::v1::ErrorCode value);
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.ValidationErrorMessageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2ferrors_5fignore_2eproto;
};
// -------------------------------------------------------------------

class UnauthenticatedResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.UnauthenticatedResponse) */ {
 public:
  inline UnauthenticatedResponse() : UnauthenticatedResponse(nullptr) {}
  ~UnauthenticatedResponse() override;
  explicit PROTOBUF_CONSTEXPR UnauthenticatedResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnauthenticatedResponse(const UnauthenticatedResponse& from);
  UnauthenticatedResponse(UnauthenticatedResponse&& from) noexcept
    : UnauthenticatedResponse() {
    *this = ::std::move(from);
  }

  inline UnauthenticatedResponse& operator=(const UnauthenticatedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnauthenticatedResponse& operator=(UnauthenticatedResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnauthenticatedResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnauthenticatedResponse* internal_default_instance() {
    return reinterpret_cast<const UnauthenticatedResponse*>(
               &_UnauthenticatedResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UnauthenticatedResponse& a, UnauthenticatedResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UnauthenticatedResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnauthenticatedResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnauthenticatedResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnauthenticatedResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnauthenticatedResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnauthenticatedResponse& from) {
    UnauthenticatedResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnauthenticatedResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.UnauthenticatedResponse";
  }
  protected:
  explicit UnauthenticatedResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string message = 2 [json_name = "message"];
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .openfga.v1.ErrorCode code = 1 [json_name = "code"];
  void clear_code();
  ::openfga::v1::ErrorCode code() const;
  void set_code(::openfga::v1::ErrorCode value);
  private:
  ::openfga::v1::ErrorCode _internal_code() const;
  void _internal_set_code(::openfga::v1::ErrorCode value);
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.UnauthenticatedResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2ferrors_5fignore_2eproto;
};
// -------------------------------------------------------------------

class UnprocessableContentMessageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.UnprocessableContentMessageResponse) */ {
 public:
  inline UnprocessableContentMessageResponse() : UnprocessableContentMessageResponse(nullptr) {}
  ~UnprocessableContentMessageResponse() override;
  explicit PROTOBUF_CONSTEXPR UnprocessableContentMessageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnprocessableContentMessageResponse(const UnprocessableContentMessageResponse& from);
  UnprocessableContentMessageResponse(UnprocessableContentMessageResponse&& from) noexcept
    : UnprocessableContentMessageResponse() {
    *this = ::std::move(from);
  }

  inline UnprocessableContentMessageResponse& operator=(const UnprocessableContentMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnprocessableContentMessageResponse& operator=(UnprocessableContentMessageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnprocessableContentMessageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnprocessableContentMessageResponse* internal_default_instance() {
    return reinterpret_cast<const UnprocessableContentMessageResponse*>(
               &_UnprocessableContentMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UnprocessableContentMessageResponse& a, UnprocessableContentMessageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UnprocessableContentMessageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnprocessableContentMessageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnprocessableContentMessageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnprocessableContentMessageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnprocessableContentMessageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnprocessableContentMessageResponse& from) {
    UnprocessableContentMessageResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnprocessableContentMessageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.UnprocessableContentMessageResponse";
  }
  protected:
  explicit UnprocessableContentMessageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string message = 2 [json_name = "message"];
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .openfga.v1.UnprocessableContentErrorCode code = 1 [json_name = "code"];
  void clear_code();
  ::openfga::v1::UnprocessableContentErrorCode code() const;
  void set_code(::openfga::v1::UnprocessableContentErrorCode value);
  private:
  ::openfga::v1::UnprocessableContentErrorCode _internal_code() const;
  void _internal_set_code(::openfga::v1::UnprocessableContentErrorCode value);
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.UnprocessableContentMessageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2ferrors_5fignore_2eproto;
};
// -------------------------------------------------------------------

class InternalErrorMessageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.InternalErrorMessageResponse) */ {
 public:
  inline InternalErrorMessageResponse() : InternalErrorMessageResponse(nullptr) {}
  ~InternalErrorMessageResponse() override;
  explicit PROTOBUF_CONSTEXPR InternalErrorMessageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InternalErrorMessageResponse(const InternalErrorMessageResponse& from);
  InternalErrorMessageResponse(InternalErrorMessageResponse&& from) noexcept
    : InternalErrorMessageResponse() {
    *this = ::std::move(from);
  }

  inline InternalErrorMessageResponse& operator=(const InternalErrorMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InternalErrorMessageResponse& operator=(InternalErrorMessageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InternalErrorMessageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InternalErrorMessageResponse* internal_default_instance() {
    return reinterpret_cast<const InternalErrorMessageResponse*>(
               &_InternalErrorMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InternalErrorMessageResponse& a, InternalErrorMessageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InternalErrorMessageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InternalErrorMessageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InternalErrorMessageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InternalErrorMessageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InternalErrorMessageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InternalErrorMessageResponse& from) {
    InternalErrorMessageResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InternalErrorMessageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.InternalErrorMessageResponse";
  }
  protected:
  explicit InternalErrorMessageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string message = 2 [json_name = "message"];
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .openfga.v1.InternalErrorCode code = 1 [json_name = "code"];
  void clear_code();
  ::openfga::v1::InternalErrorCode code() const;
  void set_code(::openfga::v1::InternalErrorCode value);
  private:
  ::openfga::v1::InternalErrorCode _internal_code() const;
  void _internal_set_code(::openfga::v1::InternalErrorCode value);
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.InternalErrorMessageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2ferrors_5fignore_2eproto;
};
// -------------------------------------------------------------------

class PathUnknownErrorMessageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.PathUnknownErrorMessageResponse) */ {
 public:
  inline PathUnknownErrorMessageResponse() : PathUnknownErrorMessageResponse(nullptr) {}
  ~PathUnknownErrorMessageResponse() override;
  explicit PROTOBUF_CONSTEXPR PathUnknownErrorMessageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PathUnknownErrorMessageResponse(const PathUnknownErrorMessageResponse& from);
  PathUnknownErrorMessageResponse(PathUnknownErrorMessageResponse&& from) noexcept
    : PathUnknownErrorMessageResponse() {
    *this = ::std::move(from);
  }

  inline PathUnknownErrorMessageResponse& operator=(const PathUnknownErrorMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathUnknownErrorMessageResponse& operator=(PathUnknownErrorMessageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PathUnknownErrorMessageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PathUnknownErrorMessageResponse* internal_default_instance() {
    return reinterpret_cast<const PathUnknownErrorMessageResponse*>(
               &_PathUnknownErrorMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PathUnknownErrorMessageResponse& a, PathUnknownErrorMessageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PathUnknownErrorMessageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PathUnknownErrorMessageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PathUnknownErrorMessageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PathUnknownErrorMessageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PathUnknownErrorMessageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PathUnknownErrorMessageResponse& from) {
    PathUnknownErrorMessageResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathUnknownErrorMessageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.PathUnknownErrorMessageResponse";
  }
  protected:
  explicit PathUnknownErrorMessageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string message = 2 [json_name = "message"];
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .openfga.v1.NotFoundErrorCode code = 1 [json_name = "code"];
  void clear_code();
  ::openfga::v1::NotFoundErrorCode code() const;
  void set_code(::openfga::v1::NotFoundErrorCode value);
  private:
  ::openfga::v1::NotFoundErrorCode _internal_code() const;
  void _internal_set_code(::openfga::v1::NotFoundErrorCode value);
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.PathUnknownErrorMessageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2ferrors_5fignore_2eproto;
};
// -------------------------------------------------------------------

class AbortedMessageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.AbortedMessageResponse) */ {
 public:
  inline AbortedMessageResponse() : AbortedMessageResponse(nullptr) {}
  ~AbortedMessageResponse() override;
  explicit PROTOBUF_CONSTEXPR AbortedMessageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AbortedMessageResponse(const AbortedMessageResponse& from);
  AbortedMessageResponse(AbortedMessageResponse&& from) noexcept
    : AbortedMessageResponse() {
    *this = ::std::move(from);
  }

  inline AbortedMessageResponse& operator=(const AbortedMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbortedMessageResponse& operator=(AbortedMessageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AbortedMessageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AbortedMessageResponse* internal_default_instance() {
    return reinterpret_cast<const AbortedMessageResponse*>(
               &_AbortedMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AbortedMessageResponse& a, AbortedMessageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AbortedMessageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbortedMessageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AbortedMessageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AbortedMessageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AbortedMessageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AbortedMessageResponse& from) {
    AbortedMessageResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AbortedMessageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.AbortedMessageResponse";
  }
  protected:
  explicit AbortedMessageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string code = 1 [json_name = "code"];
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // string message = 2 [json_name = "message"];
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.AbortedMessageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2ferrors_5fignore_2eproto;
};
// -------------------------------------------------------------------

class ErrorMessageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:openfga.v1.ErrorMessageRequest) */ {
 public:
  inline ErrorMessageRequest() : ErrorMessageRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ErrorMessageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ErrorMessageRequest(const ErrorMessageRequest& from);
  ErrorMessageRequest(ErrorMessageRequest&& from) noexcept
    : ErrorMessageRequest() {
    *this = ::std::move(from);
  }

  inline ErrorMessageRequest& operator=(const ErrorMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorMessageRequest& operator=(ErrorMessageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorMessageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorMessageRequest* internal_default_instance() {
    return reinterpret_cast<const ErrorMessageRequest*>(
               &_ErrorMessageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ErrorMessageRequest& a, ErrorMessageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorMessageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorMessageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorMessageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ErrorMessageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ErrorMessageRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ErrorMessageRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ErrorMessageRequest";
  }
  protected:
  explicit ErrorMessageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:openfga.v1.ErrorMessageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_openfga_2fv1_2ferrors_5fignore_2eproto;
};
// -------------------------------------------------------------------

class ForbiddenResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ForbiddenResponse) */ {
 public:
  inline ForbiddenResponse() : ForbiddenResponse(nullptr) {}
  ~ForbiddenResponse() override;
  explicit PROTOBUF_CONSTEXPR ForbiddenResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForbiddenResponse(const ForbiddenResponse& from);
  ForbiddenResponse(ForbiddenResponse&& from) noexcept
    : ForbiddenResponse() {
    *this = ::std::move(from);
  }

  inline ForbiddenResponse& operator=(const ForbiddenResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForbiddenResponse& operator=(ForbiddenResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForbiddenResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForbiddenResponse* internal_default_instance() {
    return reinterpret_cast<const ForbiddenResponse*>(
               &_ForbiddenResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ForbiddenResponse& a, ForbiddenResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ForbiddenResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForbiddenResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForbiddenResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ForbiddenResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ForbiddenResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ForbiddenResponse& from) {
    ForbiddenResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForbiddenResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ForbiddenResponse";
  }
  protected:
  explicit ForbiddenResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string message = 2 [json_name = "message"];
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .openfga.v1.AuthErrorCode code = 1 [json_name = "code"];
  void clear_code();
  ::openfga::v1::AuthErrorCode code() const;
  void set_code(::openfga::v1::AuthErrorCode value);
  private:
  ::openfga::v1::AuthErrorCode _internal_code() const;
  void _internal_set_code(::openfga::v1::AuthErrorCode value);
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.ForbiddenResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2ferrors_5fignore_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ValidationErrorMessageResponse

// .openfga.v1.ErrorCode code = 1 [json_name = "code"];
inline void ValidationErrorMessageResponse::clear_code() {
  _impl_.code_ = 0;
}
inline ::openfga::v1::ErrorCode ValidationErrorMessageResponse::_internal_code() const {
  return static_cast< ::openfga::v1::ErrorCode >(_impl_.code_);
}
inline ::openfga::v1::ErrorCode ValidationErrorMessageResponse::code() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ValidationErrorMessageResponse.code)
  return _internal_code();
}
inline void ValidationErrorMessageResponse::_internal_set_code(::openfga::v1::ErrorCode value) {
  
  _impl_.code_ = value;
}
inline void ValidationErrorMessageResponse::set_code(::openfga::v1::ErrorCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:openfga.v1.ValidationErrorMessageResponse.code)
}

// string message = 2 [json_name = "message"];
inline void ValidationErrorMessageResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ValidationErrorMessageResponse::message() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ValidationErrorMessageResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ValidationErrorMessageResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ValidationErrorMessageResponse.message)
}
inline std::string* ValidationErrorMessageResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ValidationErrorMessageResponse.message)
  return _s;
}
inline const std::string& ValidationErrorMessageResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ValidationErrorMessageResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ValidationErrorMessageResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ValidationErrorMessageResponse::release_message() {
  // @@protoc_insertion_point(field_release:openfga.v1.ValidationErrorMessageResponse.message)
  return _impl_.message_.Release();
}
inline void ValidationErrorMessageResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ValidationErrorMessageResponse.message)
}

// -------------------------------------------------------------------

// UnauthenticatedResponse

// .openfga.v1.ErrorCode code = 1 [json_name = "code"];
inline void UnauthenticatedResponse::clear_code() {
  _impl_.code_ = 0;
}
inline ::openfga::v1::ErrorCode UnauthenticatedResponse::_internal_code() const {
  return static_cast< ::openfga::v1::ErrorCode >(_impl_.code_);
}
inline ::openfga::v1::ErrorCode UnauthenticatedResponse::code() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UnauthenticatedResponse.code)
  return _internal_code();
}
inline void UnauthenticatedResponse::_internal_set_code(::openfga::v1::ErrorCode value) {
  
  _impl_.code_ = value;
}
inline void UnauthenticatedResponse::set_code(::openfga::v1::ErrorCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:openfga.v1.UnauthenticatedResponse.code)
}

// string message = 2 [json_name = "message"];
inline void UnauthenticatedResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& UnauthenticatedResponse::message() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UnauthenticatedResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnauthenticatedResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.UnauthenticatedResponse.message)
}
inline std::string* UnauthenticatedResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:openfga.v1.UnauthenticatedResponse.message)
  return _s;
}
inline const std::string& UnauthenticatedResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void UnauthenticatedResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* UnauthenticatedResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* UnauthenticatedResponse::release_message() {
  // @@protoc_insertion_point(field_release:openfga.v1.UnauthenticatedResponse.message)
  return _impl_.message_.Release();
}
inline void UnauthenticatedResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.UnauthenticatedResponse.message)
}

// -------------------------------------------------------------------

// UnprocessableContentMessageResponse

// .openfga.v1.UnprocessableContentErrorCode code = 1 [json_name = "code"];
inline void UnprocessableContentMessageResponse::clear_code() {
  _impl_.code_ = 0;
}
inline ::openfga::v1::UnprocessableContentErrorCode UnprocessableContentMessageResponse::_internal_code() const {
  return static_cast< ::openfga::v1::UnprocessableContentErrorCode >(_impl_.code_);
}
inline ::openfga::v1::UnprocessableContentErrorCode UnprocessableContentMessageResponse::code() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UnprocessableContentMessageResponse.code)
  return _internal_code();
}
inline void UnprocessableContentMessageResponse::_internal_set_code(::openfga::v1::UnprocessableContentErrorCode value) {
  
  _impl_.code_ = value;
}
inline void UnprocessableContentMessageResponse::set_code(::openfga::v1::UnprocessableContentErrorCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:openfga.v1.UnprocessableContentMessageResponse.code)
}

// string message = 2 [json_name = "message"];
inline void UnprocessableContentMessageResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& UnprocessableContentMessageResponse::message() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UnprocessableContentMessageResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnprocessableContentMessageResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.UnprocessableContentMessageResponse.message)
}
inline std::string* UnprocessableContentMessageResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:openfga.v1.UnprocessableContentMessageResponse.message)
  return _s;
}
inline const std::string& UnprocessableContentMessageResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void UnprocessableContentMessageResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* UnprocessableContentMessageResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* UnprocessableContentMessageResponse::release_message() {
  // @@protoc_insertion_point(field_release:openfga.v1.UnprocessableContentMessageResponse.message)
  return _impl_.message_.Release();
}
inline void UnprocessableContentMessageResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.UnprocessableContentMessageResponse.message)
}

// -------------------------------------------------------------------

// InternalErrorMessageResponse

// .openfga.v1.InternalErrorCode code = 1 [json_name = "code"];
inline void InternalErrorMessageResponse::clear_code() {
  _impl_.code_ = 0;
}
inline ::openfga::v1::InternalErrorCode InternalErrorMessageResponse::_internal_code() const {
  return static_cast< ::openfga::v1::InternalErrorCode >(_impl_.code_);
}
inline ::openfga::v1::InternalErrorCode InternalErrorMessageResponse::code() const {
  // @@protoc_insertion_point(field_get:openfga.v1.InternalErrorMessageResponse.code)
  return _internal_code();
}
inline void InternalErrorMessageResponse::_internal_set_code(::openfga::v1::InternalErrorCode value) {
  
  _impl_.code_ = value;
}
inline void InternalErrorMessageResponse::set_code(::openfga::v1::InternalErrorCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:openfga.v1.InternalErrorMessageResponse.code)
}

// string message = 2 [json_name = "message"];
inline void InternalErrorMessageResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& InternalErrorMessageResponse::message() const {
  // @@protoc_insertion_point(field_get:openfga.v1.InternalErrorMessageResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InternalErrorMessageResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.InternalErrorMessageResponse.message)
}
inline std::string* InternalErrorMessageResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:openfga.v1.InternalErrorMessageResponse.message)
  return _s;
}
inline const std::string& InternalErrorMessageResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void InternalErrorMessageResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* InternalErrorMessageResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* InternalErrorMessageResponse::release_message() {
  // @@protoc_insertion_point(field_release:openfga.v1.InternalErrorMessageResponse.message)
  return _impl_.message_.Release();
}
inline void InternalErrorMessageResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.InternalErrorMessageResponse.message)
}

// -------------------------------------------------------------------

// PathUnknownErrorMessageResponse

// .openfga.v1.NotFoundErrorCode code = 1 [json_name = "code"];
inline void PathUnknownErrorMessageResponse::clear_code() {
  _impl_.code_ = 0;
}
inline ::openfga::v1::NotFoundErrorCode PathUnknownErrorMessageResponse::_internal_code() const {
  return static_cast< ::openfga::v1::NotFoundErrorCode >(_impl_.code_);
}
inline ::openfga::v1::NotFoundErrorCode PathUnknownErrorMessageResponse::code() const {
  // @@protoc_insertion_point(field_get:openfga.v1.PathUnknownErrorMessageResponse.code)
  return _internal_code();
}
inline void PathUnknownErrorMessageResponse::_internal_set_code(::openfga::v1::NotFoundErrorCode value) {
  
  _impl_.code_ = value;
}
inline void PathUnknownErrorMessageResponse::set_code(::openfga::v1::NotFoundErrorCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:openfga.v1.PathUnknownErrorMessageResponse.code)
}

// string message = 2 [json_name = "message"];
inline void PathUnknownErrorMessageResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& PathUnknownErrorMessageResponse::message() const {
  // @@protoc_insertion_point(field_get:openfga.v1.PathUnknownErrorMessageResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PathUnknownErrorMessageResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.PathUnknownErrorMessageResponse.message)
}
inline std::string* PathUnknownErrorMessageResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:openfga.v1.PathUnknownErrorMessageResponse.message)
  return _s;
}
inline const std::string& PathUnknownErrorMessageResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void PathUnknownErrorMessageResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* PathUnknownErrorMessageResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* PathUnknownErrorMessageResponse::release_message() {
  // @@protoc_insertion_point(field_release:openfga.v1.PathUnknownErrorMessageResponse.message)
  return _impl_.message_.Release();
}
inline void PathUnknownErrorMessageResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.PathUnknownErrorMessageResponse.message)
}

// -------------------------------------------------------------------

// AbortedMessageResponse

// string code = 1 [json_name = "code"];
inline void AbortedMessageResponse::clear_code() {
  _impl_.code_.ClearToEmpty();
}
inline const std::string& AbortedMessageResponse::code() const {
  // @@protoc_insertion_point(field_get:openfga.v1.AbortedMessageResponse.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AbortedMessageResponse::set_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.AbortedMessageResponse.code)
}
inline std::string* AbortedMessageResponse::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:openfga.v1.AbortedMessageResponse.code)
  return _s;
}
inline const std::string& AbortedMessageResponse::_internal_code() const {
  return _impl_.code_.Get();
}
inline void AbortedMessageResponse::_internal_set_code(const std::string& value) {
  
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* AbortedMessageResponse::_internal_mutable_code() {
  
  return _impl_.code_.Mutable(GetArenaForAllocation());
}
inline std::string* AbortedMessageResponse::release_code() {
  // @@protoc_insertion_point(field_release:openfga.v1.AbortedMessageResponse.code)
  return _impl_.code_.Release();
}
inline void AbortedMessageResponse::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  _impl_.code_.SetAllocated(code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.AbortedMessageResponse.code)
}

// string message = 2 [json_name = "message"];
inline void AbortedMessageResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& AbortedMessageResponse::message() const {
  // @@protoc_insertion_point(field_get:openfga.v1.AbortedMessageResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AbortedMessageResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.AbortedMessageResponse.message)
}
inline std::string* AbortedMessageResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:openfga.v1.AbortedMessageResponse.message)
  return _s;
}
inline const std::string& AbortedMessageResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void AbortedMessageResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* AbortedMessageResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* AbortedMessageResponse::release_message() {
  // @@protoc_insertion_point(field_release:openfga.v1.AbortedMessageResponse.message)
  return _impl_.message_.Release();
}
inline void AbortedMessageResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.AbortedMessageResponse.message)
}

// -------------------------------------------------------------------

// ErrorMessageRequest

// -------------------------------------------------------------------

// ForbiddenResponse

// .openfga.v1.AuthErrorCode code = 1 [json_name = "code"];
inline void ForbiddenResponse::clear_code() {
  _impl_.code_ = 0;
}
inline ::openfga::v1::AuthErrorCode ForbiddenResponse::_internal_code() const {
  return static_cast< ::openfga::v1::AuthErrorCode >(_impl_.code_);
}
inline ::openfga::v1::AuthErrorCode ForbiddenResponse::code() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ForbiddenResponse.code)
  return _internal_code();
}
inline void ForbiddenResponse::_internal_set_code(::openfga::v1::AuthErrorCode value) {
  
  _impl_.code_ = value;
}
inline void ForbiddenResponse::set_code(::openfga::v1::AuthErrorCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:openfga.v1.ForbiddenResponse.code)
}

// string message = 2 [json_name = "message"];
inline void ForbiddenResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ForbiddenResponse::message() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ForbiddenResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ForbiddenResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ForbiddenResponse.message)
}
inline std::string* ForbiddenResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ForbiddenResponse.message)
  return _s;
}
inline const std::string& ForbiddenResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ForbiddenResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ForbiddenResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ForbiddenResponse::release_message() {
  // @@protoc_insertion_point(field_release:openfga.v1.ForbiddenResponse.message)
  return _impl_.message_.Release();
}
inline void ForbiddenResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ForbiddenResponse.message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace openfga

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::openfga::v1::AuthErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::openfga::v1::AuthErrorCode>() {
  return ::openfga::v1::AuthErrorCode_descriptor();
}
template <> struct is_proto_enum< ::openfga::v1::ErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::openfga::v1::ErrorCode>() {
  return ::openfga::v1::ErrorCode_descriptor();
}
template <> struct is_proto_enum< ::openfga::v1::UnprocessableContentErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::openfga::v1::UnprocessableContentErrorCode>() {
  return ::openfga::v1::UnprocessableContentErrorCode_descriptor();
}
template <> struct is_proto_enum< ::openfga::v1::InternalErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::openfga::v1::InternalErrorCode>() {
  return ::openfga::v1::InternalErrorCode_descriptor();
}
template <> struct is_proto_enum< ::openfga::v1::NotFoundErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::openfga::v1::NotFoundErrorCode>() {
  return ::openfga::v1::NotFoundErrorCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_openfga_2fv1_2ferrors_5fignore_2eproto
