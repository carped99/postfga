// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: openfga/v1/authzmodel.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_openfga_2fv1_2fauthzmodel_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_openfga_2fv1_2fauthzmodel_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/field_behavior.pb.h"
#include "protoc-gen-openapiv2/options/annotations.pb.h"
#include "validate/validate.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_openfga_2fv1_2fauthzmodel_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_openfga_2fv1_2fauthzmodel_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_openfga_2fv1_2fauthzmodel_2eproto;
namespace openfga {
namespace v1 {
class AuthorizationModel;
struct AuthorizationModelDefaultTypeInternal;
extern AuthorizationModelDefaultTypeInternal _AuthorizationModel_default_instance_;
class AuthorizationModel_ConditionsEntry_DoNotUse;
struct AuthorizationModel_ConditionsEntry_DoNotUseDefaultTypeInternal;
extern AuthorizationModel_ConditionsEntry_DoNotUseDefaultTypeInternal _AuthorizationModel_ConditionsEntry_DoNotUse_default_instance_;
class ComputedUserset;
struct ComputedUsersetDefaultTypeInternal;
extern ComputedUsersetDefaultTypeInternal _ComputedUserset_default_instance_;
class Condition;
struct ConditionDefaultTypeInternal;
extern ConditionDefaultTypeInternal _Condition_default_instance_;
class ConditionMetadata;
struct ConditionMetadataDefaultTypeInternal;
extern ConditionMetadataDefaultTypeInternal _ConditionMetadata_default_instance_;
class ConditionParamTypeRef;
struct ConditionParamTypeRefDefaultTypeInternal;
extern ConditionParamTypeRefDefaultTypeInternal _ConditionParamTypeRef_default_instance_;
class Condition_ParametersEntry_DoNotUse;
struct Condition_ParametersEntry_DoNotUseDefaultTypeInternal;
extern Condition_ParametersEntry_DoNotUseDefaultTypeInternal _Condition_ParametersEntry_DoNotUse_default_instance_;
class Difference;
struct DifferenceDefaultTypeInternal;
extern DifferenceDefaultTypeInternal _Difference_default_instance_;
class DirectUserset;
struct DirectUsersetDefaultTypeInternal;
extern DirectUsersetDefaultTypeInternal _DirectUserset_default_instance_;
class Metadata;
struct MetadataDefaultTypeInternal;
extern MetadataDefaultTypeInternal _Metadata_default_instance_;
class Metadata_RelationsEntry_DoNotUse;
struct Metadata_RelationsEntry_DoNotUseDefaultTypeInternal;
extern Metadata_RelationsEntry_DoNotUseDefaultTypeInternal _Metadata_RelationsEntry_DoNotUse_default_instance_;
class ObjectRelation;
struct ObjectRelationDefaultTypeInternal;
extern ObjectRelationDefaultTypeInternal _ObjectRelation_default_instance_;
class Relation;
struct RelationDefaultTypeInternal;
extern RelationDefaultTypeInternal _Relation_default_instance_;
class RelationMetadata;
struct RelationMetadataDefaultTypeInternal;
extern RelationMetadataDefaultTypeInternal _RelationMetadata_default_instance_;
class RelationReference;
struct RelationReferenceDefaultTypeInternal;
extern RelationReferenceDefaultTypeInternal _RelationReference_default_instance_;
class RelationTypeInfo;
struct RelationTypeInfoDefaultTypeInternal;
extern RelationTypeInfoDefaultTypeInternal _RelationTypeInfo_default_instance_;
class SourceInfo;
struct SourceInfoDefaultTypeInternal;
extern SourceInfoDefaultTypeInternal _SourceInfo_default_instance_;
class TupleToUserset;
struct TupleToUsersetDefaultTypeInternal;
extern TupleToUsersetDefaultTypeInternal _TupleToUserset_default_instance_;
class TypeDefinition;
struct TypeDefinitionDefaultTypeInternal;
extern TypeDefinitionDefaultTypeInternal _TypeDefinition_default_instance_;
class TypeDefinition_RelationsEntry_DoNotUse;
struct TypeDefinition_RelationsEntry_DoNotUseDefaultTypeInternal;
extern TypeDefinition_RelationsEntry_DoNotUseDefaultTypeInternal _TypeDefinition_RelationsEntry_DoNotUse_default_instance_;
class Userset;
struct UsersetDefaultTypeInternal;
extern UsersetDefaultTypeInternal _Userset_default_instance_;
class Usersets;
struct UsersetsDefaultTypeInternal;
extern UsersetsDefaultTypeInternal _Usersets_default_instance_;
class Wildcard;
struct WildcardDefaultTypeInternal;
extern WildcardDefaultTypeInternal _Wildcard_default_instance_;
}  // namespace v1
}  // namespace openfga
PROTOBUF_NAMESPACE_OPEN
template<> ::openfga::v1::AuthorizationModel* Arena::CreateMaybeMessage<::openfga::v1::AuthorizationModel>(Arena*);
template<> ::openfga::v1::AuthorizationModel_ConditionsEntry_DoNotUse* Arena::CreateMaybeMessage<::openfga::v1::AuthorizationModel_ConditionsEntry_DoNotUse>(Arena*);
template<> ::openfga::v1::ComputedUserset* Arena::CreateMaybeMessage<::openfga::v1::ComputedUserset>(Arena*);
template<> ::openfga::v1::Condition* Arena::CreateMaybeMessage<::openfga::v1::Condition>(Arena*);
template<> ::openfga::v1::ConditionMetadata* Arena::CreateMaybeMessage<::openfga::v1::ConditionMetadata>(Arena*);
template<> ::openfga::v1::ConditionParamTypeRef* Arena::CreateMaybeMessage<::openfga::v1::ConditionParamTypeRef>(Arena*);
template<> ::openfga::v1::Condition_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::openfga::v1::Condition_ParametersEntry_DoNotUse>(Arena*);
template<> ::openfga::v1::Difference* Arena::CreateMaybeMessage<::openfga::v1::Difference>(Arena*);
template<> ::openfga::v1::DirectUserset* Arena::CreateMaybeMessage<::openfga::v1::DirectUserset>(Arena*);
template<> ::openfga::v1::Metadata* Arena::CreateMaybeMessage<::openfga::v1::Metadata>(Arena*);
template<> ::openfga::v1::Metadata_RelationsEntry_DoNotUse* Arena::CreateMaybeMessage<::openfga::v1::Metadata_RelationsEntry_DoNotUse>(Arena*);
template<> ::openfga::v1::ObjectRelation* Arena::CreateMaybeMessage<::openfga::v1::ObjectRelation>(Arena*);
template<> ::openfga::v1::Relation* Arena::CreateMaybeMessage<::openfga::v1::Relation>(Arena*);
template<> ::openfga::v1::RelationMetadata* Arena::CreateMaybeMessage<::openfga::v1::RelationMetadata>(Arena*);
template<> ::openfga::v1::RelationReference* Arena::CreateMaybeMessage<::openfga::v1::RelationReference>(Arena*);
template<> ::openfga::v1::RelationTypeInfo* Arena::CreateMaybeMessage<::openfga::v1::RelationTypeInfo>(Arena*);
template<> ::openfga::v1::SourceInfo* Arena::CreateMaybeMessage<::openfga::v1::SourceInfo>(Arena*);
template<> ::openfga::v1::TupleToUserset* Arena::CreateMaybeMessage<::openfga::v1::TupleToUserset>(Arena*);
template<> ::openfga::v1::TypeDefinition* Arena::CreateMaybeMessage<::openfga::v1::TypeDefinition>(Arena*);
template<> ::openfga::v1::TypeDefinition_RelationsEntry_DoNotUse* Arena::CreateMaybeMessage<::openfga::v1::TypeDefinition_RelationsEntry_DoNotUse>(Arena*);
template<> ::openfga::v1::Userset* Arena::CreateMaybeMessage<::openfga::v1::Userset>(Arena*);
template<> ::openfga::v1::Usersets* Arena::CreateMaybeMessage<::openfga::v1::Usersets>(Arena*);
template<> ::openfga::v1::Wildcard* Arena::CreateMaybeMessage<::openfga::v1::Wildcard>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace openfga {
namespace v1 {

enum ConditionParamTypeRef_TypeName : int {
  ConditionParamTypeRef_TypeName_TYPE_NAME_UNSPECIFIED = 0,
  ConditionParamTypeRef_TypeName_TYPE_NAME_ANY = 1,
  ConditionParamTypeRef_TypeName_TYPE_NAME_BOOL = 2,
  ConditionParamTypeRef_TypeName_TYPE_NAME_STRING = 3,
  ConditionParamTypeRef_TypeName_TYPE_NAME_INT = 4,
  ConditionParamTypeRef_TypeName_TYPE_NAME_UINT = 5,
  ConditionParamTypeRef_TypeName_TYPE_NAME_DOUBLE = 6,
  ConditionParamTypeRef_TypeName_TYPE_NAME_DURATION = 7,
  ConditionParamTypeRef_TypeName_TYPE_NAME_TIMESTAMP = 8,
  ConditionParamTypeRef_TypeName_TYPE_NAME_MAP = 9,
  ConditionParamTypeRef_TypeName_TYPE_NAME_LIST = 10,
  ConditionParamTypeRef_TypeName_TYPE_NAME_IPADDRESS = 11,
  ConditionParamTypeRef_TypeName_ConditionParamTypeRef_TypeName_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ConditionParamTypeRef_TypeName_ConditionParamTypeRef_TypeName_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ConditionParamTypeRef_TypeName_IsValid(int value);
constexpr ConditionParamTypeRef_TypeName ConditionParamTypeRef_TypeName_TypeName_MIN = ConditionParamTypeRef_TypeName_TYPE_NAME_UNSPECIFIED;
constexpr ConditionParamTypeRef_TypeName ConditionParamTypeRef_TypeName_TypeName_MAX = ConditionParamTypeRef_TypeName_TYPE_NAME_IPADDRESS;
constexpr int ConditionParamTypeRef_TypeName_TypeName_ARRAYSIZE = ConditionParamTypeRef_TypeName_TypeName_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConditionParamTypeRef_TypeName_descriptor();
template<typename T>
inline const std::string& ConditionParamTypeRef_TypeName_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConditionParamTypeRef_TypeName>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConditionParamTypeRef_TypeName_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConditionParamTypeRef_TypeName_descriptor(), enum_t_value);
}
inline bool ConditionParamTypeRef_TypeName_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConditionParamTypeRef_TypeName* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConditionParamTypeRef_TypeName>(
    ConditionParamTypeRef_TypeName_descriptor(), name, value);
}
// ===================================================================

class AuthorizationModel_ConditionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AuthorizationModel_ConditionsEntry_DoNotUse, 
    std::string, ::openfga::v1::Condition,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AuthorizationModel_ConditionsEntry_DoNotUse, 
    std::string, ::openfga::v1::Condition,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  AuthorizationModel_ConditionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR AuthorizationModel_ConditionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AuthorizationModel_ConditionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AuthorizationModel_ConditionsEntry_DoNotUse& other);
  static const AuthorizationModel_ConditionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AuthorizationModel_ConditionsEntry_DoNotUse*>(&_AuthorizationModel_ConditionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "openfga.v1.AuthorizationModel.ConditionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_openfga_2fv1_2fauthzmodel_2eproto;
};

// -------------------------------------------------------------------

class AuthorizationModel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.AuthorizationModel) */ {
 public:
  inline AuthorizationModel() : AuthorizationModel(nullptr) {}
  ~AuthorizationModel() override;
  explicit PROTOBUF_CONSTEXPR AuthorizationModel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthorizationModel(const AuthorizationModel& from);
  AuthorizationModel(AuthorizationModel&& from) noexcept
    : AuthorizationModel() {
    *this = ::std::move(from);
  }

  inline AuthorizationModel& operator=(const AuthorizationModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthorizationModel& operator=(AuthorizationModel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthorizationModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthorizationModel* internal_default_instance() {
    return reinterpret_cast<const AuthorizationModel*>(
               &_AuthorizationModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AuthorizationModel& a, AuthorizationModel& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthorizationModel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthorizationModel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthorizationModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthorizationModel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthorizationModel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthorizationModel& from) {
    AuthorizationModel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthorizationModel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.AuthorizationModel";
  }
  protected:
  explicit AuthorizationModel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTypeDefinitionsFieldNumber = 3,
    kConditionsFieldNumber = 4,
    kIdFieldNumber = 1,
    kSchemaVersionFieldNumber = 2,
  };
  // repeated .openfga.v1.TypeDefinition type_definitions = 3 [json_name = "type_definitions", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int type_definitions_size() const;
  private:
  int _internal_type_definitions_size() const;
  public:
  void clear_type_definitions();
  ::openfga::v1::TypeDefinition* mutable_type_definitions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TypeDefinition >*
      mutable_type_definitions();
  private:
  const ::openfga::v1::TypeDefinition& _internal_type_definitions(int index) const;
  ::openfga::v1::TypeDefinition* _internal_add_type_definitions();
  public:
  const ::openfga::v1::TypeDefinition& type_definitions(int index) const;
  ::openfga::v1::TypeDefinition* add_type_definitions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TypeDefinition >&
      type_definitions() const;

  // map<string, .openfga.v1.Condition> conditions = 4 [json_name = "conditions", (.validate.rules) = {
  int conditions_size() const;
  private:
  int _internal_conditions_size() const;
  public:
  void clear_conditions();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::Condition >&
      _internal_conditions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::Condition >*
      _internal_mutable_conditions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::Condition >&
      conditions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::Condition >*
      mutable_conditions();

  // string id = 1 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string schema_version = 2 [json_name = "schema_version", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_schema_version();
  const std::string& schema_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_version();
  PROTOBUF_NODISCARD std::string* release_schema_version();
  void set_allocated_schema_version(std::string* schema_version);
  private:
  const std::string& _internal_schema_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_version(const std::string& value);
  std::string* _internal_mutable_schema_version();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.AuthorizationModel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TypeDefinition > type_definitions_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        AuthorizationModel_ConditionsEntry_DoNotUse,
        std::string, ::openfga::v1::Condition,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> conditions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fauthzmodel_2eproto;
};
// -------------------------------------------------------------------

class TypeDefinition_RelationsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TypeDefinition_RelationsEntry_DoNotUse, 
    std::string, ::openfga::v1::Userset,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TypeDefinition_RelationsEntry_DoNotUse, 
    std::string, ::openfga::v1::Userset,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  TypeDefinition_RelationsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TypeDefinition_RelationsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TypeDefinition_RelationsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TypeDefinition_RelationsEntry_DoNotUse& other);
  static const TypeDefinition_RelationsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TypeDefinition_RelationsEntry_DoNotUse*>(&_TypeDefinition_RelationsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "openfga.v1.TypeDefinition.RelationsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_openfga_2fv1_2fauthzmodel_2eproto;
};

// -------------------------------------------------------------------

class TypeDefinition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.TypeDefinition) */ {
 public:
  inline TypeDefinition() : TypeDefinition(nullptr) {}
  ~TypeDefinition() override;
  explicit PROTOBUF_CONSTEXPR TypeDefinition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TypeDefinition(const TypeDefinition& from);
  TypeDefinition(TypeDefinition&& from) noexcept
    : TypeDefinition() {
    *this = ::std::move(from);
  }

  inline TypeDefinition& operator=(const TypeDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeDefinition& operator=(TypeDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeDefinition& default_instance() {
    return *internal_default_instance();
  }
  static inline const TypeDefinition* internal_default_instance() {
    return reinterpret_cast<const TypeDefinition*>(
               &_TypeDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TypeDefinition& a, TypeDefinition& b) {
    a.Swap(&b);
  }
  inline void Swap(TypeDefinition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeDefinition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeDefinition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TypeDefinition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TypeDefinition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TypeDefinition& from) {
    TypeDefinition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TypeDefinition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.TypeDefinition";
  }
  protected:
  explicit TypeDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kRelationsFieldNumber = 2,
    kTypeFieldNumber = 1,
    kMetadataFieldNumber = 3,
  };
  // map<string, .openfga.v1.Userset> relations = 2 [json_name = "relations", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int relations_size() const;
  private:
  int _internal_relations_size() const;
  public:
  void clear_relations();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::Userset >&
      _internal_relations() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::Userset >*
      _internal_mutable_relations();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::Userset >&
      relations() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::Userset >*
      mutable_relations();

  // string type = 1 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // .openfga.v1.Metadata metadata = 3 [json_name = "metadata"];
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::openfga::v1::Metadata& metadata() const;
  PROTOBUF_NODISCARD ::openfga::v1::Metadata* release_metadata();
  ::openfga::v1::Metadata* mutable_metadata();
  void set_allocated_metadata(::openfga::v1::Metadata* metadata);
  private:
  const ::openfga::v1::Metadata& _internal_metadata() const;
  ::openfga::v1::Metadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::openfga::v1::Metadata* metadata);
  ::openfga::v1::Metadata* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:openfga.v1.TypeDefinition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TypeDefinition_RelationsEntry_DoNotUse,
        std::string, ::openfga::v1::Userset,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> relations_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::openfga::v1::Metadata* metadata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fauthzmodel_2eproto;
};
// -------------------------------------------------------------------

class Relation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.Relation) */ {
 public:
  inline Relation() : Relation(nullptr) {}
  ~Relation() override;
  explicit PROTOBUF_CONSTEXPR Relation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Relation(const Relation& from);
  Relation(Relation&& from) noexcept
    : Relation() {
    *this = ::std::move(from);
  }

  inline Relation& operator=(const Relation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Relation& operator=(Relation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Relation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Relation* internal_default_instance() {
    return reinterpret_cast<const Relation*>(
               &_Relation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Relation& a, Relation& b) {
    a.Swap(&b);
  }
  inline void Swap(Relation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Relation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Relation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Relation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Relation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Relation& from) {
    Relation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Relation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.Relation";
  }
  protected:
  explicit Relation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kRewriteFieldNumber = 2,
    kTypeInfoFieldNumber = 3,
  };
  // string name = 1 [json_name = "name", (.validate.rules) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .openfga.v1.Userset rewrite = 2 [json_name = "rewrite", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_rewrite() const;
  private:
  bool _internal_has_rewrite() const;
  public:
  void clear_rewrite();
  const ::openfga::v1::Userset& rewrite() const;
  PROTOBUF_NODISCARD ::openfga::v1::Userset* release_rewrite();
  ::openfga::v1::Userset* mutable_rewrite();
  void set_allocated_rewrite(::openfga::v1::Userset* rewrite);
  private:
  const ::openfga::v1::Userset& _internal_rewrite() const;
  ::openfga::v1::Userset* _internal_mutable_rewrite();
  public:
  void unsafe_arena_set_allocated_rewrite(
      ::openfga::v1::Userset* rewrite);
  ::openfga::v1::Userset* unsafe_arena_release_rewrite();

  // .openfga.v1.RelationTypeInfo type_info = 3 [json_name = "typeInfo"];
  bool has_type_info() const;
  private:
  bool _internal_has_type_info() const;
  public:
  void clear_type_info();
  const ::openfga::v1::RelationTypeInfo& type_info() const;
  PROTOBUF_NODISCARD ::openfga::v1::RelationTypeInfo* release_type_info();
  ::openfga::v1::RelationTypeInfo* mutable_type_info();
  void set_allocated_type_info(::openfga::v1::RelationTypeInfo* type_info);
  private:
  const ::openfga::v1::RelationTypeInfo& _internal_type_info() const;
  ::openfga::v1::RelationTypeInfo* _internal_mutable_type_info();
  public:
  void unsafe_arena_set_allocated_type_info(
      ::openfga::v1::RelationTypeInfo* type_info);
  ::openfga::v1::RelationTypeInfo* unsafe_arena_release_type_info();

  // @@protoc_insertion_point(class_scope:openfga.v1.Relation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::openfga::v1::Userset* rewrite_;
    ::openfga::v1::RelationTypeInfo* type_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fauthzmodel_2eproto;
};
// -------------------------------------------------------------------

class RelationTypeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.RelationTypeInfo) */ {
 public:
  inline RelationTypeInfo() : RelationTypeInfo(nullptr) {}
  ~RelationTypeInfo() override;
  explicit PROTOBUF_CONSTEXPR RelationTypeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelationTypeInfo(const RelationTypeInfo& from);
  RelationTypeInfo(RelationTypeInfo&& from) noexcept
    : RelationTypeInfo() {
    *this = ::std::move(from);
  }

  inline RelationTypeInfo& operator=(const RelationTypeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelationTypeInfo& operator=(RelationTypeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelationTypeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelationTypeInfo* internal_default_instance() {
    return reinterpret_cast<const RelationTypeInfo*>(
               &_RelationTypeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RelationTypeInfo& a, RelationTypeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RelationTypeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelationTypeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelationTypeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelationTypeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RelationTypeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RelationTypeInfo& from) {
    RelationTypeInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelationTypeInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.RelationTypeInfo";
  }
  protected:
  explicit RelationTypeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirectlyRelatedUserTypesFieldNumber = 1,
  };
  // repeated .openfga.v1.RelationReference directly_related_user_types = 1 [json_name = "directly_related_user_types"];
  int directly_related_user_types_size() const;
  private:
  int _internal_directly_related_user_types_size() const;
  public:
  void clear_directly_related_user_types();
  ::openfga::v1::RelationReference* mutable_directly_related_user_types(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::RelationReference >*
      mutable_directly_related_user_types();
  private:
  const ::openfga::v1::RelationReference& _internal_directly_related_user_types(int index) const;
  ::openfga::v1::RelationReference* _internal_add_directly_related_user_types();
  public:
  const ::openfga::v1::RelationReference& directly_related_user_types(int index) const;
  ::openfga::v1::RelationReference* add_directly_related_user_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::RelationReference >&
      directly_related_user_types() const;

  // @@protoc_insertion_point(class_scope:openfga.v1.RelationTypeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::RelationReference > directly_related_user_types_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fauthzmodel_2eproto;
};
// -------------------------------------------------------------------

class Metadata_RelationsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Metadata_RelationsEntry_DoNotUse, 
    std::string, ::openfga::v1::RelationMetadata,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Metadata_RelationsEntry_DoNotUse, 
    std::string, ::openfga::v1::RelationMetadata,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Metadata_RelationsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Metadata_RelationsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Metadata_RelationsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Metadata_RelationsEntry_DoNotUse& other);
  static const Metadata_RelationsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Metadata_RelationsEntry_DoNotUse*>(&_Metadata_RelationsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "openfga.v1.Metadata.RelationsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_openfga_2fv1_2fauthzmodel_2eproto;
};

// -------------------------------------------------------------------

class Metadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.Metadata) */ {
 public:
  inline Metadata() : Metadata(nullptr) {}
  ~Metadata() override;
  explicit PROTOBUF_CONSTEXPR Metadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Metadata(const Metadata& from);
  Metadata(Metadata&& from) noexcept
    : Metadata() {
    *this = ::std::move(from);
  }

  inline Metadata& operator=(const Metadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metadata& operator=(Metadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Metadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const Metadata* internal_default_instance() {
    return reinterpret_cast<const Metadata*>(
               &_Metadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Metadata& a, Metadata& b) {
    a.Swap(&b);
  }
  inline void Swap(Metadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Metadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Metadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Metadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Metadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Metadata& from) {
    Metadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Metadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.Metadata";
  }
  protected:
  explicit Metadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kRelationsFieldNumber = 1,
    kModuleFieldNumber = 2,
    kSourceInfoFieldNumber = 3,
  };
  // map<string, .openfga.v1.RelationMetadata> relations = 1 [json_name = "relations"];
  int relations_size() const;
  private:
  int _internal_relations_size() const;
  public:
  void clear_relations();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::RelationMetadata >&
      _internal_relations() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::RelationMetadata >*
      _internal_mutable_relations();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::RelationMetadata >&
      relations() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::RelationMetadata >*
      mutable_relations();

  // string module = 2 [json_name = "module", (.validate.rules) = {
  void clear_module();
  const std::string& module() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_module(ArgT0&& arg0, ArgT... args);
  std::string* mutable_module();
  PROTOBUF_NODISCARD std::string* release_module();
  void set_allocated_module(std::string* module);
  private:
  const std::string& _internal_module() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module(const std::string& value);
  std::string* _internal_mutable_module();
  public:

  // .openfga.v1.SourceInfo source_info = 3 [json_name = "source_info"];
  bool has_source_info() const;
  private:
  bool _internal_has_source_info() const;
  public:
  void clear_source_info();
  const ::openfga::v1::SourceInfo& source_info() const;
  PROTOBUF_NODISCARD ::openfga::v1::SourceInfo* release_source_info();
  ::openfga::v1::SourceInfo* mutable_source_info();
  void set_allocated_source_info(::openfga::v1::SourceInfo* source_info);
  private:
  const ::openfga::v1::SourceInfo& _internal_source_info() const;
  ::openfga::v1::SourceInfo* _internal_mutable_source_info();
  public:
  void unsafe_arena_set_allocated_source_info(
      ::openfga::v1::SourceInfo* source_info);
  ::openfga::v1::SourceInfo* unsafe_arena_release_source_info();

  // @@protoc_insertion_point(class_scope:openfga.v1.Metadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Metadata_RelationsEntry_DoNotUse,
        std::string, ::openfga::v1::RelationMetadata,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> relations_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_;
    ::openfga::v1::SourceInfo* source_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fauthzmodel_2eproto;
};
// -------------------------------------------------------------------

class SourceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.SourceInfo) */ {
 public:
  inline SourceInfo() : SourceInfo(nullptr) {}
  ~SourceInfo() override;
  explicit PROTOBUF_CONSTEXPR SourceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SourceInfo(const SourceInfo& from);
  SourceInfo(SourceInfo&& from) noexcept
    : SourceInfo() {
    *this = ::std::move(from);
  }

  inline SourceInfo& operator=(const SourceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SourceInfo& operator=(SourceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SourceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SourceInfo* internal_default_instance() {
    return reinterpret_cast<const SourceInfo*>(
               &_SourceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SourceInfo& a, SourceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SourceInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SourceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SourceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SourceInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SourceInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SourceInfo& from) {
    SourceInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SourceInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.SourceInfo";
  }
  protected:
  explicit SourceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileFieldNumber = 1,
  };
  // string file = 1 [json_name = "file", (.validate.rules) = {
  void clear_file();
  const std::string& file() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file();
  PROTOBUF_NODISCARD std::string* release_file();
  void set_allocated_file(std::string* file);
  private:
  const std::string& _internal_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file(const std::string& value);
  std::string* _internal_mutable_file();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.SourceInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fauthzmodel_2eproto;
};
// -------------------------------------------------------------------

class RelationMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.RelationMetadata) */ {
 public:
  inline RelationMetadata() : RelationMetadata(nullptr) {}
  ~RelationMetadata() override;
  explicit PROTOBUF_CONSTEXPR RelationMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelationMetadata(const RelationMetadata& from);
  RelationMetadata(RelationMetadata&& from) noexcept
    : RelationMetadata() {
    *this = ::std::move(from);
  }

  inline RelationMetadata& operator=(const RelationMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelationMetadata& operator=(RelationMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelationMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelationMetadata* internal_default_instance() {
    return reinterpret_cast<const RelationMetadata*>(
               &_RelationMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RelationMetadata& a, RelationMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(RelationMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelationMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelationMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelationMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RelationMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RelationMetadata& from) {
    RelationMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelationMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.RelationMetadata";
  }
  protected:
  explicit RelationMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirectlyRelatedUserTypesFieldNumber = 1,
    kModuleFieldNumber = 2,
    kSourceInfoFieldNumber = 3,
  };
  // repeated .openfga.v1.RelationReference directly_related_user_types = 1 [json_name = "directly_related_user_types"];
  int directly_related_user_types_size() const;
  private:
  int _internal_directly_related_user_types_size() const;
  public:
  void clear_directly_related_user_types();
  ::openfga::v1::RelationReference* mutable_directly_related_user_types(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::RelationReference >*
      mutable_directly_related_user_types();
  private:
  const ::openfga::v1::RelationReference& _internal_directly_related_user_types(int index) const;
  ::openfga::v1::RelationReference* _internal_add_directly_related_user_types();
  public:
  const ::openfga::v1::RelationReference& directly_related_user_types(int index) const;
  ::openfga::v1::RelationReference* add_directly_related_user_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::RelationReference >&
      directly_related_user_types() const;

  // string module = 2 [json_name = "module", (.validate.rules) = {
  void clear_module();
  const std::string& module() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_module(ArgT0&& arg0, ArgT... args);
  std::string* mutable_module();
  PROTOBUF_NODISCARD std::string* release_module();
  void set_allocated_module(std::string* module);
  private:
  const std::string& _internal_module() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module(const std::string& value);
  std::string* _internal_mutable_module();
  public:

  // .openfga.v1.SourceInfo source_info = 3 [json_name = "source_info"];
  bool has_source_info() const;
  private:
  bool _internal_has_source_info() const;
  public:
  void clear_source_info();
  const ::openfga::v1::SourceInfo& source_info() const;
  PROTOBUF_NODISCARD ::openfga::v1::SourceInfo* release_source_info();
  ::openfga::v1::SourceInfo* mutable_source_info();
  void set_allocated_source_info(::openfga::v1::SourceInfo* source_info);
  private:
  const ::openfga::v1::SourceInfo& _internal_source_info() const;
  ::openfga::v1::SourceInfo* _internal_mutable_source_info();
  public:
  void unsafe_arena_set_allocated_source_info(
      ::openfga::v1::SourceInfo* source_info);
  ::openfga::v1::SourceInfo* unsafe_arena_release_source_info();

  // @@protoc_insertion_point(class_scope:openfga.v1.RelationMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::RelationReference > directly_related_user_types_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_;
    ::openfga::v1::SourceInfo* source_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fauthzmodel_2eproto;
};
// -------------------------------------------------------------------

class RelationReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.RelationReference) */ {
 public:
  inline RelationReference() : RelationReference(nullptr) {}
  ~RelationReference() override;
  explicit PROTOBUF_CONSTEXPR RelationReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelationReference(const RelationReference& from);
  RelationReference(RelationReference&& from) noexcept
    : RelationReference() {
    *this = ::std::move(from);
  }

  inline RelationReference& operator=(const RelationReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelationReference& operator=(RelationReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelationReference& default_instance() {
    return *internal_default_instance();
  }
  enum RelationOrWildcardCase {
    kRelation = 2,
    kWildcard = 3,
    RELATION_OR_WILDCARD_NOT_SET = 0,
  };

  static inline const RelationReference* internal_default_instance() {
    return reinterpret_cast<const RelationReference*>(
               &_RelationReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RelationReference& a, RelationReference& b) {
    a.Swap(&b);
  }
  inline void Swap(RelationReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelationReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelationReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelationReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RelationReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RelationReference& from) {
    RelationReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelationReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.RelationReference";
  }
  protected:
  explicit RelationReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kConditionFieldNumber = 4,
    kRelationFieldNumber = 2,
    kWildcardFieldNumber = 3,
  };
  // string type = 1 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string condition = 4 [json_name = "condition", (.validate.rules) = {
  void clear_condition();
  const std::string& condition() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_condition(ArgT0&& arg0, ArgT... args);
  std::string* mutable_condition();
  PROTOBUF_NODISCARD std::string* release_condition();
  void set_allocated_condition(std::string* condition);
  private:
  const std::string& _internal_condition() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_condition(const std::string& value);
  std::string* _internal_mutable_condition();
  public:

  // string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  bool has_relation() const;
  private:
  bool _internal_has_relation() const;
  public:
  void clear_relation();
  const std::string& relation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_relation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_relation();
  PROTOBUF_NODISCARD std::string* release_relation();
  void set_allocated_relation(std::string* relation);
  private:
  const std::string& _internal_relation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relation(const std::string& value);
  std::string* _internal_mutable_relation();
  public:

  // .openfga.v1.Wildcard wildcard = 3 [json_name = "wildcard"];
  bool has_wildcard() const;
  private:
  bool _internal_has_wildcard() const;
  public:
  void clear_wildcard();
  const ::openfga::v1::Wildcard& wildcard() const;
  PROTOBUF_NODISCARD ::openfga::v1::Wildcard* release_wildcard();
  ::openfga::v1::Wildcard* mutable_wildcard();
  void set_allocated_wildcard(::openfga::v1::Wildcard* wildcard);
  private:
  const ::openfga::v1::Wildcard& _internal_wildcard() const;
  ::openfga::v1::Wildcard* _internal_mutable_wildcard();
  public:
  void unsafe_arena_set_allocated_wildcard(
      ::openfga::v1::Wildcard* wildcard);
  ::openfga::v1::Wildcard* unsafe_arena_release_wildcard();

  void clear_relation_or_wildcard();
  RelationOrWildcardCase relation_or_wildcard_case() const;
  // @@protoc_insertion_point(class_scope:openfga.v1.RelationReference)
 private:
  class _Internal;
  void set_has_relation();
  void set_has_wildcard();

  inline bool has_relation_or_wildcard() const;
  inline void clear_has_relation_or_wildcard();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr condition_;
    union RelationOrWildcardUnion {
      constexpr RelationOrWildcardUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relation_;
      ::openfga::v1::Wildcard* wildcard_;
    } relation_or_wildcard_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fauthzmodel_2eproto;
};
// -------------------------------------------------------------------

class Wildcard final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:openfga.v1.Wildcard) */ {
 public:
  inline Wildcard() : Wildcard(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Wildcard(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Wildcard(const Wildcard& from);
  Wildcard(Wildcard&& from) noexcept
    : Wildcard() {
    *this = ::std::move(from);
  }

  inline Wildcard& operator=(const Wildcard& from) {
    CopyFrom(from);
    return *this;
  }
  inline Wildcard& operator=(Wildcard&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Wildcard& default_instance() {
    return *internal_default_instance();
  }
  static inline const Wildcard* internal_default_instance() {
    return reinterpret_cast<const Wildcard*>(
               &_Wildcard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Wildcard& a, Wildcard& b) {
    a.Swap(&b);
  }
  inline void Swap(Wildcard* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Wildcard* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Wildcard* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Wildcard>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Wildcard& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Wildcard& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.Wildcard";
  }
  protected:
  explicit Wildcard(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:openfga.v1.Wildcard)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_openfga_2fv1_2fauthzmodel_2eproto;
};
// -------------------------------------------------------------------

class Usersets final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.Usersets) */ {
 public:
  inline Usersets() : Usersets(nullptr) {}
  ~Usersets() override;
  explicit PROTOBUF_CONSTEXPR Usersets(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Usersets(const Usersets& from);
  Usersets(Usersets&& from) noexcept
    : Usersets() {
    *this = ::std::move(from);
  }

  inline Usersets& operator=(const Usersets& from) {
    CopyFrom(from);
    return *this;
  }
  inline Usersets& operator=(Usersets&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Usersets& default_instance() {
    return *internal_default_instance();
  }
  static inline const Usersets* internal_default_instance() {
    return reinterpret_cast<const Usersets*>(
               &_Usersets_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Usersets& a, Usersets& b) {
    a.Swap(&b);
  }
  inline void Swap(Usersets* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Usersets* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Usersets* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Usersets>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Usersets& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Usersets& from) {
    Usersets::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Usersets* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.Usersets";
  }
  protected:
  explicit Usersets(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildFieldNumber = 1,
  };
  // repeated .openfga.v1.Userset child = 1 [json_name = "child", (.google.api.field_behavior) = REQUIRED];
  int child_size() const;
  private:
  int _internal_child_size() const;
  public:
  void clear_child();
  ::openfga::v1::Userset* mutable_child(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Userset >*
      mutable_child();
  private:
  const ::openfga::v1::Userset& _internal_child(int index) const;
  ::openfga::v1::Userset* _internal_add_child();
  public:
  const ::openfga::v1::Userset& child(int index) const;
  ::openfga::v1::Userset* add_child();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Userset >&
      child() const;

  // @@protoc_insertion_point(class_scope:openfga.v1.Usersets)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Userset > child_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fauthzmodel_2eproto;
};
// -------------------------------------------------------------------

class Difference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.Difference) */ {
 public:
  inline Difference() : Difference(nullptr) {}
  ~Difference() override;
  explicit PROTOBUF_CONSTEXPR Difference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Difference(const Difference& from);
  Difference(Difference&& from) noexcept
    : Difference() {
    *this = ::std::move(from);
  }

  inline Difference& operator=(const Difference& from) {
    CopyFrom(from);
    return *this;
  }
  inline Difference& operator=(Difference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Difference& default_instance() {
    return *internal_default_instance();
  }
  static inline const Difference* internal_default_instance() {
    return reinterpret_cast<const Difference*>(
               &_Difference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Difference& a, Difference& b) {
    a.Swap(&b);
  }
  inline void Swap(Difference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Difference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Difference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Difference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Difference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Difference& from) {
    Difference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Difference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.Difference";
  }
  protected:
  explicit Difference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseFieldNumber = 1,
    kSubtractFieldNumber = 2,
  };
  // .openfga.v1.Userset base = 1 [json_name = "base", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::openfga::v1::Userset& base() const;
  PROTOBUF_NODISCARD ::openfga::v1::Userset* release_base();
  ::openfga::v1::Userset* mutable_base();
  void set_allocated_base(::openfga::v1::Userset* base);
  private:
  const ::openfga::v1::Userset& _internal_base() const;
  ::openfga::v1::Userset* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::openfga::v1::Userset* base);
  ::openfga::v1::Userset* unsafe_arena_release_base();

  // .openfga.v1.Userset subtract = 2 [json_name = "subtract", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_subtract() const;
  private:
  bool _internal_has_subtract() const;
  public:
  void clear_subtract();
  const ::openfga::v1::Userset& subtract() const;
  PROTOBUF_NODISCARD ::openfga::v1::Userset* release_subtract();
  ::openfga::v1::Userset* mutable_subtract();
  void set_allocated_subtract(::openfga::v1::Userset* subtract);
  private:
  const ::openfga::v1::Userset& _internal_subtract() const;
  ::openfga::v1::Userset* _internal_mutable_subtract();
  public:
  void unsafe_arena_set_allocated_subtract(
      ::openfga::v1::Userset* subtract);
  ::openfga::v1::Userset* unsafe_arena_release_subtract();

  // @@protoc_insertion_point(class_scope:openfga.v1.Difference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::openfga::v1::Userset* base_;
    ::openfga::v1::Userset* subtract_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fauthzmodel_2eproto;
};
// -------------------------------------------------------------------

class Userset final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.Userset) */ {
 public:
  inline Userset() : Userset(nullptr) {}
  ~Userset() override;
  explicit PROTOBUF_CONSTEXPR Userset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Userset(const Userset& from);
  Userset(Userset&& from) noexcept
    : Userset() {
    *this = ::std::move(from);
  }

  inline Userset& operator=(const Userset& from) {
    CopyFrom(from);
    return *this;
  }
  inline Userset& operator=(Userset&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Userset& default_instance() {
    return *internal_default_instance();
  }
  enum UsersetCase {
    kThis = 1,
    kComputedUserset = 2,
    kTupleToUserset = 3,
    kUnion = 4,
    kIntersection = 5,
    kDifference = 6,
    USERSET_NOT_SET = 0,
  };

  static inline const Userset* internal_default_instance() {
    return reinterpret_cast<const Userset*>(
               &_Userset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Userset& a, Userset& b) {
    a.Swap(&b);
  }
  inline void Swap(Userset* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Userset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Userset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Userset>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Userset& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Userset& from) {
    Userset::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Userset* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.Userset";
  }
  protected:
  explicit Userset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThisFieldNumber = 1,
    kComputedUsersetFieldNumber = 2,
    kTupleToUsersetFieldNumber = 3,
    kUnionFieldNumber = 4,
    kIntersectionFieldNumber = 5,
    kDifferenceFieldNumber = 6,
  };
  // .openfga.v1.DirectUserset this = 1 [json_name = "this"];
  bool has_this_() const;
  private:
  bool _internal_has_this_() const;
  public:
  void clear_this_();
  const ::openfga::v1::DirectUserset& this_() const;
  PROTOBUF_NODISCARD ::openfga::v1::DirectUserset* release_this_();
  ::openfga::v1::DirectUserset* mutable_this_();
  void set_allocated_this_(::openfga::v1::DirectUserset* this_);
  private:
  const ::openfga::v1::DirectUserset& _internal_this_() const;
  ::openfga::v1::DirectUserset* _internal_mutable_this_();
  public:
  void unsafe_arena_set_allocated_this_(
      ::openfga::v1::DirectUserset* this_);
  ::openfga::v1::DirectUserset* unsafe_arena_release_this_();

  // .openfga.v1.ObjectRelation computed_userset = 2 [json_name = "computedUserset"];
  bool has_computed_userset() const;
  private:
  bool _internal_has_computed_userset() const;
  public:
  void clear_computed_userset();
  const ::openfga::v1::ObjectRelation& computed_userset() const;
  PROTOBUF_NODISCARD ::openfga::v1::ObjectRelation* release_computed_userset();
  ::openfga::v1::ObjectRelation* mutable_computed_userset();
  void set_allocated_computed_userset(::openfga::v1::ObjectRelation* computed_userset);
  private:
  const ::openfga::v1::ObjectRelation& _internal_computed_userset() const;
  ::openfga::v1::ObjectRelation* _internal_mutable_computed_userset();
  public:
  void unsafe_arena_set_allocated_computed_userset(
      ::openfga::v1::ObjectRelation* computed_userset);
  ::openfga::v1::ObjectRelation* unsafe_arena_release_computed_userset();

  // .openfga.v1.TupleToUserset tuple_to_userset = 3 [json_name = "tupleToUserset"];
  bool has_tuple_to_userset() const;
  private:
  bool _internal_has_tuple_to_userset() const;
  public:
  void clear_tuple_to_userset();
  const ::openfga::v1::TupleToUserset& tuple_to_userset() const;
  PROTOBUF_NODISCARD ::openfga::v1::TupleToUserset* release_tuple_to_userset();
  ::openfga::v1::TupleToUserset* mutable_tuple_to_userset();
  void set_allocated_tuple_to_userset(::openfga::v1::TupleToUserset* tuple_to_userset);
  private:
  const ::openfga::v1::TupleToUserset& _internal_tuple_to_userset() const;
  ::openfga::v1::TupleToUserset* _internal_mutable_tuple_to_userset();
  public:
  void unsafe_arena_set_allocated_tuple_to_userset(
      ::openfga::v1::TupleToUserset* tuple_to_userset);
  ::openfga::v1::TupleToUserset* unsafe_arena_release_tuple_to_userset();

  // .openfga.v1.Usersets union = 4 [json_name = "union"];
  bool has_union_() const;
  private:
  bool _internal_has_union_() const;
  public:
  void clear_union_();
  const ::openfga::v1::Usersets& union_() const;
  PROTOBUF_NODISCARD ::openfga::v1::Usersets* release_union_();
  ::openfga::v1::Usersets* mutable_union_();
  void set_allocated_union_(::openfga::v1::Usersets* union_);
  private:
  const ::openfga::v1::Usersets& _internal_union_() const;
  ::openfga::v1::Usersets* _internal_mutable_union_();
  public:
  void unsafe_arena_set_allocated_union_(
      ::openfga::v1::Usersets* union_);
  ::openfga::v1::Usersets* unsafe_arena_release_union_();

  // .openfga.v1.Usersets intersection = 5 [json_name = "intersection"];
  bool has_intersection() const;
  private:
  bool _internal_has_intersection() const;
  public:
  void clear_intersection();
  const ::openfga::v1::Usersets& intersection() const;
  PROTOBUF_NODISCARD ::openfga::v1::Usersets* release_intersection();
  ::openfga::v1::Usersets* mutable_intersection();
  void set_allocated_intersection(::openfga::v1::Usersets* intersection);
  private:
  const ::openfga::v1::Usersets& _internal_intersection() const;
  ::openfga::v1::Usersets* _internal_mutable_intersection();
  public:
  void unsafe_arena_set_allocated_intersection(
      ::openfga::v1::Usersets* intersection);
  ::openfga::v1::Usersets* unsafe_arena_release_intersection();

  // .openfga.v1.Difference difference = 6 [json_name = "difference"];
  bool has_difference() const;
  private:
  bool _internal_has_difference() const;
  public:
  void clear_difference();
  const ::openfga::v1::Difference& difference() const;
  PROTOBUF_NODISCARD ::openfga::v1::Difference* release_difference();
  ::openfga::v1::Difference* mutable_difference();
  void set_allocated_difference(::openfga::v1::Difference* difference);
  private:
  const ::openfga::v1::Difference& _internal_difference() const;
  ::openfga::v1::Difference* _internal_mutable_difference();
  public:
  void unsafe_arena_set_allocated_difference(
      ::openfga::v1::Difference* difference);
  ::openfga::v1::Difference* unsafe_arena_release_difference();

  void clear_userset();
  UsersetCase userset_case() const;
  // @@protoc_insertion_point(class_scope:openfga.v1.Userset)
 private:
  class _Internal;
  void set_has_this_();
  void set_has_computed_userset();
  void set_has_tuple_to_userset();
  void set_has_union_();
  void set_has_intersection();
  void set_has_difference();

  inline bool has_userset() const;
  inline void clear_has_userset();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union UsersetUnion {
      constexpr UsersetUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::openfga::v1::DirectUserset* this__;
      ::openfga::v1::ObjectRelation* computed_userset_;
      ::openfga::v1::TupleToUserset* tuple_to_userset_;
      ::openfga::v1::Usersets* union__;
      ::openfga::v1::Usersets* intersection_;
      ::openfga::v1::Difference* difference_;
    } userset_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fauthzmodel_2eproto;
};
// -------------------------------------------------------------------

class DirectUserset final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:openfga.v1.DirectUserset) */ {
 public:
  inline DirectUserset() : DirectUserset(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DirectUserset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectUserset(const DirectUserset& from);
  DirectUserset(DirectUserset&& from) noexcept
    : DirectUserset() {
    *this = ::std::move(from);
  }

  inline DirectUserset& operator=(const DirectUserset& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectUserset& operator=(DirectUserset&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DirectUserset& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectUserset* internal_default_instance() {
    return reinterpret_cast<const DirectUserset*>(
               &_DirectUserset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(DirectUserset& a, DirectUserset& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectUserset* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectUserset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DirectUserset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DirectUserset>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DirectUserset& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DirectUserset& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.DirectUserset";
  }
  protected:
  explicit DirectUserset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:openfga.v1.DirectUserset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_openfga_2fv1_2fauthzmodel_2eproto;
};
// -------------------------------------------------------------------

class ObjectRelation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ObjectRelation) */ {
 public:
  inline ObjectRelation() : ObjectRelation(nullptr) {}
  ~ObjectRelation() override;
  explicit PROTOBUF_CONSTEXPR ObjectRelation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectRelation(const ObjectRelation& from);
  ObjectRelation(ObjectRelation&& from) noexcept
    : ObjectRelation() {
    *this = ::std::move(from);
  }

  inline ObjectRelation& operator=(const ObjectRelation& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectRelation& operator=(ObjectRelation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectRelation& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectRelation* internal_default_instance() {
    return reinterpret_cast<const ObjectRelation*>(
               &_ObjectRelation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ObjectRelation& a, ObjectRelation& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectRelation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectRelation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectRelation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectRelation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectRelation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObjectRelation& from) {
    ObjectRelation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectRelation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ObjectRelation";
  }
  protected:
  explicit ObjectRelation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
    kRelationFieldNumber = 2,
  };
  // string object = 1 [json_name = "object", (.validate.rules) = {
  void clear_object();
  const std::string& object() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_object(ArgT0&& arg0, ArgT... args);
  std::string* mutable_object();
  PROTOBUF_NODISCARD std::string* release_object();
  void set_allocated_object(std::string* object);
  private:
  const std::string& _internal_object() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object(const std::string& value);
  std::string* _internal_mutable_object();
  public:

  // string relation = 2 [json_name = "relation", (.validate.rules) = {
  void clear_relation();
  const std::string& relation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_relation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_relation();
  PROTOBUF_NODISCARD std::string* release_relation();
  void set_allocated_relation(std::string* relation);
  private:
  const std::string& _internal_relation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relation(const std::string& value);
  std::string* _internal_mutable_relation();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.ObjectRelation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr object_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fauthzmodel_2eproto;
};
// -------------------------------------------------------------------

class ComputedUserset final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ComputedUserset) */ {
 public:
  inline ComputedUserset() : ComputedUserset(nullptr) {}
  ~ComputedUserset() override;
  explicit PROTOBUF_CONSTEXPR ComputedUserset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ComputedUserset(const ComputedUserset& from);
  ComputedUserset(ComputedUserset&& from) noexcept
    : ComputedUserset() {
    *this = ::std::move(from);
  }

  inline ComputedUserset& operator=(const ComputedUserset& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComputedUserset& operator=(ComputedUserset&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ComputedUserset& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComputedUserset* internal_default_instance() {
    return reinterpret_cast<const ComputedUserset*>(
               &_ComputedUserset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ComputedUserset& a, ComputedUserset& b) {
    a.Swap(&b);
  }
  inline void Swap(ComputedUserset* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComputedUserset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ComputedUserset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ComputedUserset>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ComputedUserset& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ComputedUserset& from) {
    ComputedUserset::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ComputedUserset* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ComputedUserset";
  }
  protected:
  explicit ComputedUserset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRelationFieldNumber = 1,
  };
  // string relation = 1 [json_name = "relation", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_relation();
  const std::string& relation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_relation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_relation();
  PROTOBUF_NODISCARD std::string* release_relation();
  void set_allocated_relation(std::string* relation);
  private:
  const std::string& _internal_relation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relation(const std::string& value);
  std::string* _internal_mutable_relation();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.ComputedUserset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fauthzmodel_2eproto;
};
// -------------------------------------------------------------------

class TupleToUserset final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.TupleToUserset) */ {
 public:
  inline TupleToUserset() : TupleToUserset(nullptr) {}
  ~TupleToUserset() override;
  explicit PROTOBUF_CONSTEXPR TupleToUserset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TupleToUserset(const TupleToUserset& from);
  TupleToUserset(TupleToUserset&& from) noexcept
    : TupleToUserset() {
    *this = ::std::move(from);
  }

  inline TupleToUserset& operator=(const TupleToUserset& from) {
    CopyFrom(from);
    return *this;
  }
  inline TupleToUserset& operator=(TupleToUserset&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TupleToUserset& default_instance() {
    return *internal_default_instance();
  }
  static inline const TupleToUserset* internal_default_instance() {
    return reinterpret_cast<const TupleToUserset*>(
               &_TupleToUserset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(TupleToUserset& a, TupleToUserset& b) {
    a.Swap(&b);
  }
  inline void Swap(TupleToUserset* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TupleToUserset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TupleToUserset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TupleToUserset>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TupleToUserset& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TupleToUserset& from) {
    TupleToUserset::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TupleToUserset* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.TupleToUserset";
  }
  protected:
  explicit TupleToUserset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTuplesetFieldNumber = 1,
    kComputedUsersetFieldNumber = 2,
  };
  // .openfga.v1.ObjectRelation tupleset = 1 [json_name = "tupleset", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_tupleset() const;
  private:
  bool _internal_has_tupleset() const;
  public:
  void clear_tupleset();
  const ::openfga::v1::ObjectRelation& tupleset() const;
  PROTOBUF_NODISCARD ::openfga::v1::ObjectRelation* release_tupleset();
  ::openfga::v1::ObjectRelation* mutable_tupleset();
  void set_allocated_tupleset(::openfga::v1::ObjectRelation* tupleset);
  private:
  const ::openfga::v1::ObjectRelation& _internal_tupleset() const;
  ::openfga::v1::ObjectRelation* _internal_mutable_tupleset();
  public:
  void unsafe_arena_set_allocated_tupleset(
      ::openfga::v1::ObjectRelation* tupleset);
  ::openfga::v1::ObjectRelation* unsafe_arena_release_tupleset();

  // .openfga.v1.ObjectRelation computed_userset = 2 [json_name = "computedUserset", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_computed_userset() const;
  private:
  bool _internal_has_computed_userset() const;
  public:
  void clear_computed_userset();
  const ::openfga::v1::ObjectRelation& computed_userset() const;
  PROTOBUF_NODISCARD ::openfga::v1::ObjectRelation* release_computed_userset();
  ::openfga::v1::ObjectRelation* mutable_computed_userset();
  void set_allocated_computed_userset(::openfga::v1::ObjectRelation* computed_userset);
  private:
  const ::openfga::v1::ObjectRelation& _internal_computed_userset() const;
  ::openfga::v1::ObjectRelation* _internal_mutable_computed_userset();
  public:
  void unsafe_arena_set_allocated_computed_userset(
      ::openfga::v1::ObjectRelation* computed_userset);
  ::openfga::v1::ObjectRelation* unsafe_arena_release_computed_userset();

  // @@protoc_insertion_point(class_scope:openfga.v1.TupleToUserset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::openfga::v1::ObjectRelation* tupleset_;
    ::openfga::v1::ObjectRelation* computed_userset_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fauthzmodel_2eproto;
};
// -------------------------------------------------------------------

class Condition_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Condition_ParametersEntry_DoNotUse, 
    std::string, ::openfga::v1::ConditionParamTypeRef,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Condition_ParametersEntry_DoNotUse, 
    std::string, ::openfga::v1::ConditionParamTypeRef,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Condition_ParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Condition_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Condition_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Condition_ParametersEntry_DoNotUse& other);
  static const Condition_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Condition_ParametersEntry_DoNotUse*>(&_Condition_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "openfga.v1.Condition.ParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_openfga_2fv1_2fauthzmodel_2eproto;
};

// -------------------------------------------------------------------

class Condition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.Condition) */ {
 public:
  inline Condition() : Condition(nullptr) {}
  ~Condition() override;
  explicit PROTOBUF_CONSTEXPR Condition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Condition(const Condition& from);
  Condition(Condition&& from) noexcept
    : Condition() {
    *this = ::std::move(from);
  }

  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Condition& operator=(Condition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Condition& default_instance() {
    return *internal_default_instance();
  }
  static inline const Condition* internal_default_instance() {
    return reinterpret_cast<const Condition*>(
               &_Condition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Condition& a, Condition& b) {
    a.Swap(&b);
  }
  inline void Swap(Condition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Condition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Condition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Condition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Condition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Condition& from) {
    Condition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Condition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.Condition";
  }
  protected:
  explicit Condition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 3,
    kNameFieldNumber = 1,
    kExpressionFieldNumber = 2,
    kMetadataFieldNumber = 4,
  };
  // map<string, .openfga.v1.ConditionParamTypeRef> parameters = 3 [json_name = "parameters", (.validate.rules) = {
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::ConditionParamTypeRef >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::ConditionParamTypeRef >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::ConditionParamTypeRef >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::ConditionParamTypeRef >*
      mutable_parameters();

  // string name = 1 [json_name = "name", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string expression = 2 [json_name = "expression", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_expression();
  const std::string& expression() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_expression(ArgT0&& arg0, ArgT... args);
  std::string* mutable_expression();
  PROTOBUF_NODISCARD std::string* release_expression();
  void set_allocated_expression(std::string* expression);
  private:
  const std::string& _internal_expression() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expression(const std::string& value);
  std::string* _internal_mutable_expression();
  public:

  // .openfga.v1.ConditionMetadata metadata = 4 [json_name = "metadata"];
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::openfga::v1::ConditionMetadata& metadata() const;
  PROTOBUF_NODISCARD ::openfga::v1::ConditionMetadata* release_metadata();
  ::openfga::v1::ConditionMetadata* mutable_metadata();
  void set_allocated_metadata(::openfga::v1::ConditionMetadata* metadata);
  private:
  const ::openfga::v1::ConditionMetadata& _internal_metadata() const;
  ::openfga::v1::ConditionMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::openfga::v1::ConditionMetadata* metadata);
  ::openfga::v1::ConditionMetadata* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:openfga.v1.Condition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Condition_ParametersEntry_DoNotUse,
        std::string, ::openfga::v1::ConditionParamTypeRef,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> parameters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr expression_;
    ::openfga::v1::ConditionMetadata* metadata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fauthzmodel_2eproto;
};
// -------------------------------------------------------------------

class ConditionMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ConditionMetadata) */ {
 public:
  inline ConditionMetadata() : ConditionMetadata(nullptr) {}
  ~ConditionMetadata() override;
  explicit PROTOBUF_CONSTEXPR ConditionMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConditionMetadata(const ConditionMetadata& from);
  ConditionMetadata(ConditionMetadata&& from) noexcept
    : ConditionMetadata() {
    *this = ::std::move(from);
  }

  inline ConditionMetadata& operator=(const ConditionMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConditionMetadata& operator=(ConditionMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConditionMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConditionMetadata* internal_default_instance() {
    return reinterpret_cast<const ConditionMetadata*>(
               &_ConditionMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ConditionMetadata& a, ConditionMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(ConditionMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConditionMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConditionMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConditionMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConditionMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConditionMetadata& from) {
    ConditionMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ConditionMetadata";
  }
  protected:
  explicit ConditionMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModuleFieldNumber = 1,
    kSourceInfoFieldNumber = 2,
  };
  // string module = 1 [json_name = "module", (.validate.rules) = {
  void clear_module();
  const std::string& module() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_module(ArgT0&& arg0, ArgT... args);
  std::string* mutable_module();
  PROTOBUF_NODISCARD std::string* release_module();
  void set_allocated_module(std::string* module);
  private:
  const std::string& _internal_module() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module(const std::string& value);
  std::string* _internal_mutable_module();
  public:

  // .openfga.v1.SourceInfo source_info = 2 [json_name = "source_info"];
  bool has_source_info() const;
  private:
  bool _internal_has_source_info() const;
  public:
  void clear_source_info();
  const ::openfga::v1::SourceInfo& source_info() const;
  PROTOBUF_NODISCARD ::openfga::v1::SourceInfo* release_source_info();
  ::openfga::v1::SourceInfo* mutable_source_info();
  void set_allocated_source_info(::openfga::v1::SourceInfo* source_info);
  private:
  const ::openfga::v1::SourceInfo& _internal_source_info() const;
  ::openfga::v1::SourceInfo* _internal_mutable_source_info();
  public:
  void unsafe_arena_set_allocated_source_info(
      ::openfga::v1::SourceInfo* source_info);
  ::openfga::v1::SourceInfo* unsafe_arena_release_source_info();

  // @@protoc_insertion_point(class_scope:openfga.v1.ConditionMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_;
    ::openfga::v1::SourceInfo* source_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fauthzmodel_2eproto;
};
// -------------------------------------------------------------------

class ConditionParamTypeRef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ConditionParamTypeRef) */ {
 public:
  inline ConditionParamTypeRef() : ConditionParamTypeRef(nullptr) {}
  ~ConditionParamTypeRef() override;
  explicit PROTOBUF_CONSTEXPR ConditionParamTypeRef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConditionParamTypeRef(const ConditionParamTypeRef& from);
  ConditionParamTypeRef(ConditionParamTypeRef&& from) noexcept
    : ConditionParamTypeRef() {
    *this = ::std::move(from);
  }

  inline ConditionParamTypeRef& operator=(const ConditionParamTypeRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConditionParamTypeRef& operator=(ConditionParamTypeRef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConditionParamTypeRef& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConditionParamTypeRef* internal_default_instance() {
    return reinterpret_cast<const ConditionParamTypeRef*>(
               &_ConditionParamTypeRef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ConditionParamTypeRef& a, ConditionParamTypeRef& b) {
    a.Swap(&b);
  }
  inline void Swap(ConditionParamTypeRef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConditionParamTypeRef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConditionParamTypeRef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConditionParamTypeRef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConditionParamTypeRef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConditionParamTypeRef& from) {
    ConditionParamTypeRef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionParamTypeRef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ConditionParamTypeRef";
  }
  protected:
  explicit ConditionParamTypeRef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ConditionParamTypeRef_TypeName TypeName;
  static constexpr TypeName TYPE_NAME_UNSPECIFIED =
    ConditionParamTypeRef_TypeName_TYPE_NAME_UNSPECIFIED;
  static constexpr TypeName TYPE_NAME_ANY =
    ConditionParamTypeRef_TypeName_TYPE_NAME_ANY;
  static constexpr TypeName TYPE_NAME_BOOL =
    ConditionParamTypeRef_TypeName_TYPE_NAME_BOOL;
  static constexpr TypeName TYPE_NAME_STRING =
    ConditionParamTypeRef_TypeName_TYPE_NAME_STRING;
  static constexpr TypeName TYPE_NAME_INT =
    ConditionParamTypeRef_TypeName_TYPE_NAME_INT;
  static constexpr TypeName TYPE_NAME_UINT =
    ConditionParamTypeRef_TypeName_TYPE_NAME_UINT;
  static constexpr TypeName TYPE_NAME_DOUBLE =
    ConditionParamTypeRef_TypeName_TYPE_NAME_DOUBLE;
  static constexpr TypeName TYPE_NAME_DURATION =
    ConditionParamTypeRef_TypeName_TYPE_NAME_DURATION;
  static constexpr TypeName TYPE_NAME_TIMESTAMP =
    ConditionParamTypeRef_TypeName_TYPE_NAME_TIMESTAMP;
  static constexpr TypeName TYPE_NAME_MAP =
    ConditionParamTypeRef_TypeName_TYPE_NAME_MAP;
  static constexpr TypeName TYPE_NAME_LIST =
    ConditionParamTypeRef_TypeName_TYPE_NAME_LIST;
  static constexpr TypeName TYPE_NAME_IPADDRESS =
    ConditionParamTypeRef_TypeName_TYPE_NAME_IPADDRESS;
  static inline bool TypeName_IsValid(int value) {
    return ConditionParamTypeRef_TypeName_IsValid(value);
  }
  static constexpr TypeName TypeName_MIN =
    ConditionParamTypeRef_TypeName_TypeName_MIN;
  static constexpr TypeName TypeName_MAX =
    ConditionParamTypeRef_TypeName_TypeName_MAX;
  static constexpr int TypeName_ARRAYSIZE =
    ConditionParamTypeRef_TypeName_TypeName_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TypeName_descriptor() {
    return ConditionParamTypeRef_TypeName_descriptor();
  }
  template<typename T>
  static inline const std::string& TypeName_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TypeName>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TypeName_Name.");
    return ConditionParamTypeRef_TypeName_Name(enum_t_value);
  }
  static inline bool TypeName_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TypeName* value) {
    return ConditionParamTypeRef_TypeName_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGenericTypesFieldNumber = 2,
    kTypeNameFieldNumber = 1,
  };
  // repeated .openfga.v1.ConditionParamTypeRef generic_types = 2 [json_name = "generic_types", (.validate.rules) = {
  int generic_types_size() const;
  private:
  int _internal_generic_types_size() const;
  public:
  void clear_generic_types();
  ::openfga::v1::ConditionParamTypeRef* mutable_generic_types(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::ConditionParamTypeRef >*
      mutable_generic_types();
  private:
  const ::openfga::v1::ConditionParamTypeRef& _internal_generic_types(int index) const;
  ::openfga::v1::ConditionParamTypeRef* _internal_add_generic_types();
  public:
  const ::openfga::v1::ConditionParamTypeRef& generic_types(int index) const;
  ::openfga::v1::ConditionParamTypeRef* add_generic_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::ConditionParamTypeRef >&
      generic_types() const;

  // .openfga.v1.ConditionParamTypeRef.TypeName type_name = 1 [json_name = "type_name", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_type_name();
  ::openfga::v1::ConditionParamTypeRef_TypeName type_name() const;
  void set_type_name(::openfga::v1::ConditionParamTypeRef_TypeName value);
  private:
  ::openfga::v1::ConditionParamTypeRef_TypeName _internal_type_name() const;
  void _internal_set_type_name(::openfga::v1::ConditionParamTypeRef_TypeName value);
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.ConditionParamTypeRef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::ConditionParamTypeRef > generic_types_;
    int type_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fauthzmodel_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// AuthorizationModel

// string id = 1 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void AuthorizationModel::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& AuthorizationModel::id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.AuthorizationModel.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthorizationModel::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.AuthorizationModel.id)
}
inline std::string* AuthorizationModel::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.AuthorizationModel.id)
  return _s;
}
inline const std::string& AuthorizationModel::_internal_id() const {
  return _impl_.id_.Get();
}
inline void AuthorizationModel::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthorizationModel::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthorizationModel::release_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.AuthorizationModel.id)
  return _impl_.id_.Release();
}
inline void AuthorizationModel::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.AuthorizationModel.id)
}

// string schema_version = 2 [json_name = "schema_version", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void AuthorizationModel::clear_schema_version() {
  _impl_.schema_version_.ClearToEmpty();
}
inline const std::string& AuthorizationModel::schema_version() const {
  // @@protoc_insertion_point(field_get:openfga.v1.AuthorizationModel.schema_version)
  return _internal_schema_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthorizationModel::set_schema_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.AuthorizationModel.schema_version)
}
inline std::string* AuthorizationModel::mutable_schema_version() {
  std::string* _s = _internal_mutable_schema_version();
  // @@protoc_insertion_point(field_mutable:openfga.v1.AuthorizationModel.schema_version)
  return _s;
}
inline const std::string& AuthorizationModel::_internal_schema_version() const {
  return _impl_.schema_version_.Get();
}
inline void AuthorizationModel::_internal_set_schema_version(const std::string& value) {
  
  _impl_.schema_version_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthorizationModel::_internal_mutable_schema_version() {
  
  return _impl_.schema_version_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthorizationModel::release_schema_version() {
  // @@protoc_insertion_point(field_release:openfga.v1.AuthorizationModel.schema_version)
  return _impl_.schema_version_.Release();
}
inline void AuthorizationModel::set_allocated_schema_version(std::string* schema_version) {
  if (schema_version != nullptr) {
    
  } else {
    
  }
  _impl_.schema_version_.SetAllocated(schema_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_version_.IsDefault()) {
    _impl_.schema_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.AuthorizationModel.schema_version)
}

// repeated .openfga.v1.TypeDefinition type_definitions = 3 [json_name = "type_definitions", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int AuthorizationModel::_internal_type_definitions_size() const {
  return _impl_.type_definitions_.size();
}
inline int AuthorizationModel::type_definitions_size() const {
  return _internal_type_definitions_size();
}
inline void AuthorizationModel::clear_type_definitions() {
  _impl_.type_definitions_.Clear();
}
inline ::openfga::v1::TypeDefinition* AuthorizationModel::mutable_type_definitions(int index) {
  // @@protoc_insertion_point(field_mutable:openfga.v1.AuthorizationModel.type_definitions)
  return _impl_.type_definitions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TypeDefinition >*
AuthorizationModel::mutable_type_definitions() {
  // @@protoc_insertion_point(field_mutable_list:openfga.v1.AuthorizationModel.type_definitions)
  return &_impl_.type_definitions_;
}
inline const ::openfga::v1::TypeDefinition& AuthorizationModel::_internal_type_definitions(int index) const {
  return _impl_.type_definitions_.Get(index);
}
inline const ::openfga::v1::TypeDefinition& AuthorizationModel::type_definitions(int index) const {
  // @@protoc_insertion_point(field_get:openfga.v1.AuthorizationModel.type_definitions)
  return _internal_type_definitions(index);
}
inline ::openfga::v1::TypeDefinition* AuthorizationModel::_internal_add_type_definitions() {
  return _impl_.type_definitions_.Add();
}
inline ::openfga::v1::TypeDefinition* AuthorizationModel::add_type_definitions() {
  ::openfga::v1::TypeDefinition* _add = _internal_add_type_definitions();
  // @@protoc_insertion_point(field_add:openfga.v1.AuthorizationModel.type_definitions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TypeDefinition >&
AuthorizationModel::type_definitions() const {
  // @@protoc_insertion_point(field_list:openfga.v1.AuthorizationModel.type_definitions)
  return _impl_.type_definitions_;
}

// map<string, .openfga.v1.Condition> conditions = 4 [json_name = "conditions", (.validate.rules) = {
inline int AuthorizationModel::_internal_conditions_size() const {
  return _impl_.conditions_.size();
}
inline int AuthorizationModel::conditions_size() const {
  return _internal_conditions_size();
}
inline void AuthorizationModel::clear_conditions() {
  _impl_.conditions_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::Condition >&
AuthorizationModel::_internal_conditions() const {
  return _impl_.conditions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::Condition >&
AuthorizationModel::conditions() const {
  // @@protoc_insertion_point(field_map:openfga.v1.AuthorizationModel.conditions)
  return _internal_conditions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::Condition >*
AuthorizationModel::_internal_mutable_conditions() {
  return _impl_.conditions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::Condition >*
AuthorizationModel::mutable_conditions() {
  // @@protoc_insertion_point(field_mutable_map:openfga.v1.AuthorizationModel.conditions)
  return _internal_mutable_conditions();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TypeDefinition

// string type = 1 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void TypeDefinition::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& TypeDefinition::type() const {
  // @@protoc_insertion_point(field_get:openfga.v1.TypeDefinition.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TypeDefinition::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.TypeDefinition.type)
}
inline std::string* TypeDefinition::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:openfga.v1.TypeDefinition.type)
  return _s;
}
inline const std::string& TypeDefinition::_internal_type() const {
  return _impl_.type_.Get();
}
inline void TypeDefinition::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* TypeDefinition::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* TypeDefinition::release_type() {
  // @@protoc_insertion_point(field_release:openfga.v1.TypeDefinition.type)
  return _impl_.type_.Release();
}
inline void TypeDefinition::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.TypeDefinition.type)
}

// map<string, .openfga.v1.Userset> relations = 2 [json_name = "relations", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int TypeDefinition::_internal_relations_size() const {
  return _impl_.relations_.size();
}
inline int TypeDefinition::relations_size() const {
  return _internal_relations_size();
}
inline void TypeDefinition::clear_relations() {
  _impl_.relations_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::Userset >&
TypeDefinition::_internal_relations() const {
  return _impl_.relations_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::Userset >&
TypeDefinition::relations() const {
  // @@protoc_insertion_point(field_map:openfga.v1.TypeDefinition.relations)
  return _internal_relations();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::Userset >*
TypeDefinition::_internal_mutable_relations() {
  return _impl_.relations_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::Userset >*
TypeDefinition::mutable_relations() {
  // @@protoc_insertion_point(field_mutable_map:openfga.v1.TypeDefinition.relations)
  return _internal_mutable_relations();
}

// .openfga.v1.Metadata metadata = 3 [json_name = "metadata"];
inline bool TypeDefinition::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool TypeDefinition::has_metadata() const {
  return _internal_has_metadata();
}
inline void TypeDefinition::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && _impl_.metadata_ != nullptr) {
    delete _impl_.metadata_;
  }
  _impl_.metadata_ = nullptr;
}
inline const ::openfga::v1::Metadata& TypeDefinition::_internal_metadata() const {
  const ::openfga::v1::Metadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::Metadata&>(
      ::openfga::v1::_Metadata_default_instance_);
}
inline const ::openfga::v1::Metadata& TypeDefinition::metadata() const {
  // @@protoc_insertion_point(field_get:openfga.v1.TypeDefinition.metadata)
  return _internal_metadata();
}
inline void TypeDefinition::unsafe_arena_set_allocated_metadata(
    ::openfga::v1::Metadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.TypeDefinition.metadata)
}
inline ::openfga::v1::Metadata* TypeDefinition::release_metadata() {
  
  ::openfga::v1::Metadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::Metadata* TypeDefinition::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:openfga.v1.TypeDefinition.metadata)
  
  ::openfga::v1::Metadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::openfga::v1::Metadata* TypeDefinition::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::Metadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::openfga::v1::Metadata* TypeDefinition::mutable_metadata() {
  ::openfga::v1::Metadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:openfga.v1.TypeDefinition.metadata)
  return _msg;
}
inline void TypeDefinition::set_allocated_metadata(::openfga::v1::Metadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.TypeDefinition.metadata)
}

// -------------------------------------------------------------------

// Relation

// string name = 1 [json_name = "name", (.validate.rules) = {
inline void Relation::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Relation::name() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Relation.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Relation::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.Relation.name)
}
inline std::string* Relation::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Relation.name)
  return _s;
}
inline const std::string& Relation::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Relation::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Relation::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Relation::release_name() {
  // @@protoc_insertion_point(field_release:openfga.v1.Relation.name)
  return _impl_.name_.Release();
}
inline void Relation::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.Relation.name)
}

// .openfga.v1.Userset rewrite = 2 [json_name = "rewrite", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool Relation::_internal_has_rewrite() const {
  return this != internal_default_instance() && _impl_.rewrite_ != nullptr;
}
inline bool Relation::has_rewrite() const {
  return _internal_has_rewrite();
}
inline void Relation::clear_rewrite() {
  if (GetArenaForAllocation() == nullptr && _impl_.rewrite_ != nullptr) {
    delete _impl_.rewrite_;
  }
  _impl_.rewrite_ = nullptr;
}
inline const ::openfga::v1::Userset& Relation::_internal_rewrite() const {
  const ::openfga::v1::Userset* p = _impl_.rewrite_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::Userset&>(
      ::openfga::v1::_Userset_default_instance_);
}
inline const ::openfga::v1::Userset& Relation::rewrite() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Relation.rewrite)
  return _internal_rewrite();
}
inline void Relation::unsafe_arena_set_allocated_rewrite(
    ::openfga::v1::Userset* rewrite) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rewrite_);
  }
  _impl_.rewrite_ = rewrite;
  if (rewrite) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.Relation.rewrite)
}
inline ::openfga::v1::Userset* Relation::release_rewrite() {
  
  ::openfga::v1::Userset* temp = _impl_.rewrite_;
  _impl_.rewrite_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::Userset* Relation::unsafe_arena_release_rewrite() {
  // @@protoc_insertion_point(field_release:openfga.v1.Relation.rewrite)
  
  ::openfga::v1::Userset* temp = _impl_.rewrite_;
  _impl_.rewrite_ = nullptr;
  return temp;
}
inline ::openfga::v1::Userset* Relation::_internal_mutable_rewrite() {
  
  if (_impl_.rewrite_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::Userset>(GetArenaForAllocation());
    _impl_.rewrite_ = p;
  }
  return _impl_.rewrite_;
}
inline ::openfga::v1::Userset* Relation::mutable_rewrite() {
  ::openfga::v1::Userset* _msg = _internal_mutable_rewrite();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Relation.rewrite)
  return _msg;
}
inline void Relation::set_allocated_rewrite(::openfga::v1::Userset* rewrite) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rewrite_;
  }
  if (rewrite) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rewrite);
    if (message_arena != submessage_arena) {
      rewrite = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rewrite, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rewrite_ = rewrite;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.Relation.rewrite)
}

// .openfga.v1.RelationTypeInfo type_info = 3 [json_name = "typeInfo"];
inline bool Relation::_internal_has_type_info() const {
  return this != internal_default_instance() && _impl_.type_info_ != nullptr;
}
inline bool Relation::has_type_info() const {
  return _internal_has_type_info();
}
inline void Relation::clear_type_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.type_info_ != nullptr) {
    delete _impl_.type_info_;
  }
  _impl_.type_info_ = nullptr;
}
inline const ::openfga::v1::RelationTypeInfo& Relation::_internal_type_info() const {
  const ::openfga::v1::RelationTypeInfo* p = _impl_.type_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::RelationTypeInfo&>(
      ::openfga::v1::_RelationTypeInfo_default_instance_);
}
inline const ::openfga::v1::RelationTypeInfo& Relation::type_info() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Relation.type_info)
  return _internal_type_info();
}
inline void Relation::unsafe_arena_set_allocated_type_info(
    ::openfga::v1::RelationTypeInfo* type_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.type_info_);
  }
  _impl_.type_info_ = type_info;
  if (type_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.Relation.type_info)
}
inline ::openfga::v1::RelationTypeInfo* Relation::release_type_info() {
  
  ::openfga::v1::RelationTypeInfo* temp = _impl_.type_info_;
  _impl_.type_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::RelationTypeInfo* Relation::unsafe_arena_release_type_info() {
  // @@protoc_insertion_point(field_release:openfga.v1.Relation.type_info)
  
  ::openfga::v1::RelationTypeInfo* temp = _impl_.type_info_;
  _impl_.type_info_ = nullptr;
  return temp;
}
inline ::openfga::v1::RelationTypeInfo* Relation::_internal_mutable_type_info() {
  
  if (_impl_.type_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::RelationTypeInfo>(GetArenaForAllocation());
    _impl_.type_info_ = p;
  }
  return _impl_.type_info_;
}
inline ::openfga::v1::RelationTypeInfo* Relation::mutable_type_info() {
  ::openfga::v1::RelationTypeInfo* _msg = _internal_mutable_type_info();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Relation.type_info)
  return _msg;
}
inline void Relation::set_allocated_type_info(::openfga::v1::RelationTypeInfo* type_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.type_info_;
  }
  if (type_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(type_info);
    if (message_arena != submessage_arena) {
      type_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, type_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.type_info_ = type_info;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.Relation.type_info)
}

// -------------------------------------------------------------------

// RelationTypeInfo

// repeated .openfga.v1.RelationReference directly_related_user_types = 1 [json_name = "directly_related_user_types"];
inline int RelationTypeInfo::_internal_directly_related_user_types_size() const {
  return _impl_.directly_related_user_types_.size();
}
inline int RelationTypeInfo::directly_related_user_types_size() const {
  return _internal_directly_related_user_types_size();
}
inline void RelationTypeInfo::clear_directly_related_user_types() {
  _impl_.directly_related_user_types_.Clear();
}
inline ::openfga::v1::RelationReference* RelationTypeInfo::mutable_directly_related_user_types(int index) {
  // @@protoc_insertion_point(field_mutable:openfga.v1.RelationTypeInfo.directly_related_user_types)
  return _impl_.directly_related_user_types_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::RelationReference >*
RelationTypeInfo::mutable_directly_related_user_types() {
  // @@protoc_insertion_point(field_mutable_list:openfga.v1.RelationTypeInfo.directly_related_user_types)
  return &_impl_.directly_related_user_types_;
}
inline const ::openfga::v1::RelationReference& RelationTypeInfo::_internal_directly_related_user_types(int index) const {
  return _impl_.directly_related_user_types_.Get(index);
}
inline const ::openfga::v1::RelationReference& RelationTypeInfo::directly_related_user_types(int index) const {
  // @@protoc_insertion_point(field_get:openfga.v1.RelationTypeInfo.directly_related_user_types)
  return _internal_directly_related_user_types(index);
}
inline ::openfga::v1::RelationReference* RelationTypeInfo::_internal_add_directly_related_user_types() {
  return _impl_.directly_related_user_types_.Add();
}
inline ::openfga::v1::RelationReference* RelationTypeInfo::add_directly_related_user_types() {
  ::openfga::v1::RelationReference* _add = _internal_add_directly_related_user_types();
  // @@protoc_insertion_point(field_add:openfga.v1.RelationTypeInfo.directly_related_user_types)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::RelationReference >&
RelationTypeInfo::directly_related_user_types() const {
  // @@protoc_insertion_point(field_list:openfga.v1.RelationTypeInfo.directly_related_user_types)
  return _impl_.directly_related_user_types_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Metadata

// map<string, .openfga.v1.RelationMetadata> relations = 1 [json_name = "relations"];
inline int Metadata::_internal_relations_size() const {
  return _impl_.relations_.size();
}
inline int Metadata::relations_size() const {
  return _internal_relations_size();
}
inline void Metadata::clear_relations() {
  _impl_.relations_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::RelationMetadata >&
Metadata::_internal_relations() const {
  return _impl_.relations_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::RelationMetadata >&
Metadata::relations() const {
  // @@protoc_insertion_point(field_map:openfga.v1.Metadata.relations)
  return _internal_relations();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::RelationMetadata >*
Metadata::_internal_mutable_relations() {
  return _impl_.relations_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::RelationMetadata >*
Metadata::mutable_relations() {
  // @@protoc_insertion_point(field_mutable_map:openfga.v1.Metadata.relations)
  return _internal_mutable_relations();
}

// string module = 2 [json_name = "module", (.validate.rules) = {
inline void Metadata::clear_module() {
  _impl_.module_.ClearToEmpty();
}
inline const std::string& Metadata::module() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Metadata.module)
  return _internal_module();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Metadata::set_module(ArgT0&& arg0, ArgT... args) {
 
 _impl_.module_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.Metadata.module)
}
inline std::string* Metadata::mutable_module() {
  std::string* _s = _internal_mutable_module();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Metadata.module)
  return _s;
}
inline const std::string& Metadata::_internal_module() const {
  return _impl_.module_.Get();
}
inline void Metadata::_internal_set_module(const std::string& value) {
  
  _impl_.module_.Set(value, GetArenaForAllocation());
}
inline std::string* Metadata::_internal_mutable_module() {
  
  return _impl_.module_.Mutable(GetArenaForAllocation());
}
inline std::string* Metadata::release_module() {
  // @@protoc_insertion_point(field_release:openfga.v1.Metadata.module)
  return _impl_.module_.Release();
}
inline void Metadata::set_allocated_module(std::string* module) {
  if (module != nullptr) {
    
  } else {
    
  }
  _impl_.module_.SetAllocated(module, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.module_.IsDefault()) {
    _impl_.module_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.Metadata.module)
}

// .openfga.v1.SourceInfo source_info = 3 [json_name = "source_info"];
inline bool Metadata::_internal_has_source_info() const {
  return this != internal_default_instance() && _impl_.source_info_ != nullptr;
}
inline bool Metadata::has_source_info() const {
  return _internal_has_source_info();
}
inline void Metadata::clear_source_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.source_info_ != nullptr) {
    delete _impl_.source_info_;
  }
  _impl_.source_info_ = nullptr;
}
inline const ::openfga::v1::SourceInfo& Metadata::_internal_source_info() const {
  const ::openfga::v1::SourceInfo* p = _impl_.source_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::SourceInfo&>(
      ::openfga::v1::_SourceInfo_default_instance_);
}
inline const ::openfga::v1::SourceInfo& Metadata::source_info() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Metadata.source_info)
  return _internal_source_info();
}
inline void Metadata::unsafe_arena_set_allocated_source_info(
    ::openfga::v1::SourceInfo* source_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_info_);
  }
  _impl_.source_info_ = source_info;
  if (source_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.Metadata.source_info)
}
inline ::openfga::v1::SourceInfo* Metadata::release_source_info() {
  
  ::openfga::v1::SourceInfo* temp = _impl_.source_info_;
  _impl_.source_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::SourceInfo* Metadata::unsafe_arena_release_source_info() {
  // @@protoc_insertion_point(field_release:openfga.v1.Metadata.source_info)
  
  ::openfga::v1::SourceInfo* temp = _impl_.source_info_;
  _impl_.source_info_ = nullptr;
  return temp;
}
inline ::openfga::v1::SourceInfo* Metadata::_internal_mutable_source_info() {
  
  if (_impl_.source_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::SourceInfo>(GetArenaForAllocation());
    _impl_.source_info_ = p;
  }
  return _impl_.source_info_;
}
inline ::openfga::v1::SourceInfo* Metadata::mutable_source_info() {
  ::openfga::v1::SourceInfo* _msg = _internal_mutable_source_info();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Metadata.source_info)
  return _msg;
}
inline void Metadata::set_allocated_source_info(::openfga::v1::SourceInfo* source_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_info_;
  }
  if (source_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_info);
    if (message_arena != submessage_arena) {
      source_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.source_info_ = source_info;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.Metadata.source_info)
}

// -------------------------------------------------------------------

// SourceInfo

// string file = 1 [json_name = "file", (.validate.rules) = {
inline void SourceInfo::clear_file() {
  _impl_.file_.ClearToEmpty();
}
inline const std::string& SourceInfo::file() const {
  // @@protoc_insertion_point(field_get:openfga.v1.SourceInfo.file)
  return _internal_file();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SourceInfo::set_file(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.SourceInfo.file)
}
inline std::string* SourceInfo::mutable_file() {
  std::string* _s = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:openfga.v1.SourceInfo.file)
  return _s;
}
inline const std::string& SourceInfo::_internal_file() const {
  return _impl_.file_.Get();
}
inline void SourceInfo::_internal_set_file(const std::string& value) {
  
  _impl_.file_.Set(value, GetArenaForAllocation());
}
inline std::string* SourceInfo::_internal_mutable_file() {
  
  return _impl_.file_.Mutable(GetArenaForAllocation());
}
inline std::string* SourceInfo::release_file() {
  // @@protoc_insertion_point(field_release:openfga.v1.SourceInfo.file)
  return _impl_.file_.Release();
}
inline void SourceInfo::set_allocated_file(std::string* file) {
  if (file != nullptr) {
    
  } else {
    
  }
  _impl_.file_.SetAllocated(file, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_.IsDefault()) {
    _impl_.file_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.SourceInfo.file)
}

// -------------------------------------------------------------------

// RelationMetadata

// repeated .openfga.v1.RelationReference directly_related_user_types = 1 [json_name = "directly_related_user_types"];
inline int RelationMetadata::_internal_directly_related_user_types_size() const {
  return _impl_.directly_related_user_types_.size();
}
inline int RelationMetadata::directly_related_user_types_size() const {
  return _internal_directly_related_user_types_size();
}
inline void RelationMetadata::clear_directly_related_user_types() {
  _impl_.directly_related_user_types_.Clear();
}
inline ::openfga::v1::RelationReference* RelationMetadata::mutable_directly_related_user_types(int index) {
  // @@protoc_insertion_point(field_mutable:openfga.v1.RelationMetadata.directly_related_user_types)
  return _impl_.directly_related_user_types_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::RelationReference >*
RelationMetadata::mutable_directly_related_user_types() {
  // @@protoc_insertion_point(field_mutable_list:openfga.v1.RelationMetadata.directly_related_user_types)
  return &_impl_.directly_related_user_types_;
}
inline const ::openfga::v1::RelationReference& RelationMetadata::_internal_directly_related_user_types(int index) const {
  return _impl_.directly_related_user_types_.Get(index);
}
inline const ::openfga::v1::RelationReference& RelationMetadata::directly_related_user_types(int index) const {
  // @@protoc_insertion_point(field_get:openfga.v1.RelationMetadata.directly_related_user_types)
  return _internal_directly_related_user_types(index);
}
inline ::openfga::v1::RelationReference* RelationMetadata::_internal_add_directly_related_user_types() {
  return _impl_.directly_related_user_types_.Add();
}
inline ::openfga::v1::RelationReference* RelationMetadata::add_directly_related_user_types() {
  ::openfga::v1::RelationReference* _add = _internal_add_directly_related_user_types();
  // @@protoc_insertion_point(field_add:openfga.v1.RelationMetadata.directly_related_user_types)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::RelationReference >&
RelationMetadata::directly_related_user_types() const {
  // @@protoc_insertion_point(field_list:openfga.v1.RelationMetadata.directly_related_user_types)
  return _impl_.directly_related_user_types_;
}

// string module = 2 [json_name = "module", (.validate.rules) = {
inline void RelationMetadata::clear_module() {
  _impl_.module_.ClearToEmpty();
}
inline const std::string& RelationMetadata::module() const {
  // @@protoc_insertion_point(field_get:openfga.v1.RelationMetadata.module)
  return _internal_module();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RelationMetadata::set_module(ArgT0&& arg0, ArgT... args) {
 
 _impl_.module_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.RelationMetadata.module)
}
inline std::string* RelationMetadata::mutable_module() {
  std::string* _s = _internal_mutable_module();
  // @@protoc_insertion_point(field_mutable:openfga.v1.RelationMetadata.module)
  return _s;
}
inline const std::string& RelationMetadata::_internal_module() const {
  return _impl_.module_.Get();
}
inline void RelationMetadata::_internal_set_module(const std::string& value) {
  
  _impl_.module_.Set(value, GetArenaForAllocation());
}
inline std::string* RelationMetadata::_internal_mutable_module() {
  
  return _impl_.module_.Mutable(GetArenaForAllocation());
}
inline std::string* RelationMetadata::release_module() {
  // @@protoc_insertion_point(field_release:openfga.v1.RelationMetadata.module)
  return _impl_.module_.Release();
}
inline void RelationMetadata::set_allocated_module(std::string* module) {
  if (module != nullptr) {
    
  } else {
    
  }
  _impl_.module_.SetAllocated(module, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.module_.IsDefault()) {
    _impl_.module_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.RelationMetadata.module)
}

// .openfga.v1.SourceInfo source_info = 3 [json_name = "source_info"];
inline bool RelationMetadata::_internal_has_source_info() const {
  return this != internal_default_instance() && _impl_.source_info_ != nullptr;
}
inline bool RelationMetadata::has_source_info() const {
  return _internal_has_source_info();
}
inline void RelationMetadata::clear_source_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.source_info_ != nullptr) {
    delete _impl_.source_info_;
  }
  _impl_.source_info_ = nullptr;
}
inline const ::openfga::v1::SourceInfo& RelationMetadata::_internal_source_info() const {
  const ::openfga::v1::SourceInfo* p = _impl_.source_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::SourceInfo&>(
      ::openfga::v1::_SourceInfo_default_instance_);
}
inline const ::openfga::v1::SourceInfo& RelationMetadata::source_info() const {
  // @@protoc_insertion_point(field_get:openfga.v1.RelationMetadata.source_info)
  return _internal_source_info();
}
inline void RelationMetadata::unsafe_arena_set_allocated_source_info(
    ::openfga::v1::SourceInfo* source_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_info_);
  }
  _impl_.source_info_ = source_info;
  if (source_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.RelationMetadata.source_info)
}
inline ::openfga::v1::SourceInfo* RelationMetadata::release_source_info() {
  
  ::openfga::v1::SourceInfo* temp = _impl_.source_info_;
  _impl_.source_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::SourceInfo* RelationMetadata::unsafe_arena_release_source_info() {
  // @@protoc_insertion_point(field_release:openfga.v1.RelationMetadata.source_info)
  
  ::openfga::v1::SourceInfo* temp = _impl_.source_info_;
  _impl_.source_info_ = nullptr;
  return temp;
}
inline ::openfga::v1::SourceInfo* RelationMetadata::_internal_mutable_source_info() {
  
  if (_impl_.source_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::SourceInfo>(GetArenaForAllocation());
    _impl_.source_info_ = p;
  }
  return _impl_.source_info_;
}
inline ::openfga::v1::SourceInfo* RelationMetadata::mutable_source_info() {
  ::openfga::v1::SourceInfo* _msg = _internal_mutable_source_info();
  // @@protoc_insertion_point(field_mutable:openfga.v1.RelationMetadata.source_info)
  return _msg;
}
inline void RelationMetadata::set_allocated_source_info(::openfga::v1::SourceInfo* source_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_info_;
  }
  if (source_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_info);
    if (message_arena != submessage_arena) {
      source_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.source_info_ = source_info;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.RelationMetadata.source_info)
}

// -------------------------------------------------------------------

// RelationReference

// string type = 1 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void RelationReference::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& RelationReference::type() const {
  // @@protoc_insertion_point(field_get:openfga.v1.RelationReference.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RelationReference::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.RelationReference.type)
}
inline std::string* RelationReference::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:openfga.v1.RelationReference.type)
  return _s;
}
inline const std::string& RelationReference::_internal_type() const {
  return _impl_.type_.Get();
}
inline void RelationReference::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* RelationReference::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* RelationReference::release_type() {
  // @@protoc_insertion_point(field_release:openfga.v1.RelationReference.type)
  return _impl_.type_.Release();
}
inline void RelationReference::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.RelationReference.type)
}

// string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline bool RelationReference::_internal_has_relation() const {
  return relation_or_wildcard_case() == kRelation;
}
inline bool RelationReference::has_relation() const {
  return _internal_has_relation();
}
inline void RelationReference::set_has_relation() {
  _impl_._oneof_case_[0] = kRelation;
}
inline void RelationReference::clear_relation() {
  if (_internal_has_relation()) {
    _impl_.relation_or_wildcard_.relation_.Destroy();
    clear_has_relation_or_wildcard();
  }
}
inline const std::string& RelationReference::relation() const {
  // @@protoc_insertion_point(field_get:openfga.v1.RelationReference.relation)
  return _internal_relation();
}
template <typename ArgT0, typename... ArgT>
inline void RelationReference::set_relation(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_relation()) {
    clear_relation_or_wildcard();
    set_has_relation();
    _impl_.relation_or_wildcard_.relation_.InitDefault();
  }
  _impl_.relation_or_wildcard_.relation_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.RelationReference.relation)
}
inline std::string* RelationReference::mutable_relation() {
  std::string* _s = _internal_mutable_relation();
  // @@protoc_insertion_point(field_mutable:openfga.v1.RelationReference.relation)
  return _s;
}
inline const std::string& RelationReference::_internal_relation() const {
  if (_internal_has_relation()) {
    return _impl_.relation_or_wildcard_.relation_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RelationReference::_internal_set_relation(const std::string& value) {
  if (!_internal_has_relation()) {
    clear_relation_or_wildcard();
    set_has_relation();
    _impl_.relation_or_wildcard_.relation_.InitDefault();
  }
  _impl_.relation_or_wildcard_.relation_.Set(value, GetArenaForAllocation());
}
inline std::string* RelationReference::_internal_mutable_relation() {
  if (!_internal_has_relation()) {
    clear_relation_or_wildcard();
    set_has_relation();
    _impl_.relation_or_wildcard_.relation_.InitDefault();
  }
  return _impl_.relation_or_wildcard_.relation_.Mutable(      GetArenaForAllocation());
}
inline std::string* RelationReference::release_relation() {
  // @@protoc_insertion_point(field_release:openfga.v1.RelationReference.relation)
  if (_internal_has_relation()) {
    clear_has_relation_or_wildcard();
    return _impl_.relation_or_wildcard_.relation_.Release();
  } else {
    return nullptr;
  }
}
inline void RelationReference::set_allocated_relation(std::string* relation) {
  if (has_relation_or_wildcard()) {
    clear_relation_or_wildcard();
  }
  if (relation != nullptr) {
    set_has_relation();
    _impl_.relation_or_wildcard_.relation_.InitAllocated(relation, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.RelationReference.relation)
}

// .openfga.v1.Wildcard wildcard = 3 [json_name = "wildcard"];
inline bool RelationReference::_internal_has_wildcard() const {
  return relation_or_wildcard_case() == kWildcard;
}
inline bool RelationReference::has_wildcard() const {
  return _internal_has_wildcard();
}
inline void RelationReference::set_has_wildcard() {
  _impl_._oneof_case_[0] = kWildcard;
}
inline void RelationReference::clear_wildcard() {
  if (_internal_has_wildcard()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.relation_or_wildcard_.wildcard_;
    }
    clear_has_relation_or_wildcard();
  }
}
inline ::openfga::v1::Wildcard* RelationReference::release_wildcard() {
  // @@protoc_insertion_point(field_release:openfga.v1.RelationReference.wildcard)
  if (_internal_has_wildcard()) {
    clear_has_relation_or_wildcard();
    ::openfga::v1::Wildcard* temp = _impl_.relation_or_wildcard_.wildcard_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.relation_or_wildcard_.wildcard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openfga::v1::Wildcard& RelationReference::_internal_wildcard() const {
  return _internal_has_wildcard()
      ? *_impl_.relation_or_wildcard_.wildcard_
      : reinterpret_cast< ::openfga::v1::Wildcard&>(::openfga::v1::_Wildcard_default_instance_);
}
inline const ::openfga::v1::Wildcard& RelationReference::wildcard() const {
  // @@protoc_insertion_point(field_get:openfga.v1.RelationReference.wildcard)
  return _internal_wildcard();
}
inline ::openfga::v1::Wildcard* RelationReference::unsafe_arena_release_wildcard() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openfga.v1.RelationReference.wildcard)
  if (_internal_has_wildcard()) {
    clear_has_relation_or_wildcard();
    ::openfga::v1::Wildcard* temp = _impl_.relation_or_wildcard_.wildcard_;
    _impl_.relation_or_wildcard_.wildcard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelationReference::unsafe_arena_set_allocated_wildcard(::openfga::v1::Wildcard* wildcard) {
  clear_relation_or_wildcard();
  if (wildcard) {
    set_has_wildcard();
    _impl_.relation_or_wildcard_.wildcard_ = wildcard;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.RelationReference.wildcard)
}
inline ::openfga::v1::Wildcard* RelationReference::_internal_mutable_wildcard() {
  if (!_internal_has_wildcard()) {
    clear_relation_or_wildcard();
    set_has_wildcard();
    _impl_.relation_or_wildcard_.wildcard_ = CreateMaybeMessage< ::openfga::v1::Wildcard >(GetArenaForAllocation());
  }
  return _impl_.relation_or_wildcard_.wildcard_;
}
inline ::openfga::v1::Wildcard* RelationReference::mutable_wildcard() {
  ::openfga::v1::Wildcard* _msg = _internal_mutable_wildcard();
  // @@protoc_insertion_point(field_mutable:openfga.v1.RelationReference.wildcard)
  return _msg;
}

// string condition = 4 [json_name = "condition", (.validate.rules) = {
inline void RelationReference::clear_condition() {
  _impl_.condition_.ClearToEmpty();
}
inline const std::string& RelationReference::condition() const {
  // @@protoc_insertion_point(field_get:openfga.v1.RelationReference.condition)
  return _internal_condition();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RelationReference::set_condition(ArgT0&& arg0, ArgT... args) {
 
 _impl_.condition_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.RelationReference.condition)
}
inline std::string* RelationReference::mutable_condition() {
  std::string* _s = _internal_mutable_condition();
  // @@protoc_insertion_point(field_mutable:openfga.v1.RelationReference.condition)
  return _s;
}
inline const std::string& RelationReference::_internal_condition() const {
  return _impl_.condition_.Get();
}
inline void RelationReference::_internal_set_condition(const std::string& value) {
  
  _impl_.condition_.Set(value, GetArenaForAllocation());
}
inline std::string* RelationReference::_internal_mutable_condition() {
  
  return _impl_.condition_.Mutable(GetArenaForAllocation());
}
inline std::string* RelationReference::release_condition() {
  // @@protoc_insertion_point(field_release:openfga.v1.RelationReference.condition)
  return _impl_.condition_.Release();
}
inline void RelationReference::set_allocated_condition(std::string* condition) {
  if (condition != nullptr) {
    
  } else {
    
  }
  _impl_.condition_.SetAllocated(condition, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.condition_.IsDefault()) {
    _impl_.condition_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.RelationReference.condition)
}

inline bool RelationReference::has_relation_or_wildcard() const {
  return relation_or_wildcard_case() != RELATION_OR_WILDCARD_NOT_SET;
}
inline void RelationReference::clear_has_relation_or_wildcard() {
  _impl_._oneof_case_[0] = RELATION_OR_WILDCARD_NOT_SET;
}
inline RelationReference::RelationOrWildcardCase RelationReference::relation_or_wildcard_case() const {
  return RelationReference::RelationOrWildcardCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Wildcard

// -------------------------------------------------------------------

// Usersets

// repeated .openfga.v1.Userset child = 1 [json_name = "child", (.google.api.field_behavior) = REQUIRED];
inline int Usersets::_internal_child_size() const {
  return _impl_.child_.size();
}
inline int Usersets::child_size() const {
  return _internal_child_size();
}
inline void Usersets::clear_child() {
  _impl_.child_.Clear();
}
inline ::openfga::v1::Userset* Usersets::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:openfga.v1.Usersets.child)
  return _impl_.child_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Userset >*
Usersets::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:openfga.v1.Usersets.child)
  return &_impl_.child_;
}
inline const ::openfga::v1::Userset& Usersets::_internal_child(int index) const {
  return _impl_.child_.Get(index);
}
inline const ::openfga::v1::Userset& Usersets::child(int index) const {
  // @@protoc_insertion_point(field_get:openfga.v1.Usersets.child)
  return _internal_child(index);
}
inline ::openfga::v1::Userset* Usersets::_internal_add_child() {
  return _impl_.child_.Add();
}
inline ::openfga::v1::Userset* Usersets::add_child() {
  ::openfga::v1::Userset* _add = _internal_add_child();
  // @@protoc_insertion_point(field_add:openfga.v1.Usersets.child)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::Userset >&
Usersets::child() const {
  // @@protoc_insertion_point(field_list:openfga.v1.Usersets.child)
  return _impl_.child_;
}

// -------------------------------------------------------------------

// Difference

// .openfga.v1.Userset base = 1 [json_name = "base", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool Difference::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool Difference::has_base() const {
  return _internal_has_base();
}
inline void Difference::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::openfga::v1::Userset& Difference::_internal_base() const {
  const ::openfga::v1::Userset* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::Userset&>(
      ::openfga::v1::_Userset_default_instance_);
}
inline const ::openfga::v1::Userset& Difference::base() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Difference.base)
  return _internal_base();
}
inline void Difference::unsafe_arena_set_allocated_base(
    ::openfga::v1::Userset* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.Difference.base)
}
inline ::openfga::v1::Userset* Difference::release_base() {
  
  ::openfga::v1::Userset* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::Userset* Difference::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:openfga.v1.Difference.base)
  
  ::openfga::v1::Userset* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::openfga::v1::Userset* Difference::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::Userset>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::openfga::v1::Userset* Difference::mutable_base() {
  ::openfga::v1::Userset* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Difference.base)
  return _msg;
}
inline void Difference::set_allocated_base(::openfga::v1::Userset* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.Difference.base)
}

// .openfga.v1.Userset subtract = 2 [json_name = "subtract", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool Difference::_internal_has_subtract() const {
  return this != internal_default_instance() && _impl_.subtract_ != nullptr;
}
inline bool Difference::has_subtract() const {
  return _internal_has_subtract();
}
inline void Difference::clear_subtract() {
  if (GetArenaForAllocation() == nullptr && _impl_.subtract_ != nullptr) {
    delete _impl_.subtract_;
  }
  _impl_.subtract_ = nullptr;
}
inline const ::openfga::v1::Userset& Difference::_internal_subtract() const {
  const ::openfga::v1::Userset* p = _impl_.subtract_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::Userset&>(
      ::openfga::v1::_Userset_default_instance_);
}
inline const ::openfga::v1::Userset& Difference::subtract() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Difference.subtract)
  return _internal_subtract();
}
inline void Difference::unsafe_arena_set_allocated_subtract(
    ::openfga::v1::Userset* subtract) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subtract_);
  }
  _impl_.subtract_ = subtract;
  if (subtract) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.Difference.subtract)
}
inline ::openfga::v1::Userset* Difference::release_subtract() {
  
  ::openfga::v1::Userset* temp = _impl_.subtract_;
  _impl_.subtract_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::Userset* Difference::unsafe_arena_release_subtract() {
  // @@protoc_insertion_point(field_release:openfga.v1.Difference.subtract)
  
  ::openfga::v1::Userset* temp = _impl_.subtract_;
  _impl_.subtract_ = nullptr;
  return temp;
}
inline ::openfga::v1::Userset* Difference::_internal_mutable_subtract() {
  
  if (_impl_.subtract_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::Userset>(GetArenaForAllocation());
    _impl_.subtract_ = p;
  }
  return _impl_.subtract_;
}
inline ::openfga::v1::Userset* Difference::mutable_subtract() {
  ::openfga::v1::Userset* _msg = _internal_mutable_subtract();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Difference.subtract)
  return _msg;
}
inline void Difference::set_allocated_subtract(::openfga::v1::Userset* subtract) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.subtract_;
  }
  if (subtract) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(subtract);
    if (message_arena != submessage_arena) {
      subtract = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subtract, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.subtract_ = subtract;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.Difference.subtract)
}

// -------------------------------------------------------------------

// Userset

// .openfga.v1.DirectUserset this = 1 [json_name = "this"];
inline bool Userset::_internal_has_this_() const {
  return userset_case() == kThis;
}
inline bool Userset::has_this_() const {
  return _internal_has_this_();
}
inline void Userset::set_has_this_() {
  _impl_._oneof_case_[0] = kThis;
}
inline void Userset::clear_this_() {
  if (_internal_has_this_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.userset_.this__;
    }
    clear_has_userset();
  }
}
inline ::openfga::v1::DirectUserset* Userset::release_this_() {
  // @@protoc_insertion_point(field_release:openfga.v1.Userset.this)
  if (_internal_has_this_()) {
    clear_has_userset();
    ::openfga::v1::DirectUserset* temp = _impl_.userset_.this__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.userset_.this__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openfga::v1::DirectUserset& Userset::_internal_this_() const {
  return _internal_has_this_()
      ? *_impl_.userset_.this__
      : reinterpret_cast< ::openfga::v1::DirectUserset&>(::openfga::v1::_DirectUserset_default_instance_);
}
inline const ::openfga::v1::DirectUserset& Userset::this_() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Userset.this)
  return _internal_this_();
}
inline ::openfga::v1::DirectUserset* Userset::unsafe_arena_release_this_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openfga.v1.Userset.this)
  if (_internal_has_this_()) {
    clear_has_userset();
    ::openfga::v1::DirectUserset* temp = _impl_.userset_.this__;
    _impl_.userset_.this__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Userset::unsafe_arena_set_allocated_this_(::openfga::v1::DirectUserset* this_) {
  clear_userset();
  if (this_) {
    set_has_this_();
    _impl_.userset_.this__ = this_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.Userset.this)
}
inline ::openfga::v1::DirectUserset* Userset::_internal_mutable_this_() {
  if (!_internal_has_this_()) {
    clear_userset();
    set_has_this_();
    _impl_.userset_.this__ = CreateMaybeMessage< ::openfga::v1::DirectUserset >(GetArenaForAllocation());
  }
  return _impl_.userset_.this__;
}
inline ::openfga::v1::DirectUserset* Userset::mutable_this_() {
  ::openfga::v1::DirectUserset* _msg = _internal_mutable_this_();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Userset.this)
  return _msg;
}

// .openfga.v1.ObjectRelation computed_userset = 2 [json_name = "computedUserset"];
inline bool Userset::_internal_has_computed_userset() const {
  return userset_case() == kComputedUserset;
}
inline bool Userset::has_computed_userset() const {
  return _internal_has_computed_userset();
}
inline void Userset::set_has_computed_userset() {
  _impl_._oneof_case_[0] = kComputedUserset;
}
inline void Userset::clear_computed_userset() {
  if (_internal_has_computed_userset()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.userset_.computed_userset_;
    }
    clear_has_userset();
  }
}
inline ::openfga::v1::ObjectRelation* Userset::release_computed_userset() {
  // @@protoc_insertion_point(field_release:openfga.v1.Userset.computed_userset)
  if (_internal_has_computed_userset()) {
    clear_has_userset();
    ::openfga::v1::ObjectRelation* temp = _impl_.userset_.computed_userset_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.userset_.computed_userset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openfga::v1::ObjectRelation& Userset::_internal_computed_userset() const {
  return _internal_has_computed_userset()
      ? *_impl_.userset_.computed_userset_
      : reinterpret_cast< ::openfga::v1::ObjectRelation&>(::openfga::v1::_ObjectRelation_default_instance_);
}
inline const ::openfga::v1::ObjectRelation& Userset::computed_userset() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Userset.computed_userset)
  return _internal_computed_userset();
}
inline ::openfga::v1::ObjectRelation* Userset::unsafe_arena_release_computed_userset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openfga.v1.Userset.computed_userset)
  if (_internal_has_computed_userset()) {
    clear_has_userset();
    ::openfga::v1::ObjectRelation* temp = _impl_.userset_.computed_userset_;
    _impl_.userset_.computed_userset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Userset::unsafe_arena_set_allocated_computed_userset(::openfga::v1::ObjectRelation* computed_userset) {
  clear_userset();
  if (computed_userset) {
    set_has_computed_userset();
    _impl_.userset_.computed_userset_ = computed_userset;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.Userset.computed_userset)
}
inline ::openfga::v1::ObjectRelation* Userset::_internal_mutable_computed_userset() {
  if (!_internal_has_computed_userset()) {
    clear_userset();
    set_has_computed_userset();
    _impl_.userset_.computed_userset_ = CreateMaybeMessage< ::openfga::v1::ObjectRelation >(GetArenaForAllocation());
  }
  return _impl_.userset_.computed_userset_;
}
inline ::openfga::v1::ObjectRelation* Userset::mutable_computed_userset() {
  ::openfga::v1::ObjectRelation* _msg = _internal_mutable_computed_userset();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Userset.computed_userset)
  return _msg;
}

// .openfga.v1.TupleToUserset tuple_to_userset = 3 [json_name = "tupleToUserset"];
inline bool Userset::_internal_has_tuple_to_userset() const {
  return userset_case() == kTupleToUserset;
}
inline bool Userset::has_tuple_to_userset() const {
  return _internal_has_tuple_to_userset();
}
inline void Userset::set_has_tuple_to_userset() {
  _impl_._oneof_case_[0] = kTupleToUserset;
}
inline void Userset::clear_tuple_to_userset() {
  if (_internal_has_tuple_to_userset()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.userset_.tuple_to_userset_;
    }
    clear_has_userset();
  }
}
inline ::openfga::v1::TupleToUserset* Userset::release_tuple_to_userset() {
  // @@protoc_insertion_point(field_release:openfga.v1.Userset.tuple_to_userset)
  if (_internal_has_tuple_to_userset()) {
    clear_has_userset();
    ::openfga::v1::TupleToUserset* temp = _impl_.userset_.tuple_to_userset_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.userset_.tuple_to_userset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openfga::v1::TupleToUserset& Userset::_internal_tuple_to_userset() const {
  return _internal_has_tuple_to_userset()
      ? *_impl_.userset_.tuple_to_userset_
      : reinterpret_cast< ::openfga::v1::TupleToUserset&>(::openfga::v1::_TupleToUserset_default_instance_);
}
inline const ::openfga::v1::TupleToUserset& Userset::tuple_to_userset() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Userset.tuple_to_userset)
  return _internal_tuple_to_userset();
}
inline ::openfga::v1::TupleToUserset* Userset::unsafe_arena_release_tuple_to_userset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openfga.v1.Userset.tuple_to_userset)
  if (_internal_has_tuple_to_userset()) {
    clear_has_userset();
    ::openfga::v1::TupleToUserset* temp = _impl_.userset_.tuple_to_userset_;
    _impl_.userset_.tuple_to_userset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Userset::unsafe_arena_set_allocated_tuple_to_userset(::openfga::v1::TupleToUserset* tuple_to_userset) {
  clear_userset();
  if (tuple_to_userset) {
    set_has_tuple_to_userset();
    _impl_.userset_.tuple_to_userset_ = tuple_to_userset;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.Userset.tuple_to_userset)
}
inline ::openfga::v1::TupleToUserset* Userset::_internal_mutable_tuple_to_userset() {
  if (!_internal_has_tuple_to_userset()) {
    clear_userset();
    set_has_tuple_to_userset();
    _impl_.userset_.tuple_to_userset_ = CreateMaybeMessage< ::openfga::v1::TupleToUserset >(GetArenaForAllocation());
  }
  return _impl_.userset_.tuple_to_userset_;
}
inline ::openfga::v1::TupleToUserset* Userset::mutable_tuple_to_userset() {
  ::openfga::v1::TupleToUserset* _msg = _internal_mutable_tuple_to_userset();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Userset.tuple_to_userset)
  return _msg;
}

// .openfga.v1.Usersets union = 4 [json_name = "union"];
inline bool Userset::_internal_has_union_() const {
  return userset_case() == kUnion;
}
inline bool Userset::has_union_() const {
  return _internal_has_union_();
}
inline void Userset::set_has_union_() {
  _impl_._oneof_case_[0] = kUnion;
}
inline void Userset::clear_union_() {
  if (_internal_has_union_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.userset_.union__;
    }
    clear_has_userset();
  }
}
inline ::openfga::v1::Usersets* Userset::release_union_() {
  // @@protoc_insertion_point(field_release:openfga.v1.Userset.union)
  if (_internal_has_union_()) {
    clear_has_userset();
    ::openfga::v1::Usersets* temp = _impl_.userset_.union__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.userset_.union__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openfga::v1::Usersets& Userset::_internal_union_() const {
  return _internal_has_union_()
      ? *_impl_.userset_.union__
      : reinterpret_cast< ::openfga::v1::Usersets&>(::openfga::v1::_Usersets_default_instance_);
}
inline const ::openfga::v1::Usersets& Userset::union_() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Userset.union)
  return _internal_union_();
}
inline ::openfga::v1::Usersets* Userset::unsafe_arena_release_union_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openfga.v1.Userset.union)
  if (_internal_has_union_()) {
    clear_has_userset();
    ::openfga::v1::Usersets* temp = _impl_.userset_.union__;
    _impl_.userset_.union__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Userset::unsafe_arena_set_allocated_union_(::openfga::v1::Usersets* union_) {
  clear_userset();
  if (union_) {
    set_has_union_();
    _impl_.userset_.union__ = union_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.Userset.union)
}
inline ::openfga::v1::Usersets* Userset::_internal_mutable_union_() {
  if (!_internal_has_union_()) {
    clear_userset();
    set_has_union_();
    _impl_.userset_.union__ = CreateMaybeMessage< ::openfga::v1::Usersets >(GetArenaForAllocation());
  }
  return _impl_.userset_.union__;
}
inline ::openfga::v1::Usersets* Userset::mutable_union_() {
  ::openfga::v1::Usersets* _msg = _internal_mutable_union_();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Userset.union)
  return _msg;
}

// .openfga.v1.Usersets intersection = 5 [json_name = "intersection"];
inline bool Userset::_internal_has_intersection() const {
  return userset_case() == kIntersection;
}
inline bool Userset::has_intersection() const {
  return _internal_has_intersection();
}
inline void Userset::set_has_intersection() {
  _impl_._oneof_case_[0] = kIntersection;
}
inline void Userset::clear_intersection() {
  if (_internal_has_intersection()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.userset_.intersection_;
    }
    clear_has_userset();
  }
}
inline ::openfga::v1::Usersets* Userset::release_intersection() {
  // @@protoc_insertion_point(field_release:openfga.v1.Userset.intersection)
  if (_internal_has_intersection()) {
    clear_has_userset();
    ::openfga::v1::Usersets* temp = _impl_.userset_.intersection_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.userset_.intersection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openfga::v1::Usersets& Userset::_internal_intersection() const {
  return _internal_has_intersection()
      ? *_impl_.userset_.intersection_
      : reinterpret_cast< ::openfga::v1::Usersets&>(::openfga::v1::_Usersets_default_instance_);
}
inline const ::openfga::v1::Usersets& Userset::intersection() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Userset.intersection)
  return _internal_intersection();
}
inline ::openfga::v1::Usersets* Userset::unsafe_arena_release_intersection() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openfga.v1.Userset.intersection)
  if (_internal_has_intersection()) {
    clear_has_userset();
    ::openfga::v1::Usersets* temp = _impl_.userset_.intersection_;
    _impl_.userset_.intersection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Userset::unsafe_arena_set_allocated_intersection(::openfga::v1::Usersets* intersection) {
  clear_userset();
  if (intersection) {
    set_has_intersection();
    _impl_.userset_.intersection_ = intersection;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.Userset.intersection)
}
inline ::openfga::v1::Usersets* Userset::_internal_mutable_intersection() {
  if (!_internal_has_intersection()) {
    clear_userset();
    set_has_intersection();
    _impl_.userset_.intersection_ = CreateMaybeMessage< ::openfga::v1::Usersets >(GetArenaForAllocation());
  }
  return _impl_.userset_.intersection_;
}
inline ::openfga::v1::Usersets* Userset::mutable_intersection() {
  ::openfga::v1::Usersets* _msg = _internal_mutable_intersection();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Userset.intersection)
  return _msg;
}

// .openfga.v1.Difference difference = 6 [json_name = "difference"];
inline bool Userset::_internal_has_difference() const {
  return userset_case() == kDifference;
}
inline bool Userset::has_difference() const {
  return _internal_has_difference();
}
inline void Userset::set_has_difference() {
  _impl_._oneof_case_[0] = kDifference;
}
inline void Userset::clear_difference() {
  if (_internal_has_difference()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.userset_.difference_;
    }
    clear_has_userset();
  }
}
inline ::openfga::v1::Difference* Userset::release_difference() {
  // @@protoc_insertion_point(field_release:openfga.v1.Userset.difference)
  if (_internal_has_difference()) {
    clear_has_userset();
    ::openfga::v1::Difference* temp = _impl_.userset_.difference_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.userset_.difference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openfga::v1::Difference& Userset::_internal_difference() const {
  return _internal_has_difference()
      ? *_impl_.userset_.difference_
      : reinterpret_cast< ::openfga::v1::Difference&>(::openfga::v1::_Difference_default_instance_);
}
inline const ::openfga::v1::Difference& Userset::difference() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Userset.difference)
  return _internal_difference();
}
inline ::openfga::v1::Difference* Userset::unsafe_arena_release_difference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openfga.v1.Userset.difference)
  if (_internal_has_difference()) {
    clear_has_userset();
    ::openfga::v1::Difference* temp = _impl_.userset_.difference_;
    _impl_.userset_.difference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Userset::unsafe_arena_set_allocated_difference(::openfga::v1::Difference* difference) {
  clear_userset();
  if (difference) {
    set_has_difference();
    _impl_.userset_.difference_ = difference;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.Userset.difference)
}
inline ::openfga::v1::Difference* Userset::_internal_mutable_difference() {
  if (!_internal_has_difference()) {
    clear_userset();
    set_has_difference();
    _impl_.userset_.difference_ = CreateMaybeMessage< ::openfga::v1::Difference >(GetArenaForAllocation());
  }
  return _impl_.userset_.difference_;
}
inline ::openfga::v1::Difference* Userset::mutable_difference() {
  ::openfga::v1::Difference* _msg = _internal_mutable_difference();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Userset.difference)
  return _msg;
}

inline bool Userset::has_userset() const {
  return userset_case() != USERSET_NOT_SET;
}
inline void Userset::clear_has_userset() {
  _impl_._oneof_case_[0] = USERSET_NOT_SET;
}
inline Userset::UsersetCase Userset::userset_case() const {
  return Userset::UsersetCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DirectUserset

// -------------------------------------------------------------------

// ObjectRelation

// string object = 1 [json_name = "object", (.validate.rules) = {
inline void ObjectRelation::clear_object() {
  _impl_.object_.ClearToEmpty();
}
inline const std::string& ObjectRelation::object() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ObjectRelation.object)
  return _internal_object();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectRelation::set_object(ArgT0&& arg0, ArgT... args) {
 
 _impl_.object_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ObjectRelation.object)
}
inline std::string* ObjectRelation::mutable_object() {
  std::string* _s = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ObjectRelation.object)
  return _s;
}
inline const std::string& ObjectRelation::_internal_object() const {
  return _impl_.object_.Get();
}
inline void ObjectRelation::_internal_set_object(const std::string& value) {
  
  _impl_.object_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectRelation::_internal_mutable_object() {
  
  return _impl_.object_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectRelation::release_object() {
  // @@protoc_insertion_point(field_release:openfga.v1.ObjectRelation.object)
  return _impl_.object_.Release();
}
inline void ObjectRelation::set_allocated_object(std::string* object) {
  if (object != nullptr) {
    
  } else {
    
  }
  _impl_.object_.SetAllocated(object, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.object_.IsDefault()) {
    _impl_.object_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ObjectRelation.object)
}

// string relation = 2 [json_name = "relation", (.validate.rules) = {
inline void ObjectRelation::clear_relation() {
  _impl_.relation_.ClearToEmpty();
}
inline const std::string& ObjectRelation::relation() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ObjectRelation.relation)
  return _internal_relation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectRelation::set_relation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.relation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ObjectRelation.relation)
}
inline std::string* ObjectRelation::mutable_relation() {
  std::string* _s = _internal_mutable_relation();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ObjectRelation.relation)
  return _s;
}
inline const std::string& ObjectRelation::_internal_relation() const {
  return _impl_.relation_.Get();
}
inline void ObjectRelation::_internal_set_relation(const std::string& value) {
  
  _impl_.relation_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectRelation::_internal_mutable_relation() {
  
  return _impl_.relation_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectRelation::release_relation() {
  // @@protoc_insertion_point(field_release:openfga.v1.ObjectRelation.relation)
  return _impl_.relation_.Release();
}
inline void ObjectRelation::set_allocated_relation(std::string* relation) {
  if (relation != nullptr) {
    
  } else {
    
  }
  _impl_.relation_.SetAllocated(relation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.relation_.IsDefault()) {
    _impl_.relation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ObjectRelation.relation)
}

// -------------------------------------------------------------------

// ComputedUserset

// string relation = 1 [json_name = "relation", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void ComputedUserset::clear_relation() {
  _impl_.relation_.ClearToEmpty();
}
inline const std::string& ComputedUserset::relation() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ComputedUserset.relation)
  return _internal_relation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ComputedUserset::set_relation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.relation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ComputedUserset.relation)
}
inline std::string* ComputedUserset::mutable_relation() {
  std::string* _s = _internal_mutable_relation();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ComputedUserset.relation)
  return _s;
}
inline const std::string& ComputedUserset::_internal_relation() const {
  return _impl_.relation_.Get();
}
inline void ComputedUserset::_internal_set_relation(const std::string& value) {
  
  _impl_.relation_.Set(value, GetArenaForAllocation());
}
inline std::string* ComputedUserset::_internal_mutable_relation() {
  
  return _impl_.relation_.Mutable(GetArenaForAllocation());
}
inline std::string* ComputedUserset::release_relation() {
  // @@protoc_insertion_point(field_release:openfga.v1.ComputedUserset.relation)
  return _impl_.relation_.Release();
}
inline void ComputedUserset::set_allocated_relation(std::string* relation) {
  if (relation != nullptr) {
    
  } else {
    
  }
  _impl_.relation_.SetAllocated(relation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.relation_.IsDefault()) {
    _impl_.relation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ComputedUserset.relation)
}

// -------------------------------------------------------------------

// TupleToUserset

// .openfga.v1.ObjectRelation tupleset = 1 [json_name = "tupleset", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool TupleToUserset::_internal_has_tupleset() const {
  return this != internal_default_instance() && _impl_.tupleset_ != nullptr;
}
inline bool TupleToUserset::has_tupleset() const {
  return _internal_has_tupleset();
}
inline void TupleToUserset::clear_tupleset() {
  if (GetArenaForAllocation() == nullptr && _impl_.tupleset_ != nullptr) {
    delete _impl_.tupleset_;
  }
  _impl_.tupleset_ = nullptr;
}
inline const ::openfga::v1::ObjectRelation& TupleToUserset::_internal_tupleset() const {
  const ::openfga::v1::ObjectRelation* p = _impl_.tupleset_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::ObjectRelation&>(
      ::openfga::v1::_ObjectRelation_default_instance_);
}
inline const ::openfga::v1::ObjectRelation& TupleToUserset::tupleset() const {
  // @@protoc_insertion_point(field_get:openfga.v1.TupleToUserset.tupleset)
  return _internal_tupleset();
}
inline void TupleToUserset::unsafe_arena_set_allocated_tupleset(
    ::openfga::v1::ObjectRelation* tupleset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tupleset_);
  }
  _impl_.tupleset_ = tupleset;
  if (tupleset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.TupleToUserset.tupleset)
}
inline ::openfga::v1::ObjectRelation* TupleToUserset::release_tupleset() {
  
  ::openfga::v1::ObjectRelation* temp = _impl_.tupleset_;
  _impl_.tupleset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::ObjectRelation* TupleToUserset::unsafe_arena_release_tupleset() {
  // @@protoc_insertion_point(field_release:openfga.v1.TupleToUserset.tupleset)
  
  ::openfga::v1::ObjectRelation* temp = _impl_.tupleset_;
  _impl_.tupleset_ = nullptr;
  return temp;
}
inline ::openfga::v1::ObjectRelation* TupleToUserset::_internal_mutable_tupleset() {
  
  if (_impl_.tupleset_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::ObjectRelation>(GetArenaForAllocation());
    _impl_.tupleset_ = p;
  }
  return _impl_.tupleset_;
}
inline ::openfga::v1::ObjectRelation* TupleToUserset::mutable_tupleset() {
  ::openfga::v1::ObjectRelation* _msg = _internal_mutable_tupleset();
  // @@protoc_insertion_point(field_mutable:openfga.v1.TupleToUserset.tupleset)
  return _msg;
}
inline void TupleToUserset::set_allocated_tupleset(::openfga::v1::ObjectRelation* tupleset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tupleset_;
  }
  if (tupleset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tupleset);
    if (message_arena != submessage_arena) {
      tupleset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tupleset, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tupleset_ = tupleset;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.TupleToUserset.tupleset)
}

// .openfga.v1.ObjectRelation computed_userset = 2 [json_name = "computedUserset", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool TupleToUserset::_internal_has_computed_userset() const {
  return this != internal_default_instance() && _impl_.computed_userset_ != nullptr;
}
inline bool TupleToUserset::has_computed_userset() const {
  return _internal_has_computed_userset();
}
inline void TupleToUserset::clear_computed_userset() {
  if (GetArenaForAllocation() == nullptr && _impl_.computed_userset_ != nullptr) {
    delete _impl_.computed_userset_;
  }
  _impl_.computed_userset_ = nullptr;
}
inline const ::openfga::v1::ObjectRelation& TupleToUserset::_internal_computed_userset() const {
  const ::openfga::v1::ObjectRelation* p = _impl_.computed_userset_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::ObjectRelation&>(
      ::openfga::v1::_ObjectRelation_default_instance_);
}
inline const ::openfga::v1::ObjectRelation& TupleToUserset::computed_userset() const {
  // @@protoc_insertion_point(field_get:openfga.v1.TupleToUserset.computed_userset)
  return _internal_computed_userset();
}
inline void TupleToUserset::unsafe_arena_set_allocated_computed_userset(
    ::openfga::v1::ObjectRelation* computed_userset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.computed_userset_);
  }
  _impl_.computed_userset_ = computed_userset;
  if (computed_userset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.TupleToUserset.computed_userset)
}
inline ::openfga::v1::ObjectRelation* TupleToUserset::release_computed_userset() {
  
  ::openfga::v1::ObjectRelation* temp = _impl_.computed_userset_;
  _impl_.computed_userset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::ObjectRelation* TupleToUserset::unsafe_arena_release_computed_userset() {
  // @@protoc_insertion_point(field_release:openfga.v1.TupleToUserset.computed_userset)
  
  ::openfga::v1::ObjectRelation* temp = _impl_.computed_userset_;
  _impl_.computed_userset_ = nullptr;
  return temp;
}
inline ::openfga::v1::ObjectRelation* TupleToUserset::_internal_mutable_computed_userset() {
  
  if (_impl_.computed_userset_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::ObjectRelation>(GetArenaForAllocation());
    _impl_.computed_userset_ = p;
  }
  return _impl_.computed_userset_;
}
inline ::openfga::v1::ObjectRelation* TupleToUserset::mutable_computed_userset() {
  ::openfga::v1::ObjectRelation* _msg = _internal_mutable_computed_userset();
  // @@protoc_insertion_point(field_mutable:openfga.v1.TupleToUserset.computed_userset)
  return _msg;
}
inline void TupleToUserset::set_allocated_computed_userset(::openfga::v1::ObjectRelation* computed_userset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.computed_userset_;
  }
  if (computed_userset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(computed_userset);
    if (message_arena != submessage_arena) {
      computed_userset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, computed_userset, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.computed_userset_ = computed_userset;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.TupleToUserset.computed_userset)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Condition

// string name = 1 [json_name = "name", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void Condition::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Condition::name() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Condition.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Condition::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.Condition.name)
}
inline std::string* Condition::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Condition.name)
  return _s;
}
inline const std::string& Condition::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Condition::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Condition::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Condition::release_name() {
  // @@protoc_insertion_point(field_release:openfga.v1.Condition.name)
  return _impl_.name_.Release();
}
inline void Condition::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.Condition.name)
}

// string expression = 2 [json_name = "expression", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void Condition::clear_expression() {
  _impl_.expression_.ClearToEmpty();
}
inline const std::string& Condition::expression() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Condition.expression)
  return _internal_expression();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Condition::set_expression(ArgT0&& arg0, ArgT... args) {
 
 _impl_.expression_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.Condition.expression)
}
inline std::string* Condition::mutable_expression() {
  std::string* _s = _internal_mutable_expression();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Condition.expression)
  return _s;
}
inline const std::string& Condition::_internal_expression() const {
  return _impl_.expression_.Get();
}
inline void Condition::_internal_set_expression(const std::string& value) {
  
  _impl_.expression_.Set(value, GetArenaForAllocation());
}
inline std::string* Condition::_internal_mutable_expression() {
  
  return _impl_.expression_.Mutable(GetArenaForAllocation());
}
inline std::string* Condition::release_expression() {
  // @@protoc_insertion_point(field_release:openfga.v1.Condition.expression)
  return _impl_.expression_.Release();
}
inline void Condition::set_allocated_expression(std::string* expression) {
  if (expression != nullptr) {
    
  } else {
    
  }
  _impl_.expression_.SetAllocated(expression, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.expression_.IsDefault()) {
    _impl_.expression_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.Condition.expression)
}

// map<string, .openfga.v1.ConditionParamTypeRef> parameters = 3 [json_name = "parameters", (.validate.rules) = {
inline int Condition::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int Condition::parameters_size() const {
  return _internal_parameters_size();
}
inline void Condition::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::ConditionParamTypeRef >&
Condition::_internal_parameters() const {
  return _impl_.parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::ConditionParamTypeRef >&
Condition::parameters() const {
  // @@protoc_insertion_point(field_map:openfga.v1.Condition.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::ConditionParamTypeRef >*
Condition::_internal_mutable_parameters() {
  return _impl_.parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::ConditionParamTypeRef >*
Condition::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:openfga.v1.Condition.parameters)
  return _internal_mutable_parameters();
}

// .openfga.v1.ConditionMetadata metadata = 4 [json_name = "metadata"];
inline bool Condition::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool Condition::has_metadata() const {
  return _internal_has_metadata();
}
inline void Condition::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && _impl_.metadata_ != nullptr) {
    delete _impl_.metadata_;
  }
  _impl_.metadata_ = nullptr;
}
inline const ::openfga::v1::ConditionMetadata& Condition::_internal_metadata() const {
  const ::openfga::v1::ConditionMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::ConditionMetadata&>(
      ::openfga::v1::_ConditionMetadata_default_instance_);
}
inline const ::openfga::v1::ConditionMetadata& Condition::metadata() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Condition.metadata)
  return _internal_metadata();
}
inline void Condition::unsafe_arena_set_allocated_metadata(
    ::openfga::v1::ConditionMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.Condition.metadata)
}
inline ::openfga::v1::ConditionMetadata* Condition::release_metadata() {
  
  ::openfga::v1::ConditionMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::ConditionMetadata* Condition::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:openfga.v1.Condition.metadata)
  
  ::openfga::v1::ConditionMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::openfga::v1::ConditionMetadata* Condition::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::ConditionMetadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::openfga::v1::ConditionMetadata* Condition::mutable_metadata() {
  ::openfga::v1::ConditionMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Condition.metadata)
  return _msg;
}
inline void Condition::set_allocated_metadata(::openfga::v1::ConditionMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.Condition.metadata)
}

// -------------------------------------------------------------------

// ConditionMetadata

// string module = 1 [json_name = "module", (.validate.rules) = {
inline void ConditionMetadata::clear_module() {
  _impl_.module_.ClearToEmpty();
}
inline const std::string& ConditionMetadata::module() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ConditionMetadata.module)
  return _internal_module();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConditionMetadata::set_module(ArgT0&& arg0, ArgT... args) {
 
 _impl_.module_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.ConditionMetadata.module)
}
inline std::string* ConditionMetadata::mutable_module() {
  std::string* _s = _internal_mutable_module();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ConditionMetadata.module)
  return _s;
}
inline const std::string& ConditionMetadata::_internal_module() const {
  return _impl_.module_.Get();
}
inline void ConditionMetadata::_internal_set_module(const std::string& value) {
  
  _impl_.module_.Set(value, GetArenaForAllocation());
}
inline std::string* ConditionMetadata::_internal_mutable_module() {
  
  return _impl_.module_.Mutable(GetArenaForAllocation());
}
inline std::string* ConditionMetadata::release_module() {
  // @@protoc_insertion_point(field_release:openfga.v1.ConditionMetadata.module)
  return _impl_.module_.Release();
}
inline void ConditionMetadata::set_allocated_module(std::string* module) {
  if (module != nullptr) {
    
  } else {
    
  }
  _impl_.module_.SetAllocated(module, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.module_.IsDefault()) {
    _impl_.module_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ConditionMetadata.module)
}

// .openfga.v1.SourceInfo source_info = 2 [json_name = "source_info"];
inline bool ConditionMetadata::_internal_has_source_info() const {
  return this != internal_default_instance() && _impl_.source_info_ != nullptr;
}
inline bool ConditionMetadata::has_source_info() const {
  return _internal_has_source_info();
}
inline void ConditionMetadata::clear_source_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.source_info_ != nullptr) {
    delete _impl_.source_info_;
  }
  _impl_.source_info_ = nullptr;
}
inline const ::openfga::v1::SourceInfo& ConditionMetadata::_internal_source_info() const {
  const ::openfga::v1::SourceInfo* p = _impl_.source_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::SourceInfo&>(
      ::openfga::v1::_SourceInfo_default_instance_);
}
inline const ::openfga::v1::SourceInfo& ConditionMetadata::source_info() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ConditionMetadata.source_info)
  return _internal_source_info();
}
inline void ConditionMetadata::unsafe_arena_set_allocated_source_info(
    ::openfga::v1::SourceInfo* source_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_info_);
  }
  _impl_.source_info_ = source_info;
  if (source_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.ConditionMetadata.source_info)
}
inline ::openfga::v1::SourceInfo* ConditionMetadata::release_source_info() {
  
  ::openfga::v1::SourceInfo* temp = _impl_.source_info_;
  _impl_.source_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::SourceInfo* ConditionMetadata::unsafe_arena_release_source_info() {
  // @@protoc_insertion_point(field_release:openfga.v1.ConditionMetadata.source_info)
  
  ::openfga::v1::SourceInfo* temp = _impl_.source_info_;
  _impl_.source_info_ = nullptr;
  return temp;
}
inline ::openfga::v1::SourceInfo* ConditionMetadata::_internal_mutable_source_info() {
  
  if (_impl_.source_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::SourceInfo>(GetArenaForAllocation());
    _impl_.source_info_ = p;
  }
  return _impl_.source_info_;
}
inline ::openfga::v1::SourceInfo* ConditionMetadata::mutable_source_info() {
  ::openfga::v1::SourceInfo* _msg = _internal_mutable_source_info();
  // @@protoc_insertion_point(field_mutable:openfga.v1.ConditionMetadata.source_info)
  return _msg;
}
inline void ConditionMetadata::set_allocated_source_info(::openfga::v1::SourceInfo* source_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_info_;
  }
  if (source_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_info);
    if (message_arena != submessage_arena) {
      source_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.source_info_ = source_info;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.ConditionMetadata.source_info)
}

// -------------------------------------------------------------------

// ConditionParamTypeRef

// .openfga.v1.ConditionParamTypeRef.TypeName type_name = 1 [json_name = "type_name", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void ConditionParamTypeRef::clear_type_name() {
  _impl_.type_name_ = 0;
}
inline ::openfga::v1::ConditionParamTypeRef_TypeName ConditionParamTypeRef::_internal_type_name() const {
  return static_cast< ::openfga::v1::ConditionParamTypeRef_TypeName >(_impl_.type_name_);
}
inline ::openfga::v1::ConditionParamTypeRef_TypeName ConditionParamTypeRef::type_name() const {
  // @@protoc_insertion_point(field_get:openfga.v1.ConditionParamTypeRef.type_name)
  return _internal_type_name();
}
inline void ConditionParamTypeRef::_internal_set_type_name(::openfga::v1::ConditionParamTypeRef_TypeName value) {
  
  _impl_.type_name_ = value;
}
inline void ConditionParamTypeRef::set_type_name(::openfga::v1::ConditionParamTypeRef_TypeName value) {
  _internal_set_type_name(value);
  // @@protoc_insertion_point(field_set:openfga.v1.ConditionParamTypeRef.type_name)
}

// repeated .openfga.v1.ConditionParamTypeRef generic_types = 2 [json_name = "generic_types", (.validate.rules) = {
inline int ConditionParamTypeRef::_internal_generic_types_size() const {
  return _impl_.generic_types_.size();
}
inline int ConditionParamTypeRef::generic_types_size() const {
  return _internal_generic_types_size();
}
inline void ConditionParamTypeRef::clear_generic_types() {
  _impl_.generic_types_.Clear();
}
inline ::openfga::v1::ConditionParamTypeRef* ConditionParamTypeRef::mutable_generic_types(int index) {
  // @@protoc_insertion_point(field_mutable:openfga.v1.ConditionParamTypeRef.generic_types)
  return _impl_.generic_types_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::ConditionParamTypeRef >*
ConditionParamTypeRef::mutable_generic_types() {
  // @@protoc_insertion_point(field_mutable_list:openfga.v1.ConditionParamTypeRef.generic_types)
  return &_impl_.generic_types_;
}
inline const ::openfga::v1::ConditionParamTypeRef& ConditionParamTypeRef::_internal_generic_types(int index) const {
  return _impl_.generic_types_.Get(index);
}
inline const ::openfga::v1::ConditionParamTypeRef& ConditionParamTypeRef::generic_types(int index) const {
  // @@protoc_insertion_point(field_get:openfga.v1.ConditionParamTypeRef.generic_types)
  return _internal_generic_types(index);
}
inline ::openfga::v1::ConditionParamTypeRef* ConditionParamTypeRef::_internal_add_generic_types() {
  return _impl_.generic_types_.Add();
}
inline ::openfga::v1::ConditionParamTypeRef* ConditionParamTypeRef::add_generic_types() {
  ::openfga::v1::ConditionParamTypeRef* _add = _internal_add_generic_types();
  // @@protoc_insertion_point(field_add:openfga.v1.ConditionParamTypeRef.generic_types)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::ConditionParamTypeRef >&
ConditionParamTypeRef::generic_types() const {
  // @@protoc_insertion_point(field_list:openfga.v1.ConditionParamTypeRef.generic_types)
  return _impl_.generic_types_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace openfga

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::openfga::v1::ConditionParamTypeRef_TypeName> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::openfga::v1::ConditionParamTypeRef_TypeName>() {
  return ::openfga::v1::ConditionParamTypeRef_TypeName_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_openfga_2fv1_2fauthzmodel_2eproto
