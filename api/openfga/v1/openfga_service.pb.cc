// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: openfga/v1/openfga_service.proto

#include "openfga/v1/openfga_service.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace openfga {
namespace v1 {
PROTOBUF_CONSTEXPR ListObjectsRequest::ListObjectsRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.store_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.authorization_model_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.relation_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.contextual_tuples_)*/nullptr
  , /*decltype(_impl_.context_)*/nullptr
  , /*decltype(_impl_.consistency_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListObjectsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListObjectsRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListObjectsRequestDefaultTypeInternal() {}
  union {
    ListObjectsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListObjectsRequestDefaultTypeInternal _ListObjectsRequest_default_instance_;
PROTOBUF_CONSTEXPR ListObjectsResponse::ListObjectsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.objects_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListObjectsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListObjectsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListObjectsResponseDefaultTypeInternal() {}
  union {
    ListObjectsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListObjectsResponseDefaultTypeInternal _ListObjectsResponse_default_instance_;
PROTOBUF_CONSTEXPR ListUsersRequest::ListUsersRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.user_filters_)*/{}
  , /*decltype(_impl_.contextual_tuples_)*/{}
  , /*decltype(_impl_.store_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.authorization_model_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.relation_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.object_)*/nullptr
  , /*decltype(_impl_.context_)*/nullptr
  , /*decltype(_impl_.consistency_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListUsersRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListUsersRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListUsersRequestDefaultTypeInternal() {}
  union {
    ListUsersRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListUsersRequestDefaultTypeInternal _ListUsersRequest_default_instance_;
PROTOBUF_CONSTEXPR ListUsersResponse::ListUsersResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.users_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListUsersResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListUsersResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListUsersResponseDefaultTypeInternal() {}
  union {
    ListUsersResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListUsersResponseDefaultTypeInternal _ListUsersResponse_default_instance_;
PROTOBUF_CONSTEXPR StreamedListObjectsRequest::StreamedListObjectsRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.store_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.authorization_model_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.relation_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.contextual_tuples_)*/nullptr
  , /*decltype(_impl_.context_)*/nullptr
  , /*decltype(_impl_.consistency_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StreamedListObjectsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamedListObjectsRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamedListObjectsRequestDefaultTypeInternal() {}
  union {
    StreamedListObjectsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamedListObjectsRequestDefaultTypeInternal _StreamedListObjectsRequest_default_instance_;
PROTOBUF_CONSTEXPR StreamedListObjectsResponse::StreamedListObjectsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.object_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StreamedListObjectsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamedListObjectsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamedListObjectsResponseDefaultTypeInternal() {}
  union {
    StreamedListObjectsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamedListObjectsResponseDefaultTypeInternal _StreamedListObjectsResponse_default_instance_;
PROTOBUF_CONSTEXPR ReadRequest::ReadRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.store_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.continuation_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tuple_key_)*/nullptr
  , /*decltype(_impl_.page_size_)*/nullptr
  , /*decltype(_impl_.consistency_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReadRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReadRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReadRequestDefaultTypeInternal() {}
  union {
    ReadRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReadRequestDefaultTypeInternal _ReadRequest_default_instance_;
PROTOBUF_CONSTEXPR ReadRequestTupleKey::ReadRequestTupleKey(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.user_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.relation_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.object_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReadRequestTupleKeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReadRequestTupleKeyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReadRequestTupleKeyDefaultTypeInternal() {}
  union {
    ReadRequestTupleKey _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReadRequestTupleKeyDefaultTypeInternal _ReadRequestTupleKey_default_instance_;
PROTOBUF_CONSTEXPR ReadResponse::ReadResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tuples_)*/{}
  , /*decltype(_impl_.continuation_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReadResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReadResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReadResponseDefaultTypeInternal() {}
  union {
    ReadResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReadResponseDefaultTypeInternal _ReadResponse_default_instance_;
PROTOBUF_CONSTEXPR WriteRequestWrites::WriteRequestWrites(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tuple_keys_)*/{}
  , /*decltype(_impl_.on_duplicate_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WriteRequestWritesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WriteRequestWritesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WriteRequestWritesDefaultTypeInternal() {}
  union {
    WriteRequestWrites _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WriteRequestWritesDefaultTypeInternal _WriteRequestWrites_default_instance_;
PROTOBUF_CONSTEXPR WriteRequestDeletes::WriteRequestDeletes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tuple_keys_)*/{}
  , /*decltype(_impl_.on_missing_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WriteRequestDeletesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WriteRequestDeletesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WriteRequestDeletesDefaultTypeInternal() {}
  union {
    WriteRequestDeletes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WriteRequestDeletesDefaultTypeInternal _WriteRequestDeletes_default_instance_;
PROTOBUF_CONSTEXPR WriteRequest::WriteRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.store_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.authorization_model_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.writes_)*/nullptr
  , /*decltype(_impl_.deletes_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WriteRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WriteRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WriteRequestDefaultTypeInternal() {}
  union {
    WriteRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WriteRequestDefaultTypeInternal _WriteRequest_default_instance_;
PROTOBUF_CONSTEXPR WriteResponse::WriteResponse(
    ::_pbi::ConstantInitialized) {}
struct WriteResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WriteResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WriteResponseDefaultTypeInternal() {}
  union {
    WriteResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WriteResponseDefaultTypeInternal _WriteResponse_default_instance_;
PROTOBUF_CONSTEXPR CheckRequest::CheckRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.store_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.authorization_model_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tuple_key_)*/nullptr
  , /*decltype(_impl_.contextual_tuples_)*/nullptr
  , /*decltype(_impl_.context_)*/nullptr
  , /*decltype(_impl_.trace_)*/false
  , /*decltype(_impl_.consistency_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CheckRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CheckRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CheckRequestDefaultTypeInternal() {}
  union {
    CheckRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CheckRequestDefaultTypeInternal _CheckRequest_default_instance_;
PROTOBUF_CONSTEXPR CheckRequestTupleKey::CheckRequestTupleKey(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.user_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.relation_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.object_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CheckRequestTupleKeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CheckRequestTupleKeyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CheckRequestTupleKeyDefaultTypeInternal() {}
  union {
    CheckRequestTupleKey _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CheckRequestTupleKeyDefaultTypeInternal _CheckRequestTupleKey_default_instance_;
PROTOBUF_CONSTEXPR CheckResponse::CheckResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.resolution_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.allowed_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CheckResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CheckResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CheckResponseDefaultTypeInternal() {}
  union {
    CheckResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CheckResponseDefaultTypeInternal _CheckResponse_default_instance_;
PROTOBUF_CONSTEXPR BatchCheckRequest::BatchCheckRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.checks_)*/{}
  , /*decltype(_impl_.store_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.authorization_model_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.consistency_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BatchCheckRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchCheckRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchCheckRequestDefaultTypeInternal() {}
  union {
    BatchCheckRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchCheckRequestDefaultTypeInternal _BatchCheckRequest_default_instance_;
PROTOBUF_CONSTEXPR BatchCheckItem::BatchCheckItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.correlation_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tuple_key_)*/nullptr
  , /*decltype(_impl_.contextual_tuples_)*/nullptr
  , /*decltype(_impl_.context_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BatchCheckItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchCheckItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchCheckItemDefaultTypeInternal() {}
  union {
    BatchCheckItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchCheckItemDefaultTypeInternal _BatchCheckItem_default_instance_;
PROTOBUF_CONSTEXPR BatchCheckResponse_ResultEntry_DoNotUse::BatchCheckResponse_ResultEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct BatchCheckResponse_ResultEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchCheckResponse_ResultEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchCheckResponse_ResultEntry_DoNotUseDefaultTypeInternal() {}
  union {
    BatchCheckResponse_ResultEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchCheckResponse_ResultEntry_DoNotUseDefaultTypeInternal _BatchCheckResponse_ResultEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR BatchCheckResponse::BatchCheckResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.result_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BatchCheckResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchCheckResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchCheckResponseDefaultTypeInternal() {}
  union {
    BatchCheckResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchCheckResponseDefaultTypeInternal _BatchCheckResponse_default_instance_;
PROTOBUF_CONSTEXPR BatchCheckSingleResult::BatchCheckSingleResult(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.check_result_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct BatchCheckSingleResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchCheckSingleResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchCheckSingleResultDefaultTypeInternal() {}
  union {
    BatchCheckSingleResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchCheckSingleResultDefaultTypeInternal _BatchCheckSingleResult_default_instance_;
PROTOBUF_CONSTEXPR CheckError::CheckError(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.code_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct CheckErrorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CheckErrorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CheckErrorDefaultTypeInternal() {}
  union {
    CheckError _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CheckErrorDefaultTypeInternal _CheckError_default_instance_;
PROTOBUF_CONSTEXPR ExpandRequest::ExpandRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.store_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.authorization_model_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tuple_key_)*/nullptr
  , /*decltype(_impl_.contextual_tuples_)*/nullptr
  , /*decltype(_impl_.consistency_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ExpandRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExpandRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExpandRequestDefaultTypeInternal() {}
  union {
    ExpandRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExpandRequestDefaultTypeInternal _ExpandRequest_default_instance_;
PROTOBUF_CONSTEXPR ExpandRequestTupleKey::ExpandRequestTupleKey(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.relation_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.object_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ExpandRequestTupleKeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExpandRequestTupleKeyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExpandRequestTupleKeyDefaultTypeInternal() {}
  union {
    ExpandRequestTupleKey _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExpandRequestTupleKeyDefaultTypeInternal _ExpandRequestTupleKey_default_instance_;
PROTOBUF_CONSTEXPR ExpandResponse::ExpandResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tree_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ExpandResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExpandResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExpandResponseDefaultTypeInternal() {}
  union {
    ExpandResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExpandResponseDefaultTypeInternal _ExpandResponse_default_instance_;
PROTOBUF_CONSTEXPR ReadAuthorizationModelRequest::ReadAuthorizationModelRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.store_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReadAuthorizationModelRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReadAuthorizationModelRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReadAuthorizationModelRequestDefaultTypeInternal() {}
  union {
    ReadAuthorizationModelRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReadAuthorizationModelRequestDefaultTypeInternal _ReadAuthorizationModelRequest_default_instance_;
PROTOBUF_CONSTEXPR ReadAuthorizationModelResponse::ReadAuthorizationModelResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.authorization_model_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReadAuthorizationModelResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReadAuthorizationModelResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReadAuthorizationModelResponseDefaultTypeInternal() {}
  union {
    ReadAuthorizationModelResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReadAuthorizationModelResponseDefaultTypeInternal _ReadAuthorizationModelResponse_default_instance_;
PROTOBUF_CONSTEXPR WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse::WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct WriteAuthorizationModelRequest_ConditionsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WriteAuthorizationModelRequest_ConditionsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WriteAuthorizationModelRequest_ConditionsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WriteAuthorizationModelRequest_ConditionsEntry_DoNotUseDefaultTypeInternal _WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR WriteAuthorizationModelRequest::WriteAuthorizationModelRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.type_definitions_)*/{}
  , /*decltype(_impl_.conditions_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.store_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.schema_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WriteAuthorizationModelRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WriteAuthorizationModelRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WriteAuthorizationModelRequestDefaultTypeInternal() {}
  union {
    WriteAuthorizationModelRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WriteAuthorizationModelRequestDefaultTypeInternal _WriteAuthorizationModelRequest_default_instance_;
PROTOBUF_CONSTEXPR WriteAuthorizationModelResponse::WriteAuthorizationModelResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.authorization_model_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WriteAuthorizationModelResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WriteAuthorizationModelResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WriteAuthorizationModelResponseDefaultTypeInternal() {}
  union {
    WriteAuthorizationModelResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WriteAuthorizationModelResponseDefaultTypeInternal _WriteAuthorizationModelResponse_default_instance_;
PROTOBUF_CONSTEXPR ReadAuthorizationModelsRequest::ReadAuthorizationModelsRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.store_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.continuation_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_size_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReadAuthorizationModelsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReadAuthorizationModelsRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReadAuthorizationModelsRequestDefaultTypeInternal() {}
  union {
    ReadAuthorizationModelsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReadAuthorizationModelsRequestDefaultTypeInternal _ReadAuthorizationModelsRequest_default_instance_;
PROTOBUF_CONSTEXPR ReadAuthorizationModelsResponse::ReadAuthorizationModelsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.authorization_models_)*/{}
  , /*decltype(_impl_.continuation_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReadAuthorizationModelsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReadAuthorizationModelsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReadAuthorizationModelsResponseDefaultTypeInternal() {}
  union {
    ReadAuthorizationModelsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReadAuthorizationModelsResponseDefaultTypeInternal _ReadAuthorizationModelsResponse_default_instance_;
PROTOBUF_CONSTEXPR WriteAssertionsRequest::WriteAssertionsRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.assertions_)*/{}
  , /*decltype(_impl_.store_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.authorization_model_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WriteAssertionsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WriteAssertionsRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WriteAssertionsRequestDefaultTypeInternal() {}
  union {
    WriteAssertionsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WriteAssertionsRequestDefaultTypeInternal _WriteAssertionsRequest_default_instance_;
PROTOBUF_CONSTEXPR WriteAssertionsResponse::WriteAssertionsResponse(
    ::_pbi::ConstantInitialized) {}
struct WriteAssertionsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WriteAssertionsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WriteAssertionsResponseDefaultTypeInternal() {}
  union {
    WriteAssertionsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WriteAssertionsResponseDefaultTypeInternal _WriteAssertionsResponse_default_instance_;
PROTOBUF_CONSTEXPR ReadAssertionsRequest::ReadAssertionsRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.store_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.authorization_model_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReadAssertionsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReadAssertionsRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReadAssertionsRequestDefaultTypeInternal() {}
  union {
    ReadAssertionsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReadAssertionsRequestDefaultTypeInternal _ReadAssertionsRequest_default_instance_;
PROTOBUF_CONSTEXPR ReadAssertionsResponse::ReadAssertionsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.assertions_)*/{}
  , /*decltype(_impl_.authorization_model_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReadAssertionsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReadAssertionsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReadAssertionsResponseDefaultTypeInternal() {}
  union {
    ReadAssertionsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReadAssertionsResponseDefaultTypeInternal _ReadAssertionsResponse_default_instance_;
PROTOBUF_CONSTEXPR ReadChangesRequest::ReadChangesRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.store_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.continuation_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_size_)*/nullptr
  , /*decltype(_impl_.start_time_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReadChangesRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReadChangesRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReadChangesRequestDefaultTypeInternal() {}
  union {
    ReadChangesRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReadChangesRequestDefaultTypeInternal _ReadChangesRequest_default_instance_;
PROTOBUF_CONSTEXPR ReadChangesResponse::ReadChangesResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.changes_)*/{}
  , /*decltype(_impl_.continuation_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReadChangesResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReadChangesResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReadChangesResponseDefaultTypeInternal() {}
  union {
    ReadChangesResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReadChangesResponseDefaultTypeInternal _ReadChangesResponse_default_instance_;
PROTOBUF_CONSTEXPR CreateStoreRequest::CreateStoreRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateStoreRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateStoreRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateStoreRequestDefaultTypeInternal() {}
  union {
    CreateStoreRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateStoreRequestDefaultTypeInternal _CreateStoreRequest_default_instance_;
PROTOBUF_CONSTEXPR CreateStoreResponse::CreateStoreResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.created_at_)*/nullptr
  , /*decltype(_impl_.updated_at_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateStoreResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateStoreResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateStoreResponseDefaultTypeInternal() {}
  union {
    CreateStoreResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateStoreResponseDefaultTypeInternal _CreateStoreResponse_default_instance_;
PROTOBUF_CONSTEXPR UpdateStoreRequest::UpdateStoreRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.store_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpdateStoreRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateStoreRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateStoreRequestDefaultTypeInternal() {}
  union {
    UpdateStoreRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateStoreRequestDefaultTypeInternal _UpdateStoreRequest_default_instance_;
PROTOBUF_CONSTEXPR UpdateStoreResponse::UpdateStoreResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.created_at_)*/nullptr
  , /*decltype(_impl_.updated_at_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpdateStoreResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateStoreResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateStoreResponseDefaultTypeInternal() {}
  union {
    UpdateStoreResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateStoreResponseDefaultTypeInternal _UpdateStoreResponse_default_instance_;
PROTOBUF_CONSTEXPR DeleteStoreRequest::DeleteStoreRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.store_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeleteStoreRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteStoreRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteStoreRequestDefaultTypeInternal() {}
  union {
    DeleteStoreRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteStoreRequestDefaultTypeInternal _DeleteStoreRequest_default_instance_;
PROTOBUF_CONSTEXPR DeleteStoreResponse::DeleteStoreResponse(
    ::_pbi::ConstantInitialized) {}
struct DeleteStoreResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteStoreResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteStoreResponseDefaultTypeInternal() {}
  union {
    DeleteStoreResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteStoreResponseDefaultTypeInternal _DeleteStoreResponse_default_instance_;
PROTOBUF_CONSTEXPR GetStoreRequest::GetStoreRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.store_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetStoreRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetStoreRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetStoreRequestDefaultTypeInternal() {}
  union {
    GetStoreRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetStoreRequestDefaultTypeInternal _GetStoreRequest_default_instance_;
PROTOBUF_CONSTEXPR GetStoreResponse::GetStoreResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.created_at_)*/nullptr
  , /*decltype(_impl_.updated_at_)*/nullptr
  , /*decltype(_impl_.deleted_at_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetStoreResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetStoreResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetStoreResponseDefaultTypeInternal() {}
  union {
    GetStoreResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetStoreResponseDefaultTypeInternal _GetStoreResponse_default_instance_;
PROTOBUF_CONSTEXPR ListStoresRequest::ListStoresRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.continuation_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_size_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListStoresRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListStoresRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListStoresRequestDefaultTypeInternal() {}
  union {
    ListStoresRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListStoresRequestDefaultTypeInternal _ListStoresRequest_default_instance_;
PROTOBUF_CONSTEXPR ListStoresResponse::ListStoresResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stores_)*/{}
  , /*decltype(_impl_.continuation_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListStoresResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListStoresResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListStoresResponseDefaultTypeInternal() {}
  union {
    ListStoresResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListStoresResponseDefaultTypeInternal _ListStoresResponse_default_instance_;
PROTOBUF_CONSTEXPR AssertionTupleKey::AssertionTupleKey(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.object_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.relation_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AssertionTupleKeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AssertionTupleKeyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AssertionTupleKeyDefaultTypeInternal() {}
  union {
    AssertionTupleKey _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AssertionTupleKeyDefaultTypeInternal _AssertionTupleKey_default_instance_;
PROTOBUF_CONSTEXPR Assertion::Assertion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.contextual_tuples_)*/{}
  , /*decltype(_impl_.tuple_key_)*/nullptr
  , /*decltype(_impl_.context_)*/nullptr
  , /*decltype(_impl_.expectation_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AssertionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AssertionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AssertionDefaultTypeInternal() {}
  union {
    Assertion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AssertionDefaultTypeInternal _Assertion_default_instance_;
PROTOBUF_CONSTEXPR Assertions::Assertions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.assertions_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AssertionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AssertionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AssertionsDefaultTypeInternal() {}
  union {
    Assertions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AssertionsDefaultTypeInternal _Assertions_default_instance_;
}  // namespace v1
}  // namespace openfga
static ::_pb::Metadata file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[51];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_openfga_2fv1_2fopenfga_5fservice_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_openfga_2fv1_2fopenfga_5fservice_2eproto = nullptr;

const uint32_t TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListObjectsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListObjectsRequest, _impl_.store_id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListObjectsRequest, _impl_.authorization_model_id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListObjectsRequest, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListObjectsRequest, _impl_.relation_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListObjectsRequest, _impl_.user_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListObjectsRequest, _impl_.contextual_tuples_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListObjectsRequest, _impl_.context_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListObjectsRequest, _impl_.consistency_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListObjectsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListObjectsResponse, _impl_.objects_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListUsersRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListUsersRequest, _impl_.store_id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListUsersRequest, _impl_.authorization_model_id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListUsersRequest, _impl_.object_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListUsersRequest, _impl_.relation_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListUsersRequest, _impl_.user_filters_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListUsersRequest, _impl_.contextual_tuples_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListUsersRequest, _impl_.context_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListUsersRequest, _impl_.consistency_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListUsersResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListUsersResponse, _impl_.users_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::StreamedListObjectsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::StreamedListObjectsRequest, _impl_.store_id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::StreamedListObjectsRequest, _impl_.authorization_model_id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::StreamedListObjectsRequest, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::StreamedListObjectsRequest, _impl_.relation_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::StreamedListObjectsRequest, _impl_.user_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::StreamedListObjectsRequest, _impl_.contextual_tuples_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::StreamedListObjectsRequest, _impl_.context_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::StreamedListObjectsRequest, _impl_.consistency_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::StreamedListObjectsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::StreamedListObjectsResponse, _impl_.object_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadRequest, _impl_.store_id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadRequest, _impl_.tuple_key_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadRequest, _impl_.page_size_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadRequest, _impl_.continuation_token_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadRequest, _impl_.consistency_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadRequestTupleKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadRequestTupleKey, _impl_.user_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadRequestTupleKey, _impl_.relation_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadRequestTupleKey, _impl_.object_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadResponse, _impl_.tuples_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadResponse, _impl_.continuation_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteRequestWrites, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteRequestWrites, _impl_.tuple_keys_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteRequestWrites, _impl_.on_duplicate_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteRequestDeletes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteRequestDeletes, _impl_.tuple_keys_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteRequestDeletes, _impl_.on_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteRequest, _impl_.store_id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteRequest, _impl_.writes_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteRequest, _impl_.deletes_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteRequest, _impl_.authorization_model_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::CheckRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::CheckRequest, _impl_.store_id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::CheckRequest, _impl_.tuple_key_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::CheckRequest, _impl_.contextual_tuples_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::CheckRequest, _impl_.authorization_model_id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::CheckRequest, _impl_.trace_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::CheckRequest, _impl_.context_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::CheckRequest, _impl_.consistency_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::CheckRequestTupleKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::CheckRequestTupleKey, _impl_.user_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::CheckRequestTupleKey, _impl_.relation_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::CheckRequestTupleKey, _impl_.object_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::CheckResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::CheckResponse, _impl_.allowed_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::CheckResponse, _impl_.resolution_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::BatchCheckRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::BatchCheckRequest, _impl_.store_id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::BatchCheckRequest, _impl_.checks_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::BatchCheckRequest, _impl_.authorization_model_id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::BatchCheckRequest, _impl_.consistency_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::BatchCheckItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::BatchCheckItem, _impl_.tuple_key_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::BatchCheckItem, _impl_.contextual_tuples_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::BatchCheckItem, _impl_.context_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::BatchCheckItem, _impl_.correlation_id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::BatchCheckResponse_ResultEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::BatchCheckResponse_ResultEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::BatchCheckResponse_ResultEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::BatchCheckResponse_ResultEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::BatchCheckResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::BatchCheckResponse, _impl_.result_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::BatchCheckSingleResult, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::BatchCheckSingleResult, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::openfga::v1::BatchCheckSingleResult, _impl_.check_result_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::CheckError, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::CheckError, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::openfga::v1::CheckError, _impl_.message_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::CheckError, _impl_.code_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ExpandRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ExpandRequest, _impl_.store_id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ExpandRequest, _impl_.tuple_key_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ExpandRequest, _impl_.authorization_model_id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ExpandRequest, _impl_.consistency_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ExpandRequest, _impl_.contextual_tuples_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ExpandRequestTupleKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ExpandRequestTupleKey, _impl_.relation_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ExpandRequestTupleKey, _impl_.object_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ExpandResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ExpandResponse, _impl_.tree_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadAuthorizationModelRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadAuthorizationModelRequest, _impl_.store_id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadAuthorizationModelRequest, _impl_.id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadAuthorizationModelResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadAuthorizationModelResponse, _impl_.authorization_model_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteAuthorizationModelRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteAuthorizationModelRequest, _impl_.store_id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteAuthorizationModelRequest, _impl_.type_definitions_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteAuthorizationModelRequest, _impl_.schema_version_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteAuthorizationModelRequest, _impl_.conditions_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteAuthorizationModelResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteAuthorizationModelResponse, _impl_.authorization_model_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadAuthorizationModelsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadAuthorizationModelsRequest, _impl_.store_id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadAuthorizationModelsRequest, _impl_.page_size_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadAuthorizationModelsRequest, _impl_.continuation_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadAuthorizationModelsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadAuthorizationModelsResponse, _impl_.authorization_models_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadAuthorizationModelsResponse, _impl_.continuation_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteAssertionsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteAssertionsRequest, _impl_.store_id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteAssertionsRequest, _impl_.authorization_model_id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteAssertionsRequest, _impl_.assertions_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::WriteAssertionsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadAssertionsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadAssertionsRequest, _impl_.store_id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadAssertionsRequest, _impl_.authorization_model_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadAssertionsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadAssertionsResponse, _impl_.authorization_model_id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadAssertionsResponse, _impl_.assertions_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadChangesRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadChangesRequest, _impl_.store_id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadChangesRequest, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadChangesRequest, _impl_.page_size_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadChangesRequest, _impl_.continuation_token_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadChangesRequest, _impl_.start_time_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadChangesResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadChangesResponse, _impl_.changes_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ReadChangesResponse, _impl_.continuation_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::CreateStoreRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::CreateStoreRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::CreateStoreResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::CreateStoreResponse, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::CreateStoreResponse, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::CreateStoreResponse, _impl_.created_at_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::CreateStoreResponse, _impl_.updated_at_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UpdateStoreRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UpdateStoreRequest, _impl_.store_id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UpdateStoreRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UpdateStoreResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UpdateStoreResponse, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UpdateStoreResponse, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UpdateStoreResponse, _impl_.created_at_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::UpdateStoreResponse, _impl_.updated_at_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::DeleteStoreRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::DeleteStoreRequest, _impl_.store_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::DeleteStoreResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::GetStoreRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::GetStoreRequest, _impl_.store_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::GetStoreResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::GetStoreResponse, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::GetStoreResponse, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::GetStoreResponse, _impl_.created_at_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::GetStoreResponse, _impl_.updated_at_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::GetStoreResponse, _impl_.deleted_at_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListStoresRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListStoresRequest, _impl_.page_size_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListStoresRequest, _impl_.continuation_token_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListStoresRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListStoresResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListStoresResponse, _impl_.stores_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::ListStoresResponse, _impl_.continuation_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::AssertionTupleKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::AssertionTupleKey, _impl_.object_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::AssertionTupleKey, _impl_.relation_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::AssertionTupleKey, _impl_.user_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::Assertion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::Assertion, _impl_.tuple_key_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::Assertion, _impl_.expectation_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::Assertion, _impl_.contextual_tuples_),
  PROTOBUF_FIELD_OFFSET(::openfga::v1::Assertion, _impl_.context_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::Assertions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::openfga::v1::Assertions, _impl_.assertions_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::openfga::v1::ListObjectsRequest)},
  { 14, -1, -1, sizeof(::openfga::v1::ListObjectsResponse)},
  { 21, -1, -1, sizeof(::openfga::v1::ListUsersRequest)},
  { 35, -1, -1, sizeof(::openfga::v1::ListUsersResponse)},
  { 42, -1, -1, sizeof(::openfga::v1::StreamedListObjectsRequest)},
  { 56, -1, -1, sizeof(::openfga::v1::StreamedListObjectsResponse)},
  { 63, -1, -1, sizeof(::openfga::v1::ReadRequest)},
  { 74, -1, -1, sizeof(::openfga::v1::ReadRequestTupleKey)},
  { 83, -1, -1, sizeof(::openfga::v1::ReadResponse)},
  { 91, -1, -1, sizeof(::openfga::v1::WriteRequestWrites)},
  { 99, -1, -1, sizeof(::openfga::v1::WriteRequestDeletes)},
  { 107, -1, -1, sizeof(::openfga::v1::WriteRequest)},
  { 117, -1, -1, sizeof(::openfga::v1::WriteResponse)},
  { 123, -1, -1, sizeof(::openfga::v1::CheckRequest)},
  { 136, -1, -1, sizeof(::openfga::v1::CheckRequestTupleKey)},
  { 145, -1, -1, sizeof(::openfga::v1::CheckResponse)},
  { 153, -1, -1, sizeof(::openfga::v1::BatchCheckRequest)},
  { 163, -1, -1, sizeof(::openfga::v1::BatchCheckItem)},
  { 173, 181, -1, sizeof(::openfga::v1::BatchCheckResponse_ResultEntry_DoNotUse)},
  { 183, -1, -1, sizeof(::openfga::v1::BatchCheckResponse)},
  { 190, -1, -1, sizeof(::openfga::v1::BatchCheckSingleResult)},
  { 199, -1, -1, sizeof(::openfga::v1::CheckError)},
  { 209, -1, -1, sizeof(::openfga::v1::ExpandRequest)},
  { 220, -1, -1, sizeof(::openfga::v1::ExpandRequestTupleKey)},
  { 228, -1, -1, sizeof(::openfga::v1::ExpandResponse)},
  { 235, -1, -1, sizeof(::openfga::v1::ReadAuthorizationModelRequest)},
  { 243, -1, -1, sizeof(::openfga::v1::ReadAuthorizationModelResponse)},
  { 250, 258, -1, sizeof(::openfga::v1::WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse)},
  { 260, -1, -1, sizeof(::openfga::v1::WriteAuthorizationModelRequest)},
  { 270, -1, -1, sizeof(::openfga::v1::WriteAuthorizationModelResponse)},
  { 277, -1, -1, sizeof(::openfga::v1::ReadAuthorizationModelsRequest)},
  { 286, -1, -1, sizeof(::openfga::v1::ReadAuthorizationModelsResponse)},
  { 294, -1, -1, sizeof(::openfga::v1::WriteAssertionsRequest)},
  { 303, -1, -1, sizeof(::openfga::v1::WriteAssertionsResponse)},
  { 309, -1, -1, sizeof(::openfga::v1::ReadAssertionsRequest)},
  { 317, -1, -1, sizeof(::openfga::v1::ReadAssertionsResponse)},
  { 325, -1, -1, sizeof(::openfga::v1::ReadChangesRequest)},
  { 336, -1, -1, sizeof(::openfga::v1::ReadChangesResponse)},
  { 344, -1, -1, sizeof(::openfga::v1::CreateStoreRequest)},
  { 351, -1, -1, sizeof(::openfga::v1::CreateStoreResponse)},
  { 361, -1, -1, sizeof(::openfga::v1::UpdateStoreRequest)},
  { 369, -1, -1, sizeof(::openfga::v1::UpdateStoreResponse)},
  { 379, -1, -1, sizeof(::openfga::v1::DeleteStoreRequest)},
  { 386, -1, -1, sizeof(::openfga::v1::DeleteStoreResponse)},
  { 392, -1, -1, sizeof(::openfga::v1::GetStoreRequest)},
  { 399, -1, -1, sizeof(::openfga::v1::GetStoreResponse)},
  { 410, -1, -1, sizeof(::openfga::v1::ListStoresRequest)},
  { 419, -1, -1, sizeof(::openfga::v1::ListStoresResponse)},
  { 427, -1, -1, sizeof(::openfga::v1::AssertionTupleKey)},
  { 436, -1, -1, sizeof(::openfga::v1::Assertion)},
  { 446, -1, -1, sizeof(::openfga::v1::Assertions)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::openfga::v1::_ListObjectsRequest_default_instance_._instance,
  &::openfga::v1::_ListObjectsResponse_default_instance_._instance,
  &::openfga::v1::_ListUsersRequest_default_instance_._instance,
  &::openfga::v1::_ListUsersResponse_default_instance_._instance,
  &::openfga::v1::_StreamedListObjectsRequest_default_instance_._instance,
  &::openfga::v1::_StreamedListObjectsResponse_default_instance_._instance,
  &::openfga::v1::_ReadRequest_default_instance_._instance,
  &::openfga::v1::_ReadRequestTupleKey_default_instance_._instance,
  &::openfga::v1::_ReadResponse_default_instance_._instance,
  &::openfga::v1::_WriteRequestWrites_default_instance_._instance,
  &::openfga::v1::_WriteRequestDeletes_default_instance_._instance,
  &::openfga::v1::_WriteRequest_default_instance_._instance,
  &::openfga::v1::_WriteResponse_default_instance_._instance,
  &::openfga::v1::_CheckRequest_default_instance_._instance,
  &::openfga::v1::_CheckRequestTupleKey_default_instance_._instance,
  &::openfga::v1::_CheckResponse_default_instance_._instance,
  &::openfga::v1::_BatchCheckRequest_default_instance_._instance,
  &::openfga::v1::_BatchCheckItem_default_instance_._instance,
  &::openfga::v1::_BatchCheckResponse_ResultEntry_DoNotUse_default_instance_._instance,
  &::openfga::v1::_BatchCheckResponse_default_instance_._instance,
  &::openfga::v1::_BatchCheckSingleResult_default_instance_._instance,
  &::openfga::v1::_CheckError_default_instance_._instance,
  &::openfga::v1::_ExpandRequest_default_instance_._instance,
  &::openfga::v1::_ExpandRequestTupleKey_default_instance_._instance,
  &::openfga::v1::_ExpandResponse_default_instance_._instance,
  &::openfga::v1::_ReadAuthorizationModelRequest_default_instance_._instance,
  &::openfga::v1::_ReadAuthorizationModelResponse_default_instance_._instance,
  &::openfga::v1::_WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse_default_instance_._instance,
  &::openfga::v1::_WriteAuthorizationModelRequest_default_instance_._instance,
  &::openfga::v1::_WriteAuthorizationModelResponse_default_instance_._instance,
  &::openfga::v1::_ReadAuthorizationModelsRequest_default_instance_._instance,
  &::openfga::v1::_ReadAuthorizationModelsResponse_default_instance_._instance,
  &::openfga::v1::_WriteAssertionsRequest_default_instance_._instance,
  &::openfga::v1::_WriteAssertionsResponse_default_instance_._instance,
  &::openfga::v1::_ReadAssertionsRequest_default_instance_._instance,
  &::openfga::v1::_ReadAssertionsResponse_default_instance_._instance,
  &::openfga::v1::_ReadChangesRequest_default_instance_._instance,
  &::openfga::v1::_ReadChangesResponse_default_instance_._instance,
  &::openfga::v1::_CreateStoreRequest_default_instance_._instance,
  &::openfga::v1::_CreateStoreResponse_default_instance_._instance,
  &::openfga::v1::_UpdateStoreRequest_default_instance_._instance,
  &::openfga::v1::_UpdateStoreResponse_default_instance_._instance,
  &::openfga::v1::_DeleteStoreRequest_default_instance_._instance,
  &::openfga::v1::_DeleteStoreResponse_default_instance_._instance,
  &::openfga::v1::_GetStoreRequest_default_instance_._instance,
  &::openfga::v1::_GetStoreResponse_default_instance_._instance,
  &::openfga::v1::_ListStoresRequest_default_instance_._instance,
  &::openfga::v1::_ListStoresResponse_default_instance_._instance,
  &::openfga::v1::_AssertionTupleKey_default_instance_._instance,
  &::openfga::v1::_Assertion_default_instance_._instance,
  &::openfga::v1::_Assertions_default_instance_._instance,
};

const char descriptor_table_protodef_openfga_2fv1_2fopenfga_5fservice_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n openfga/v1/openfga_service.proto\022\nopen"
  "fga.v1\032\034google/api/annotations.proto\032\037go"
  "ogle/api/field_behavior.proto\032\033google/ap"
  "i/visibility.proto\032\034google/protobuf/stru"
  "ct.proto\032\037google/protobuf/timestamp.prot"
  "o\032\036google/protobuf/wrappers.proto\032\033openf"
  "ga/v1/authzmodel.proto\032\036openfga/v1/error"
  "s_ignore.proto\032\030openfga/v1/openfga.proto"
  "\032,openfga/v1/openfga_service_consistency"
  ".proto\032.protoc-gen-openapiv2/options/ann"
  "otations.proto\032\027validate/validate.proto\""
  "\221\005\n\022ListObjectsRequest\022e\n\010store_id\030\001 \001(\t"
  "BI\222A\036J\034\"01YCP46JKYM8FJCQ37NMBYHE5X\"\372B%r#"
  "2!^[ABCDEFGHJKMNPQRSTVWXYZ0-9]{26}$R\010sto"
  "re_id\022\204\001\n\026authorization_model_id\030\002 \001(\tBL"
  "\222A\036J\034\"01G5JAVJ41T49E9TT3SKVS7X1J\"\372B(r&2!"
  "^[ABCDEFGHJKMNPQRSTVWXYZ0-9]{26}$\320\001\001R\026au"
  "thorization_model_id\022>\n\004type\030\003 \001(\tB*\222A\014J"
  "\n\"document\"\340A\002\372B\025r\0232\021^[^:#@\\s]{1,254}$R\004"
  "type\022C\n\010relation\030\004 \001(\tB\'\222A\nJ\010\"reader\"\340A\002"
  "\372B\024r\0222\020^[^:#@\\s]{1,50}$R\010relation\0227\n\004use"
  "r\030\005 \001(\tB#\222A\023J\013\"user:anne\"x\200\004\200\001\001\340A\002\372B\007r\005 "
  "\001(\200\004R\004user\022M\n\021contextual_tuples\030\006 \001(\0132\037."
  "openfga.v1.ContextualTupleKeysR\021contextu"
  "al_tuples\0221\n\007context\030\007 \001(\0132\027.google.prot"
  "obuf.StructR\007context\022M\n\013consistency\030\010 \001("
  "\0162!.openfga.v1.ConsistencyPreferenceB\010\372B"
  "\005\202\001\002\020\001R\013consistency\"a\n\023ListObjectsRespon"
  "se\022J\n\007objects\030\001 \003(\tB0\222A*J([\"document:roa"
  "dmap\",\"document:planning\"]\340A\002R\007objects\"\302"
  "\006\n\020ListUsersRequest\022e\n\010store_id\030\001 \001(\tBI\222"
  "A\036J\034\"01YCP46JKYM8FJCQ37NMBYHE5X\"\372B%r#2!^"
  "[ABCDEFGHJKMNPQRSTVWXYZ0-9]{26}$R\010store_"
  "id\022\204\001\n\026authorization_model_id\030\002 \001(\tBL\222A\036"
  "J\034\"01G5JAVJ41T49E9TT3SKVS7X1J\"\372B(r&2!^[A"
  "BCDEFGHJKMNPQRSTVWXYZ0-9]{26}$\320\001\001R\026autho"
  "rization_model_id\022N\n\006object\030\003 \001(\0132\022.open"
  "fga.v1.ObjectB\"\222A\024J\022\"document:example\"\340A"
  "\002\372B\005\212\001\002\020\001R\006object\022C\n\010relation\030\004 \001(\tB\'\222A\n"
  "J\010\"reader\"\340A\002\372B\024r\0222\020^[^:#@\\s]{1,50}$R\010re"
  "lation\022\324\001\n\014user_filters\030\005 \003(\0132\032.openfga."
  "v1.UserTypeFilterB\223\001\222A\202\0012=The type of re"
  "sults returned. Only accepts exactly one"
  " value.J;[{\"type\": \"user\"}, {\"type\": \"gr"
  "oup\", \"relation\": \"member\"}]\240\001\001\250\001\001\340A\002\372B\007"
  "\222\001\004\010\001\020\001R\014user_filters\022R\n\021contextual_tupl"
  "es\030\006 \003(\0132\024.openfga.v1.TupleKeyB\016\222A\003\240\001d\372B"
  "\005\222\001\002\020dR\021contextual_tuples\0221\n\007context\030\007 \001"
  "(\0132\027.google.protobuf.StructR\007context\022M\n\013"
  "consistency\030\010 \001(\0162!.openfga.v1.Consisten"
  "cyPreferenceB\010\372B\005\202\001\002\020\001R\013consistency\"C\n\021L"
  "istUsersResponse\022.\n\005users\030\001 \003(\0132\020.openfg"
  "a.v1.UserB\006\222A\000\340A\002R\005users\"\231\005\n\032StreamedLis"
  "tObjectsRequest\022e\n\010store_id\030\001 \001(\tBI\222A\036J\034"
  "\"01YCP46JKYM8FJCQ37NMBYHE5X\"\372B%r#2!^[ABC"
  "DEFGHJKMNPQRSTVWXYZ0-9]{26}$R\010store_id\022\204"
  "\001\n\026authorization_model_id\030\002 \001(\tBL\222A\036J\034\"0"
  "1G5JAVJ41T49E9TT3SKVS7X1J\"\372B(r&2!^[ABCDE"
  "FGHJKMNPQRSTVWXYZ0-9]{26}$\320\001\001R\026authoriza"
  "tion_model_id\022>\n\004type\030\003 \001(\tB*\222A\014J\n\"docum"
  "ent\"\340A\002\372B\025r\0232\021^[^:#@\\s]{1,254}$R\004type\022C\n"
  "\010relation\030\004 \001(\tB\'\222A\nJ\010\"reader\"\340A\002\372B\024r\0222\020"
  "^[^:#@\\s]{1,50}$R\010relation\0227\n\004user\030\005 \001(\t"
  "B#\222A\023J\013\"user:anne\"x\200\004\200\001\001\340A\002\372B\007r\005 \001(\200\004R\004u"
  "ser\022M\n\021contextual_tuples\030\006 \001(\0132\037.openfga"
  ".v1.ContextualTupleKeysR\021contextual_tupl"
  "es\0221\n\007context\030\007 \001(\0132\027.google.protobuf.St"
  "ructR\007context\022M\n\013consistency\030\010 \001(\0162!.ope"
  "nfga.v1.ConsistencyPreferenceB\010\372B\005\202\001\002\020\001R"
  "\013consistency\"Q\n\033StreamedListObjectsRespo"
  "nse\0222\n\006object\030\001 \001(\tB\032\222A\024J\022\"document:road"
  "map\"\340A\002R\006object\"\242\004\n\013ReadRequest\022h\n\010store"
  "_id\030\001 \001(\tBL\222A\036J\034\"01YCP46JKYM8FJCQ37NMBYH"
  "E5X\"\340A\002\372B%r#2!^[ABCDEFGHJKMNPQRSTVWXYZ0-"
  "9]{26}$R\010store_id\022=\n\ttuple_key\030\002 \001(\0132\037.o"
  "penfga.v1.ReadRequestTupleKeyR\ttuple_key"
  "\022]\n\tpage_size\030\003 \001(\0132\033.google.protobuf.In"
  "t32ValueB\"\222A\026J\00250Y\000\000\000\000\000\000Y@i\000\000\000\000\000\000\360\?\372B\006\032\004"
  "\030d(\001R\tpage_size\022\273\001\n\022continuation_token\030\004"
  " \001(\tB\212\001\222AdJb\"eyJwayI6IkxBVEVTVF9OU0NPTkZ"
  "JR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZ"
  "LZExTcUoyN01MdTdqTjh0cWgifQ==\"\372B r\036(\200(2\031"
  "^$|^[A-Za-z0-9-_]+={0,2}$R\022continuation_"
  "token\022M\n\013consistency\030\005 \001(\0162!.openfga.v1."
  "ConsistencyPreferenceB\010\372B\005\202\001\002\020\001R\013consist"
  "ency\"\375\001\n\023ReadRequestTupleKey\022O\n\004user\030\001 \001"
  "(\tB;\222A\020J\013\"user:anne\"x\200\004\372B%r#(\200\0042\033^[^\\s]{"
  "1,511}:[^\\s]{1,511}$\320\001\001R\004user\022E\n\010relatio"
  "n\030\002 \001(\tB)\222A\014J\010\"reader\"x2\372B\027r\0252\020^[^:#@\\s]"
  "{1,50}$\320\001\001R\010relation\022N\n\006object\030\003 \001(\tB6\222A"
  "\033J\026\"document:2021-budget\"x\200\002\372B\025r\0232\016^[^\\s"
  "]{2,256}$\320\001\001R\006object\"\303\002\n\014ReadResponse\022.\n"
  "\006tuples\030\001 \003(\0132\021.openfga.v1.TupleB\003\340A\002R\006t"
  "uples\022\202\002\n\022continuation_token\030\002 \001(\tB\321\001\222A\247"
  "\0012AThe continuation token will be empty "
  "if there are no more tuples.Jb\"eyJwayI6I"
  "kxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic"
  "2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0c"
  "WgifQ==\"\340A\002\372B r\036(\200(2\031^$|^[A-Za-z0-9-_]+="
  "{0,2}$R\022continuation_token\"\203\003\n\022WriteRequ"
  "estWrites\022G\n\ntuple_keys\030\001 \003(\0132\024.openfga."
  "v1.TupleKeyB\021\222A\003\250\001\001\340A\002\372B\005\222\001\002\010\001R\ntuple_ke"
  "ys\022\243\002\n\014on_duplicate\030\002 \001(\tB\376\001\222A\367\0012\322\001On \'e"
  "rror\' ( or unspecified ), the API return"
  "s an error if an identical tuple already"
  " exists. On \'ignore\', identical writes a"
  "re treated as no-ops (matching on user, "
  "relation, object, and RelationshipCondit"
  "ion).:\005errorJ\010\"ignore\"\362\002\005error\362\002\006ignore\340"
  "A\001R\014on_duplicate\"\320\002\n\023WriteRequestDeletes"
  "\022W\n\ntuple_keys\030\001 \003(\0132$.openfga.v1.TupleK"
  "eyWithoutConditionB\021\222A\003\250\001\001\340A\002\372B\005\222\001\002\010\001R\nt"
  "uple_keys\022\337\001\n\non_missing\030\002 \001(\tB\276\001\222A\267\0012\222\001"
  "On \'error\', the API returns an error whe"
  "n deleting a tuple that does not exist. "
  "On \'ignore\', deletes of non-existent tup"
  "les are treated as no-ops.:\005errorJ\010\"igno"
  "re\"\362\002\005error\362\002\006ignore\340A\001R\non_missing\"\362\002\n\014"
  "WriteRequest\022h\n\010store_id\030\001 \001(\tBL\222A\036J\034\"01"
  "YCP46JKYM8FJCQ37NMBYHE5X\"\340A\002\372B%r#2!^[ABC"
  "DEFGHJKMNPQRSTVWXYZ0-9]{26}$R\010store_id\0226"
  "\n\006writes\030\002 \001(\0132\036.openfga.v1.WriteRequest"
  "WritesR\006writes\0229\n\007deletes\030\003 \001(\0132\037.openfg"
  "a.v1.WriteRequestDeletesR\007deletes\022\204\001\n\026au"
  "thorization_model_id\030\004 \001(\tBL\222A\036J\034\"01G5JA"
  "VJ41T49E9TT3SKVS7X1J\"\372B(r&2!^[ABCDEFGHJK"
  "MNPQRSTVWXYZ0-9]{26}$\320\001\001R\026authorization_"
  "model_id\"\017\n\rWriteResponse\"\301\004\n\014CheckReque"
  "st\022h\n\010store_id\030\001 \001(\tBL\222A\036J\034\"01YCP46JKYM8"
  "FJCQ37NMBYHE5X\"\340A\002\372B%r#2!^[ABCDEFGHJKMNP"
  "QRSTVWXYZ0-9]{26}$R\010store_id\022K\n\ttuple_ke"
  "y\030\002 \001(\0132 .openfga.v1.CheckRequestTupleKe"
  "yB\013\340A\002\372B\005\212\001\002\020\001R\ttuple_key\022M\n\021contextual_"
  "tuples\030\003 \001(\0132\037.openfga.v1.ContextualTupl"
  "eKeysR\021contextual_tuples\022\204\001\n\026authorizati"
  "on_model_id\030\004 \001(\tBL\222A\036J\034\"01G5JAVJ41T49E9"
  "TT3SKVS7X1J\"\372B(r&2!^[ABCDEFGHJKMNPQRSTVW"
  "XYZ0-9]{26}$\320\001\001R\026authorization_model_id\022"
  "\"\n\005trace\030\005 \001(\010B\014\222A\t@\001J\005falseR\005trace\0221\n\007c"
  "ontext\030\006 \001(\0132\027.google.protobuf.StructR\007c"
  "ontext\022M\n\013consistency\030\007 \001(\0162!.openfga.v1"
  ".ConsistencyPreferenceB\010\372B\005\202\001\002\020\001R\013consis"
  "tency\"\356\001\n\024CheckRequestTupleKey\022\?\n\004user\030\001"
  " \001(\tB+\222A\020J\013\"user:anne\"x\200\004\340A\002\372B\022r\0202\016^[^\\s"
  "]{2,512}$R\004user\022E\n\010relation\030\002 \001(\tB)\222A\014J\010"
  "\"reader\"x2\340A\002\372B\024r\0222\020^[^:#@\\s]{1,50}$R\010re"
  "lation\022N\n\006object\030\003 \001(\tB6\222A\033J\026\"document:2"
  "021-budget\"x\200\002\340A\002\372B\022r\0202\016^[^\\s]{2,256}$R\006"
  "object\"T\n\rCheckResponse\022#\n\007allowed\030\001 \001(\010"
  "B\t\222A\006J\004trueR\007allowed\022\036\n\nresolution\030\002 \001(\t"
  "R\nresolution\"\232\003\n\021BatchCheckRequest\022h\n\010st"
  "ore_id\030\001 \001(\tBL\222A\036J\034\"01YCP46JKYM8FJCQ37NM"
  "BYHE5X\"\340A\002\372B%r#2!^[ABCDEFGHJKMNPQRSTVWXY"
  "Z0-9]{26}$R\010store_id\022E\n\006checks\030\002 \003(\0132\032.o"
  "penfga.v1.BatchCheckItemB\021\222A\003\250\001\001\340A\002\372B\005\222\001"
  "\002\010\001R\006checks\022\204\001\n\026authorization_model_id\030\003"
  " \001(\tBL\222A\036J\034\"01G5JAVJ41T49E9TT3SKVS7X1J\"\372"
  "B(r&2!^[ABCDEFGHJKMNPQRSTVWXYZ0-9]{26}$\320"
  "\001\001R\026authorization_model_id\022M\n\013consistenc"
  "y\030\004 \001(\0162!.openfga.v1.ConsistencyPreferen"
  "ceB\010\372B\005\202\001\002\020\001R\013consistency\"\276\003\n\016BatchCheck"
  "Item\022K\n\ttuple_key\030\001 \001(\0132 .openfga.v1.Che"
  "ckRequestTupleKeyB\013\340A\002\372B\005\212\001\002\020\001R\ttuple_ke"
  "y\022M\n\021contextual_tuples\030\002 \001(\0132\037.openfga.v"
  "1.ContextualTupleKeysR\021contextual_tuples"
  "\0221\n\007context\030\003 \001(\0132\027.google.protobuf.Stru"
  "ctR\007context\022\334\001\n\016correlation_id\030\004 \001(\tB\263\001\222"
  "A\226\0012lcorrelation_id must be a string con"
  "taining only letters, numbers, or hyphen"
  "s, with length \342\211\244 36 characters.J&\"1cd9"
  "3d8c-8e45-43c6-9a15-cbb3c7f394bc\"\340A\002\372B\023r"
  "\0212\017^[\\w\\d-]{1,36}$R\016correlation_id\"\346\002\n\022B"
  "atchCheckResponse\022\360\001\n\006result\030\001 \003(\0132*.ope"
  "nfga.v1.BatchCheckResponse.ResultEntryB\253"
  "\001\222A\247\0012Nmap keys are the correlation_id v"
  "alues from the BatchCheckItems in the re"
  "questJU{\"1cd93d8c-8e45-43c6-9a15-cbb3c7f"
  "394bc\": {\"allowed\": true, \"error\": {\"mes"
  "sage\": \"\"}}}R\006result\032]\n\013ResultEntry\022\020\n\003k"
  "ey\030\001 \001(\tR\003key\0228\n\005value\030\002 \001(\0132\".openfga.v"
  "1.BatchCheckSingleResultR\005value:\0028\001\"t\n\026B"
  "atchCheckSingleResult\022\032\n\007allowed\030\001 \001(\010H\000"
  "R\007allowed\022.\n\005error\030\002 \001(\0132\026.openfga.v1.Ch"
  "eckErrorH\000R\005errorB\016\n\014check_result\"\262\001\n\nCh"
  "eckError\0229\n\013input_error\030\001 \001(\0162\025.openfga."
  "v1.ErrorCodeH\000R\013input_error\022G\n\016internal_"
  "error\030\002 \001(\0162\035.openfga.v1.InternalErrorCo"
  "deH\000R\016internal_error\022\030\n\007message\030\003 \001(\tR\007m"
  "essageB\006\n\004code\"\354\003\n\rExpandRequest\022h\n\010stor"
  "e_id\030\001 \001(\tBL\222A\036J\034\"01YCP46JKYM8FJCQ37NMBY"
  "HE5X\"\340A\002\372B%r#2!^[ABCDEFGHJKMNPQRSTVWXYZ0"
  "-9]{26}$R\010store_id\022L\n\ttuple_key\030\002 \001(\0132!."
  "openfga.v1.ExpandRequestTupleKeyB\013\340A\002\372B\005"
  "\212\001\002\020\001R\ttuple_key\022\204\001\n\026authorization_model"
  "_id\030\003 \001(\tBL\222A\036J\034\"01G5JAVJ41T49E9TT3SKVS7"
  "X1J\"\372B(r&2!^[ABCDEFGHJKMNPQRSTVWXYZ0-9]{"
  "26}$\320\001\001R\026authorization_model_id\022M\n\013consi"
  "stency\030\004 \001(\0162!.openfga.v1.ConsistencyPre"
  "ferenceB\010\372B\005\202\001\002\020\001R\013consistency\022M\n\021contex"
  "tual_tuples\030\005 \001(\0132\037.openfga.v1.Contextua"
  "lTupleKeysR\021contextual_tuples\"\264\001\n\025Expand"
  "RequestTupleKey\022H\n\010relation\030\001 \001(\tB,\222A\014J\010"
  "\"reader\"x2\340A\002\372B\027r\0252\020^[^:#@\\s]{1,50}$\320\001\001R"
  "\010relation\022Q\n\006object\030\002 \001(\tB9\222A\033J\026\"documen"
  "t:2021-budget\"x\200\002\340A\002\372B\025r\0232\016^[^\\s]{2,256}"
  "$\320\001\001R\006object\"=\n\016ExpandResponse\022+\n\004tree\030\001"
  " \001(\0132\027.openfga.v1.UsersetTreeR\004tree\"\347\001\n\035"
  "ReadAuthorizationModelRequest\022h\n\010store_i"
  "d\030\001 \001(\tBL\222A\036J\034\"01YCP46JKYM8FJCQ37NMBYHE5"
  "X\"\340A\002\372B%r#2!^[ABCDEFGHJKMNPQRSTVWXYZ0-9]"
  "{26}$R\010store_id\022\\\n\002id\030\002 \001(\tBL\222A\036J\034\"01G5J"
  "AVJ41T49E9TT3SKVS7X1J\"\340A\002\372B%r#2!^[ABCDEF"
  "GHJKMNPQRSTVWXYZ0-9]{26}$R\002id\"r\n\036ReadAut"
  "horizationModelResponse\022P\n\023authorization"
  "_model\030\001 \001(\0132\036.openfga.v1.AuthorizationM"
  "odelR\023authorization_model\"\373\003\n\036WriteAutho"
  "rizationModelRequest\022h\n\010store_id\030\001 \001(\tBL"
  "\222A\036J\034\"01YCP46JKYM8FJCQ37NMBYHE5X\"\340A\002\372B%r"
  "#2!^[ABCDEFGHJKMNPQRSTVWXYZ0-9]{26}$R\010st"
  "ore_id\022Y\n\020type_definitions\030\002 \003(\0132\032.openf"
  "ga.v1.TypeDefinitionB\021\222A\003\250\001\001\340A\002\372B\005\222\001\002\010\001R"
  "\020type_definitions\022B\n\016schema_version\030\003 \001("
  "\tB\032\340A\002\372B\024r\022R\0031.0R\0031.1R\0031.2\320\001\000R\016schema_ve"
  "rsion\022z\n\nconditions\030\004 \003(\0132:.openfga.v1.W"
  "riteAuthorizationModelRequest.Conditions"
  "EntryB\036\372B\033\232\001\030\020\031\"\024r\0222\020^[^:#@\\s]{1,50}$R\nc"
  "onditions\032T\n\017ConditionsEntry\022\020\n\003key\030\001 \001("
  "\tR\003key\022+\n\005value\030\002 \001(\0132\025.openfga.v1.Condi"
  "tionR\005value:\0028\001\"\250\001\n\037WriteAuthorizationMo"
  "delResponse\022\204\001\n\026authorization_model_id\030\001"
  " \001(\tBL\222A\036J\034\"01G5JAVJ41T49E9TT3SKVS7X1J\"\340"
  "A\002\372B%r#2!^[ABCDEFGHJKMNPQRSTVWXYZ0-9]{26"
  "}$R\026authorization_model_id\"\225\003\n\036ReadAutho"
  "rizationModelsRequest\022h\n\010store_id\030\001 \001(\tB"
  "L\222A\036J\034\"01YCP46JKYM8FJCQ37NMBYHE5X\"\340A\002\372B%"
  "r#2!^[ABCDEFGHJKMNPQRSTVWXYZ0-9]{26}$R\010s"
  "tore_id\022K\n\tpage_size\030\002 \001(\0132\033.google.prot"
  "obuf.Int32ValueB\020\222A\004J\00250\372B\006\032\004\030d(\001R\tpage_"
  "size\022\273\001\n\022continuation_token\030\003 \001(\tB\212\001\222AdJ"
  "b\"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMH"
  "N0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN0"
  "1MdTdqTjh0cWgifQ==\"\372B r\036(\200(2\031^$|^[A-Za-z"
  "0-9-_]+={0,2}$R\022continuation_token\"\374\002\n\037R"
  "eadAuthorizationModelsResponse\022W\n\024author"
  "ization_models\030\001 \003(\0132\036.openfga.v1.Author"
  "izationModelB\003\340A\002R\024authorization_models\022"
  "\377\001\n\022continuation_token\030\002 \001(\tB\316\001\222A\247\0012AThe"
  " continuation token will be empty if the"
  "re are no more models.Jb\"eyJwayI6IkxBVEV"
  "TVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiI"
  "xem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ="
  "=\"\372B r\036(\200(2\031^$|^[A-Za-z0-9-_]+={0,2}$R\022c"
  "ontinuation_token\"\325\002\n\026WriteAssertionsReq"
  "uest\022h\n\010store_id\030\001 \001(\tBL\222A\036J\034\"01YCP46JKY"
  "M8FJCQ37NMBYHE5X\"\340A\002\372B%r#2!^[ABCDEFGHJKM"
  "NPQRSTVWXYZ0-9]{26}$R\010store_id\022\204\001\n\026autho"
  "rization_model_id\030\002 \001(\tBL\222A\036J\034\"01G5JAVJ4"
  "1T49E9TT3SKVS7X1J\"\340A\002\372B%r#2!^[ABCDEFGHJK"
  "MNPQRSTVWXYZ0-9]{26}$R\026authorization_mod"
  "el_id\022J\n\nassertions\030\003 \003(\0132\025.openfga.v1.A"
  "ssertionB\023\222A\003\240\001d\340A\002\372B\007\222\001\004\010\000\020dR\nassertion"
  "s\"\031\n\027WriteAssertionsResponse\"\210\002\n\025ReadAss"
  "ertionsRequest\022h\n\010store_id\030\001 \001(\tBL\222A\036J\034\""
  "01YCP46JKYM8FJCQ37NMBYHE5X\"\340A\002\372B%r#2!^[A"
  "BCDEFGHJKMNPQRSTVWXYZ0-9]{26}$R\010store_id"
  "\022\204\001\n\026authorization_model_id\030\002 \001(\tBL\222A\036J\034"
  "\"01G5JAVJ41T49E9TT3SKVS7X1J\"\340A\002\372B%r#2!^["
  "ABCDEFGHJKMNPQRSTVWXYZ0-9]{26}$R\026authori"
  "zation_model_id\"\326\001\n\026ReadAssertionsRespon"
  "se\022\204\001\n\026authorization_model_id\030\001 \001(\tBL\222A\036"
  "J\034\"01G5JAVJ41T49E9TT3SKVS7X1J\"\340A\002\372B%r#2!"
  "^[ABCDEFGHJKMNPQRSTVWXYZ0-9]{26}$R\026autho"
  "rization_model_id\0225\n\nassertions\030\002 \003(\0132\025."
  "openfga.v1.AssertionR\nassertions\"\371\005\n\022Rea"
  "dChangesRequest\022h\n\010store_id\030\001 \001(\tBL\222A\036J\034"
  "\"01YCP46JKYM8FJCQ37NMBYHE5X\"\340A\002\372B%r#2!^["
  "ABCDEFGHJKMNPQRSTVWXYZ0-9]{26}$R\010store_i"
  "d\022.\n\004type\030\002 \001(\tB\032\372B\027r\0252\020^[^:#\\s]{1,254}$"
  "\320\001\001R\004type\022K\n\tpage_size\030\003 \001(\0132\033.google.pr"
  "otobuf.Int32ValueB\020\222A\004J\00250\372B\006\032\004\030d(\001R\tpag"
  "e_size\022\273\001\n\022continuation_token\030\004 \001(\tB\212\001\222A"
  "dJb\"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRo"
  "MHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoy"
  "N01MdTdqTjh0cWgifQ==\"\372B r\036(\200(2\031^$|^[A-Za"
  "-z0-9-_]+={0,2}$R\022continuation_token\022\275\002\n"
  "\nstart_time\030\005 \001(\0132\032.google.protobuf.Time"
  "stampB\200\002\222A\364\0012\327\001Start date and time of ch"
  "anges to read.\nFormat: ISO 8601 timestam"
  "p (e.g., 2022-01-01T00:00:00Z)\nIf a cont"
  "inuation_token is provided along side st"
  "art_time, the continuation_token will ta"
  "ke precedence over start_time.J\0302021-01-"
  "01T00:00:00.000Z\372B\005\262\001\0028\001R\nstart_time\"\323\002\n"
  "\023ReadChangesResponse\0226\n\007changes\030\001 \003(\0132\027."
  "openfga.v1.TupleChangeB\003\340A\002R\007changes\022\203\002\n"
  "\022continuation_token\030\002 \001(\tB\322\001\222A\253\0012EThe co"
  "ntinuation token will be identical if th"
  "ere are no new changes.Jb\"eyJwayI6IkxBVE"
  "VTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOi"
  "Ixem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ"
  "==\"\372B r\036(\200(2\031^$|^[A-Za-z0-9-_]+={0,2}$R\022"
  "continuation_token\"g\n\022CreateStoreRequest"
  "\022Q\n\004name\030\001 \001(\tB=\222A\021J\017\"my-store-name\"\340A\002\372"
  "B#r!2\037^[a-zA-Z0-9\\s\\.\\-\\/^_&@]{3,64}$R\004n"
  "ame\"\346\001\n\023CreateStoreResponse\0224\n\002id\030\001 \001(\tB"
  "$\222A\036J\034\"01YCP46JKYM8FJCQ37NMBYHE5X\"\340A\002R\002i"
  "d\022\027\n\004name\030\002 \001(\tB\003\340A\002R\004name\022\?\n\ncreated_at"
  "\030\003 \001(\0132\032.google.protobuf.TimestampB\003\340A\002R"
  "\ncreated_at\022\?\n\nupdated_at\030\004 \001(\0132\032.google"
  ".protobuf.TimestampB\003\340A\002R\nupdated_at\"\325\001\n"
  "\022UpdateStoreRequest\022h\n\010store_id\030\001 \001(\tBL\222"
  "A\036J\034\"01YCP46JKYM8FJCQ37NMBYHE5X\"\340A\002\372B%r#"
  "2!^[ABCDEFGHJKMNPQRSTVWXYZ0-9]{26}$R\010sto"
  "re_id\022U\n\004name\030\002 \001(\tBA\222A\025J\023\"my-new-store-"
  "name\"\340A\002\372B#r!2\037^[a-zA-Z0-9\\s\\.\\-\\/^_&@]{"
  "3,64}$R\004name\"\346\001\n\023UpdateStoreResponse\0224\n\002"
  "id\030\001 \001(\tB$\222A\036J\034\"01YCP46JKYM8FJCQ37NMBYHE"
  "5X\"\340A\002R\002id\022\027\n\004name\030\002 \001(\tB\003\340A\002R\004name\022\?\n\nc"
  "reated_at\030\003 \001(\0132\032.google.protobuf.Timest"
  "ampB\003\340A\002R\ncreated_at\022\?\n\nupdated_at\030\004 \001(\013"
  "2\032.google.protobuf.TimestampB\003\340A\002R\nupdat"
  "ed_at\"~\n\022DeleteStoreRequest\022h\n\010store_id\030"
  "\001 \001(\tBL\222A\036J\034\"01YCP46JKYM8FJCQ37NMBYHE5X\""
  "\340A\002\372B%r#2!^[ABCDEFGHJKMNPQRSTVWXYZ0-9]{2"
  "6}$R\010store_id\"\025\n\023DeleteStoreResponse\"{\n\017"
  "GetStoreRequest\022h\n\010store_id\030\001 \001(\tBL\222A\036J\034"
  "\"01YCP46JKYM8FJCQ37NMBYHE5X\"\340A\002\372B%r#2!^["
  "ABCDEFGHJKMNPQRSTVWXYZ0-9]{26}$R\010store_i"
  "d\"\237\002\n\020GetStoreResponse\0224\n\002id\030\001 \001(\tB$\222A\036J"
  "\034\"01YCP46JKYM8FJCQ37NMBYHE5X\"\340A\002R\002id\022\027\n\004"
  "name\030\002 \001(\tB\003\340A\002R\004name\022\?\n\ncreated_at\030\003 \001("
  "\0132\032.google.protobuf.TimestampB\003\340A\002R\ncrea"
  "ted_at\022\?\n\nupdated_at\030\004 \001(\0132\032.google.prot"
  "obuf.TimestampB\003\340A\002R\nupdated_at\022:\n\ndelet"
  "ed_at\030\005 \001(\0132\032.google.protobuf.TimestampR"
  "\ndeleted_at\"\302\004\n\021ListStoresRequest\022D\n\tpag"
  "e_size\030\001 \001(\0132\033.google.protobuf.Int32Valu"
  "eB\t\372B\006\032\004\030d(\001R\tpage_size\022\276\001\n\022continuation"
  "_token\030\002 \001(\tB\215\001\222AdJb\"eyJwayI6IkxBVEVTVF9"
  "OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1"
  "qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\"\372B"
  "#r!(\200(2\034^$|^$|^[A-Za-z0-9-_]+={0,2}$R\022co"
  "ntinuation_token\022\245\002\n\004name\030\003 \001(\tB\220\002\222A\340\0012\314"
  "\001The name parameter instructs the API to"
  " only include results that match that na"
  "me.Multiple results may be returned. Onl"
  "y exact matches will be returned; substr"
  "ing matches and regexes will not be eval"
  "uatedJ\017\"my-store-name\"\340A\001\372B&r$2\037^[a-zA-Z"
  "0-9\\s\\.\\-\\/^_&@]{3,64}$\320\001\001R\004name\"\311\002\n\022Lis"
  "tStoresResponse\022.\n\006stores\030\001 \003(\0132\021.openfg"
  "a.v1.StoreB\003\340A\002R\006stores\022\202\002\n\022continuation"
  "_token\030\002 \001(\tB\321\001\222A\247\0012AThe continuation to"
  "ken will be empty if there are no more s"
  "tores.Jb\"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19"
  "hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZEx"
  "TcUoyN01MdTdqTjh0cWgifQ==\"\340A\002\372B r\036(\200(2\031^"
  "$|^[A-Za-z0-9-_]+={0,2}$R\022continuation_t"
  "oken\"\353\001\n\021AssertionTupleKey\022N\n\006object\030\001 \001"
  "(\tB6\222A\033J\026\"document:2021-budget\"x\200\002\340A\002\372B\022"
  "r\0202\016^[^\\s]{2,256}$R\006object\022E\n\010relation\030\002"
  " \001(\tB)\222A\014J\010\"reader\"x2\340A\002\372B\024r\0222\020^[^:#@\\s]"
  "{1,50}$R\010relation\022\?\n\004user\030\003 \001(\tB+\222A\020J\013\"u"
  "ser:anne\"x\200\004\340A\002\372B\022r\0202\016^[^\\s]{2,512}$R\004us"
  "er\"\235\002\n\tAssertion\022H\n\ttuple_key\030\001 \001(\0132\035.op"
  "enfga.v1.AssertionTupleKeyB\013\340A\002\372B\005\212\001\002\020\001R"
  "\ttuple_key\022%\n\013expectation\030\002 \001(\010B\003\340A\002R\013ex"
  "pectation\022R\n\021contextual_tuples\030\003 \003(\0132\024.o"
  "penfga.v1.TupleKeyB\016\222A\003\240\001\024\372B\005\222\001\002\020\024R\021cont"
  "extual_tuples\022K\n\007context\030\004 \001(\0132\027.google."
  "protobuf.StructB\030\222A\025J\023{\"view_count\": 100"
  "}R\007context\"H\n\nAssertions\022:\n\nassertions\030\001"
  " \003(\0132\025.openfga.v1.AssertionB\003\340A\002R\nassert"
  "ions2\356\360\001\n\016OpenFGAService\022\320\035\n\004Read\022\027.open"
  "fga.v1.ReadRequest\032\030.openfga.v1.ReadResp"
  "onse\"\224\035\222A\356\034\n\023Relationship Tuples\022WGet tu"
  "ples from the store that matches a query"
  ", without following userset rewrite rule"
  "s\032\367\033The Read API will return the tuples "
  "for a certain store that match a query f"
  "ilter specified in the body of the reque"
  "st. \nThe API doesn\'t guarantee order by "
  "any field. \nIt is different from the `/s"
  "tores/{store_id}/expand` API in that it "
  "only returns relationship tuples that ar"
  "e stored in the system and satisfy the q"
  "uery. \nIn the body:\n1. `tuple_key` is op"
  "tional. If not specified, it will return"
  " all tuples in the store.\n2. `tuple_key."
  "object` is mandatory if `tuple_key` is s"
  "pecified. It can be a full object (e.g.,"
  " `type:object_id`) or type only (e.g., `"
  "type:`).\n3. `tuple_key.user` is mandator"
  "y if tuple_key is specified in the case "
  "the `tuple_key.object` is a type only. I"
  "f tuple_key.user is specified, it needs "
  "to be a full object (e.g., `type:user_id"
  "`).\n## Examples\n### Query for all object"
  "s in a type definition\nTo query for all "
  "objects that `user:bob` has `reader` rel"
  "ationship in the `document` type definit"
  "ion, call read API with body of\n```json\n"
  "{\n \"tuple_key\": {\n     \"user\": \"user:bob"
  "\",\n     \"relation\": \"reader\",\n     \"obje"
  "ct\": \"document:\"\n  }\n}\n```\nThe API will "
  "return tuples and a continuation token, "
  "something like\n```json\n{\n  \"tuples\": [\n "
  "   {\n      \"key\": {\n        \"user\": \"use"
  "r:bob\",\n        \"relation\": \"reader\",\n  "
  "      \"object\": \"document:2021-budget\"\n "
  "     },\n      \"timestamp\": \"2021-10-06T1"
  "5:32:11.128Z\"\n    }\n  ],\n  \"continuation"
  "_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR1"
  "9hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZE"
  "xTcUoyN01MdTdqTjh0cWgifQ==\"\n}\n```\nThis m"
  "eans that `user:bob` has a `reader` rela"
  "tionship with 1 document `document:2021-"
  "budget`. Note that this API, unlike the "
  "List Objects API, does not evaluate the "
  "tuples in the store.\nThe continuation to"
  "ken will be empty if there are no more t"
  "uples to query.\n### Query for all stored"
  " relationship tuples that have a particu"
  "lar relation and object\nTo query for all"
  " users that have `reader` relationship w"
  "ith `document:2021-budget`, call read AP"
  "I with body of \n```json\n{\n  \"tuple_key\":"
  " {\n     \"object\": \"document:2021-budget\""
  ",\n     \"relation\": \"reader\"\n   }\n}\n```\nT"
  "he API will return something like \n```js"
  "on\n{\n  \"tuples\": [\n    {\n      \"key\": {\n"
  "        \"user\": \"user:bob\",\n        \"rel"
  "ation\": \"reader\",\n        \"object\": \"doc"
  "ument:2021-budget\"\n      },\n      \"times"
  "tamp\": \"2021-10-06T15:32:11.128Z\"\n    }\n"
  "  ],\n  \"continuation_token\": \"eyJwayI6Ik"
  "xBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2"
  "siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cW"
  "gifQ==\"\n}\n```\nThis means that `document:"
  "2021-budget` has 1 `reader` (`user:bob`)"
  ".  Note that, even if the model said tha"
  "t all `writers` are also `readers`, the "
  "API will not return writers such as `use"
  "r:anne` because it only returns tuples a"
  "nd does not evaluate them.\n### Query for"
  " all users with all relationships for a "
  "particular document\nTo query for all use"
  "rs that have any relationship with `docu"
  "ment:2021-budget`, call read API with bo"
  "dy of \n```json\n{\n  \"tuple_key\": {\n      "
  "\"object\": \"document:2021-budget\"\n   }\n}\n"
  "```\nThe API will return something like \n"
  "```json\n{\n  \"tuples\": [\n    {\n      \"key"
  "\": {\n        \"user\": \"user:anne\",\n      "
  "  \"relation\": \"writer\",\n        \"object\""
  ": \"document:2021-budget\"\n      },\n      "
  "\"timestamp\": \"2021-10-05T13:42:12.356Z\"\n"
  "    },\n    {\n      \"key\": {\n        \"use"
  "r\": \"user:bob\",\n        \"relation\": \"rea"
  "der\",\n        \"object\": \"document:2021-b"
  "udget\"\n      },\n      \"timestamp\": \"2021"
  "-10-06T15:32:11.128Z\"\n    }\n  ],\n  \"cont"
  "inuation_token\": \"eyJwayI6IkxBVEVTVF9OU0"
  "NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbX"
  "F3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\"\n}\n``"
  "`\nThis means that `document:2021-budget`"
  " has 1 `reader` (`user:bob`) and 1 `writ"
  "er` (`user:anne`).\n*\004Read\202\323\344\223\002\034:\001*\"\027/sto"
  "res/{store_id}/read\022\314\022\n\005Write\022\030.openfga."
  "v1.WriteRequest\032\031.openfga.v1.WriteRespon"
  "se\"\215\022\222A\346\021\n\023Relationship Tuples\022#Add or d"
  "elete tuples from the store\032\242\021The Write "
  "API will transactionally update the tupl"
  "es for a certain store. Tuples and type "
  "definitions allow OpenFGA to determine w"
  "hether a relationship exists between an "
  "object and an user.\nIn the body, `writes"
  "` adds new tuples and `deletes` removes "
  "existing tuples. When deleting a tuple, "
  "any `condition` specified with it is ign"
  "ored.\nThe API is not idempotent by defau"
  "lt: if, later on, you try to add the sam"
  "e tuple key (even if the `condition` is "
  "different), or if you try to delete a no"
  "n-existing tuple, it will throw an error"
  ".\nTo allow writes when an identical tupl"
  "e already exists in the database, set `\""
  "on_duplicate\": \"ignore\"` on the `writes`"
  " object.\nTo allow deletes when a tuple w"
  "as already removed from the database, se"
  "t `\"on_missing\": \"ignore\"` on the `delet"
  "es` object.\nIf a Write request contains "
  "both idempotent (ignore) and non-idempot"
  "ent (error) operations, the most restric"
  "tive action (error) will take precedence"
  ". If a condition fails for a sub-request"
  " with an error flag, the entire transact"
  "ion will be rolled back. This gives deve"
  "lopers explicit control over the atomici"
  "ty of the requests.\nThe API will not all"
  "ow you to write tuples such as `document"
  ":2021-budget#viewer@document:2021-budget"
  "#viewer`, because they are implicit.\nAn "
  "`authorization_model_id` may be specifie"
  "d in the body. If it is, it will be used"
  " to assert that each written tuple (not "
  "deleted) is valid for the model specifie"
  "d. If it is not specified, the latest au"
  "thorization model ID will be used.\n## Ex"
  "ample\n### Adding relationships\nTo add `u"
  "ser:anne` as a `writer` for `document:20"
  "21-budget`, call write API with the foll"
  "owing \n```json\n{\n  \"writes\": {\n    \"tupl"
  "e_keys\": [\n      {\n        \"user\": \"user"
  ":anne\",\n        \"relation\": \"writer\",\n  "
  "      \"object\": \"document:2021-budget\"\n "
  "     }\n    ],\n    \"on_duplicate\": \"ignor"
  "e\"\n  },\n  \"authorization_model_id\": \"01G"
  "50QVV17PECNVAHX1GG4Y5NC\"\n}\n```\n### Remov"
  "ing relationships\nTo remove `user:bob` a"
  "s a `reader` for `document:2021-budget`,"
  " call write API with the following \n```j"
  "son\n{\n  \"deletes\": {\n    \"tuple_keys\": ["
  "\n      {\n        \"user\": \"user:bob\",\n   "
  "     \"relation\": \"reader\",\n        \"obje"
  "ct\": \"document:2021-budget\"\n      }\n    "
  "],\n    \"on_missing\": \"ignore\"\n  }\n}\n```\n"
  "*\005Write\202\323\344\223\002\035:\001*\"\030/stores/{store_id}/wri"
  "te\022\332*\n\005Check\022\030.openfga.v1.CheckRequest\032\031"
  ".openfga.v1.CheckResponse\"\233*\222A\364)\n\024Relati"
  "onship Queries\0226Check whether a user is "
  "authorized to access an object\032\234)The Che"
  "ck API returns whether a given user has "
  "a relationship with a given object in a "
  "given store.\nThe `user` field of the req"
  "uest can be a specific target, such as `"
  "user:anne`, or a userset (set of users) "
  "such as `group:marketing#member` or a ty"
  "pe-bound public access `user:*`.\nTo arri"
  "ve at a result, the API uses: an authori"
  "zation model, explicit tuples written th"
  "rough the Write API, contextual tuples p"
  "resent in the request, and implicit tupl"
  "es that exist by virtue of applying set "
  "theory (such as `document:2021-budget#vi"
  "ewer@document:2021-budget#viewer`; the s"
  "et of users who are viewers of `document"
  ":2021-budget` are the set of users who a"
  "re the viewers of `document:2021-budget`"
  ").\nA `contextual_tuples` object may also"
  " be included in the body of the request."
  " This object contains one field `tuple_k"
  "eys`, which is an array of tuple keys. E"
  "ach of these tuples may have an associat"
  "ed `condition`.\nYou may also provide an "
  "`authorization_model_id` in the body. Th"
  "is will be used to assert that the input"
  " `tuple_key` is valid for the model spec"
  "ified. If not specified, the assertion w"
  "ill be made against the latest authoriza"
  "tion model ID. It is strongly recommende"
  "d to specify authorization model id for "
  "better performance.\nYou may also provide"
  " a `context` object that will be used to"
  " evaluate the conditioned tuples in the "
  "system. It is strongly recommended to pr"
  "ovide a value for all the input paramete"
  "rs of all the conditions, to ensure that"
  " all tuples be evaluated correctly.\nBy d"
  "efault, the Check API caches results for"
  " a short time to optimize performance. Y"
  "ou may specify a value of `HIGHER_CONSIS"
  "TENCY` for the optional `consistency` pa"
  "rameter in the body to inform the server"
  " that higher conisistency is preferred a"
  "t the expense of increased latency. Cons"
  "ideration should be given to the increas"
  "ed latency if requesting higher consiste"
  "ncy.\nThe response will return whether th"
  "e relationship exists in the field `allo"
  "wed`.\n\nSome exceptions apply, but in gen"
  "eral, if a Check API responds with `{all"
  "owed: true}`, then you can expect the eq"
  "uivalent ListObjects query to return the"
  " object, and viceversa. \nFor example, if"
  " `Check(user:anne, reader, document:2021"
  "-budget)` responds with `{allowed: true}"
  "`, then `ListObjects(user:anne, reader, "
  "document)` may include `document:2021-bu"
  "dget` in the response.\n## Examples\n### Q"
  "uerying with contextual tuples\nIn order "
  "to check if user `user:anne` of type `us"
  "er` has a `reader` relationship with obj"
  "ect `document:2021-budget` given the fol"
  "lowing contextual tuple\n```json\n{\n  \"use"
  "r\": \"user:anne\",\n  \"relation\": \"member\","
  "\n  \"object\": \"time_slot:office_hours\"\n}\n"
  "```\nthe Check API can be used with the f"
  "ollowing request body:\n```json\n{\n  \"tupl"
  "e_key\": {\n    \"user\": \"user:anne\",\n    \""
  "relation\": \"reader\",\n    \"object\": \"docu"
  "ment:2021-budget\"\n  },\n  \"contextual_tup"
  "les\": {\n    \"tuple_keys\": [\n      {\n    "
  "    \"user\": \"user:anne\",\n        \"relati"
  "on\": \"member\",\n        \"object\": \"time_s"
  "lot:office_hours\"\n      }\n    ]\n  },\n  \""
  "authorization_model_id\": \"01G50QVV17PECN"
  "VAHX1GG4Y5NC\"\n}\n```\n### Querying userset"
  "s\nSome Checks will always return `true`,"
  " even without any tuples. For example, f"
  "or the following authorization model\n```"
  "python\nmodel\n  schema 1.1\ntype user\ntype"
  " document\n  relations\n    define reader:"
  " [user]\n```\nthe following query\n```json\n"
  "{\n  \"tuple_key\": {\n     \"user\": \"documen"
  "t:2021-budget#reader\",\n     \"relation\": "
  "\"reader\",\n     \"object\": \"document:2021-"
  "budget\"\n  }\n}\n```\nwill always return `{ "
  "\"allowed\": true }`. This is because user"
  "sets are self-defining: the userset `doc"
  "ument:2021-budget#reader` will always ha"
  "ve the `reader` relation with `document:"
  "2021-budget`.\n### Querying usersets with"
  " difference in the model\nA Check for a u"
  "serset can yield results that must be tr"
  "eated carefully if the model involves di"
  "fference. For example, for the following"
  " authorization model\n```python\nmodel\n  s"
  "chema 1.1\ntype user\ntype group\n  relatio"
  "ns\n    define member: [user]\ntype docume"
  "nt\n  relations\n    define blocked: [user"
  "]\n    define reader: [group#member] but "
  "not blocked\n```\nthe following query\n```j"
  "son\n{\n  \"tuple_key\": {\n     \"user\": \"gro"
  "up:finance#member\",\n     \"relation\": \"re"
  "ader\",\n     \"object\": \"document:2021-bud"
  "get\"\n  },\n  \"contextual_tuples\": {\n    \""
  "tuple_keys\": [\n      {\n        \"user\": \""
  "user:anne\",\n        \"relation\": \"member\""
  ",\n        \"object\": \"group:finance\"\n    "
  "  },\n      {\n        \"user\": \"group:fina"
  "nce#member\",\n        \"relation\": \"reader"
  "\",\n        \"object\": \"document:2021-budg"
  "et\"\n      },\n      {\n        \"user\": \"us"
  "er:anne\",\n        \"relation\": \"blocked\","
  "\n        \"object\": \"document:2021-budget"
  "\"\n      }\n    ]\n  },\n}\n```\nwill return `"
  "{ \"allowed\": true }`, even though a spec"
  "ific user of the userset `group:finance#"
  "member` does not have the `reader` relat"
  "ionship with the given object.\n### Reque"
  "sting higher consistency\nBy default, the"
  " Check API caches results for a short ti"
  "me to optimize performance. You may requ"
  "est higher consistency to inform the ser"
  "ver that higher consistency should be pr"
  "eferred at the expense of increased late"
  "ncy. Care should be taken when requestin"
  "g higher consistency due to the increase"
  "d latency.\n```json\n{\n  \"tuple_key\": {\n  "
  "   \"user\": \"group:finance#member\",\n     "
  "\"relation\": \"reader\",\n     \"object\": \"do"
  "cument:2021-budget\"\n  },\n  \"consistency\""
  ": \"HIGHER_CONSISTENCY\"\n}\n```\n*\005Check\202\323\344\223"
  "\002\035:\001*\"\030/stores/{store_id}/check\022\213\023\n\nBatc"
  "hCheck\022\035.openfga.v1.BatchCheckRequest\032\036."
  "openfga.v1.BatchCheckResponse\"\275\022\222A\220\022\n\024Re"
  "lationship Queries\0225Send a list of `chec"
  "k` operations in a single request\032\264\021The "
  "`BatchCheck` API functions nearly identi"
  "cally to `Check`, but instead of checkin"
  "g a single user-object relationship Batc"
  "hCheck accepts a list of relationships t"
  "o check and returns a map containing `Ba"
  "tchCheckItem` response for each check it"
  " received.\n\nAn associated `correlation_i"
  "d` is required for each check in the bat"
  "ch. This ID is used to correlate a check"
  " to the appropriate response. It is a st"
  "ring consisting of only alphanumeric cha"
  "racters or hyphens with a maximum length"
  " of 36 characters. This `correlation_id`"
  " is used to map the result of each check"
  " to the item which was checked, so it mu"
  "st be unique for each item in the batch."
  " We recommend using a UUID or ULID as th"
  "e `correlation_id`, but you can use what"
  "ever unique identifier you need as long "
  " as it matches this regex pattern: `^[\\w"
  "\\d-]{1,36}$`\n\nNOTE: The maximum number o"
  "f checks that can be passed in the `Batc"
  "hCheck` API is configurable via the [OPE"
  "NFGA_MAX_CHECKS_PER_BATCH_CHECK](https:/"
  "/openfga.dev/docs/getting-started/setup-"
  "openfga/configuration#OPENFGA_MAX_CHECKS"
  "_PER_BATCH_CHECK) environment variable. "
  "If `BatchCheck` is called using the SDK,"
  " the SDK can split the batch check reque"
  "sts for you.\n\nFor more details on how `C"
  "heck` functions, see the docs for `/chec"
  "k`.\n\n### Examples\n#### A BatchCheckReque"
  "st\n```json\n{\n  \"checks\": [\n     {\n      "
  " \"tuple_key\": {\n         \"object\": \"docu"
  "ment:2021-budget\"\n         \"relation\": \""
  "reader\",\n         \"user\": \"user:anne\",\n "
  "      },\n       \"contextual_tuples\": {.."
  ".}\n       \"context\": {}\n       \"correlat"
  "ion_id\": \"01JA8PM3QM7VBPGB8KMPK8SBD5\"\n  "
  "   },\n     {\n       \"tuple_key\": {\n     "
  "    \"object\": \"document:2021-budget\"\n   "
  "      \"relation\": \"reader\",\n         \"us"
  "er\": \"user:bob\",\n       },\n       \"conte"
  "xtual_tuples\": {...}\n       \"context\": {"
  "}\n       \"correlation_id\": \"01JA8PMM6A90"
  "NV5ET0F28CYSZQ\"\n     }\n   ]\n}\n```\n\nBelow"
  " is a possible response to the above req"
  "uest. Note that the result map\'s keys ar"
  "e the `correlation_id` values from the c"
  "hecked items in the request:\n```json\n{\n "
  "  \"result\": {\n     \"01JA8PMM6A90NV5ET0F2"
  "8CYSZQ\": {\n       \"allowed\": false, \n   "
  "    \"error\": {\"message\": \"\"} \n    },\n   "
  "  \"01JA8PM3QM7VBPGB8KMPK8SBD5\": {\n      "
  " \"allowed\": true, \n       \"error\": {\"mes"
  "sage\": \"\"} \n    }\n}\n```\n*\nBatchCheck\202\323\344\223"
  "\002#:\001*\"\036/stores/{store_id}/batch-check\022\332\036"
  "\n\006Expand\022\031.openfga.v1.ExpandRequest\032\032.op"
  "enfga.v1.ExpandResponse\"\230\036\222A\360\035\n\024Relation"
  "ship Queries\022\216\001Expand all relationships "
  "in userset tree format, and following us"
  "erset rewrite rules.  Useful to reason a"
  "bout and debug a certain relationship\032\276\034"
  "The Expand API will return all users and"
  " usersets that have certain relationship"
  " with an object in a certain store.\nThis"
  " is different from the `/stores/{store_i"
  "d}/read` API in that both users and comp"
  "uted usersets are returned.\nBody paramet"
  "ers `tuple_key.object` and `tuple_key.re"
  "lation` are all required.\nA `contextual_"
  "tuples` object may also be included in t"
  "he body of the request. This object cont"
  "ains one field `tuple_keys`, which is an"
  " array of tuple keys. Each of these tupl"
  "es may have an associated `condition`.\nT"
  "he response will return a tree whose lea"
  "ves are the specific users and usersets."
  " Union, intersection and difference oper"
  "ator are located in the intermediate nod"
  "es.\n\n## Example\nTo expand all users that"
  " have the `reader` relationship with obj"
  "ect `document:2021-budget`, use the Expa"
  "nd API with the following request body\n`"
  "``json\n{\n  \"tuple_key\": {\n    \"object\": "
  "\"document:2021-budget\",\n    \"relation\": "
  "\"reader\"\n  },\n  \"authorization_model_id\""
  ": \"01G50QVV17PECNVAHX1GG4Y5NC\"\n}\n```\nOpe"
  "nFGA\'s response will be a userset tree o"
  "f the users and usersets that have read "
  "access to the document.\n```json\n{\n  \"tre"
  "e\":{\n    \"root\":{\n      \"type\":\"document"
  ":2021-budget#reader\",\n      \"union\":{\n  "
  "      \"nodes\":[\n          {\n            "
  "\"type\":\"document:2021-budget#reader\",\n  "
  "          \"leaf\":{\n              \"users\""
  ":{\n                \"users\":[\n           "
  "       \"user:bob\"\n                ]\n    "
  "          }\n            }\n          },\n "
  "         {\n            \"type\":\"document:"
  "2021-budget#reader\",\n            \"leaf\":"
  "{\n              \"computed\":{\n           "
  "     \"userset\":\"document:2021-budget#wri"
  "ter\"\n              }\n            }\n     "
  "     }\n        ]\n      }\n    }\n  }\n}\n```"
  "\nThe caller can then call expand API for"
  " the `writer` relationship for the `docu"
  "ment:2021-budget`.\n### Expand Request wi"
  "th Contextual Tuples\n\nGiven the model\n``"
  "`python\nmodel\n    schema 1.1\n\ntype user\n"
  "\ntype folder\n    relations\n        defin"
  "e owner: [user]\n\ntype document\n    relat"
  "ions\n        define parent: [folder]\n   "
  "     define viewer: [user] or writer\n   "
  "     define writer: [user] or owner from"
  " parent\n```\nand the initial tuples\n```js"
  "on\n[{\n    \"user\": \"user:bob\",\n    \"relat"
  "ion\": \"owner\",\n    \"object\": \"folder:1\"\n"
  "}]\n```\n\nTo expand all `writers` of `docu"
  "ment:1` when `document:1` is put in `fol"
  "der:1`, the first call could be\n\n```json"
  "\n{\n  \"tuple_key\": {\n    \"object\": \"docum"
  "ent:1\",\n    \"relation\": \"writer\"\n  },\n  "
  "\"contextual_tuples\": {\n    \"tuple_keys\":"
  " [\n      {\n        \"user\": \"folder:1\",\n "
  "       \"relation\": \"parent\",\n        \"ob"
  "ject\": \"document:1\"\n      }\n    ]\n  }\n}\n"
  "```\nthis returns:\n```json\n{\n  \"tree\": {\n"
  "    \"root\": {\n      \"name\": \"document:1#"
  "writer\",\n      \"union\": {\n        \"nodes"
  "\": [\n          {\n            \"name\": \"do"
  "cument:1#writer\",\n            \"leaf\": {\n"
  "              \"users\": {\n               "
  " \"users\": []\n              }\n           "
  " }\n          },\n          {\n            "
  "\"name\": \"document:1#writer\",\n           "
  " \"leaf\": {\n              \"tupleToUserset"
  "\": {\n                \"tupleset\": \"docume"
  "nt:1#parent\",\n                \"computed\""
  ": [\n                  {\n                "
  "    \"userset\": \"folder:1#owner\"\n        "
  "          }\n                ]\n          "
  "    }\n            }\n          }\n        "
  "]\n      }\n    }\n  }\n}\n```\nThis tells us "
  "that the `owner` of `folder:1` may also "
  "be a writer. So our next call could be t"
  "o find the `owners` of `folder:1`\n```jso"
  "n\n{\n  \"tuple_key\": {\n    \"object\": \"fold"
  "er:1\",\n    \"relation\": \"owner\"\n  }\n}\n```"
  "\nwhich gives\n```json\n{\n  \"tree\": {\n    \""
  "root\": {\n      \"name\": \"folder:1#owner\","
  "\n      \"leaf\": {\n        \"users\": {\n    "
  "      \"users\": [\n            \"user:bob\"\n"
  "          ]\n        }\n      }\n    }\n  }\n"
  "}\n```\n*\006Expand\202\323\344\223\002\036:\001*\"\031/stores/{store_"
  "id}/expand\022\202\013\n\027ReadAuthorizationModels\022*"
  ".openfga.v1.ReadAuthorizationModelsReque"
  "st\032+.openfga.v1.ReadAuthorizationModelsR"
  "esponse\"\215\n\222A\332\t\n\024Authorization Models\022:Re"
  "turn all the authorization models for a "
  "particular store\032\354\010The ReadAuthorization"
  "Models API will return all the authoriza"
  "tion models for a certain store.\nOpenFGA"
  "\'s response will contain an array of all"
  " authorization models, sorted in descend"
  "ing order of creation.\n\n## Example\nAssum"
  "e that a store\'s authorization model has"
  " been configured twice. To get all the a"
  "uthorization models that have been creat"
  "ed in this store, call GET authorization"
  "-models. The API will return a response "
  "that looks like:\n```json\n{\n  \"authorizat"
  "ion_models\": [\n    {\n      \"id\": \"01G50Q"
  "VV17PECNVAHX1GG4Y5NC\",\n      \"type_defin"
  "itions\": [...]\n    },\n    {\n      \"id\": "
  "\"01G4ZW8F4A07AKQ8RHSVG9RW04\",\n      \"typ"
  "e_definitions\": [...]\n    },\n  ],\n  \"con"
  "tinuation_token\": \"eyJwayI6IkxBVEVTVF9OU"
  "0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qb"
  "XF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\"\n}\n`"
  "``\nIf there are no more authorization mo"
  "dels available, the `continuation_token`"
  " field will be empty\n```json\n{\n  \"author"
  "ization_models\": [\n    {\n      \"id\": \"01"
  "G50QVV17PECNVAHX1GG4Y5NC\",\n      \"type_d"
  "efinitions\": [...]\n    },\n    {\n      \"i"
  "d\": \"01G4ZW8F4A07AKQ8RHSVG9RW04\",\n      "
  "\"type_definitions\": [...]\n    },\n  ],\n  "
  "\"continuation_token\": \"\"\n}\n```\n*\027ReadAut"
  "horizationModels\202\323\344\223\002)\022\'/stores/{store_i"
  "d}/authorization-models\022\204\013\n\026ReadAuthoriz"
  "ationModel\022).openfga.v1.ReadAuthorizatio"
  "nModelRequest\032*.openfga.v1.ReadAuthoriza"
  "tionModelResponse\"\222\n\222A\332\t\n\024Authorization "
  "Models\0225Return a particular version of a"
  "n authorization model\032\362\010The ReadAuthoriz"
  "ationModel API returns an authorization "
  "model by its identifier.\nThe response wi"
  "ll return the authorization model for th"
  "e particular version.\n\n## Example\nTo ret"
  "rieve the authorization model with ID `0"
  "1G5JAVJ41T49E9TT3SKVS7X1J` for the store"
  ", call the GET authorization-models by I"
  "D API with `01G5JAVJ41T49E9TT3SKVS7X1J` "
  "as the `id` path parameter.  The API wil"
  "l return:\n```json\n{\n  \"authorization_mod"
  "el\":{\n    \"id\":\"01G5JAVJ41T49E9TT3SKVS7X"
  "1J\",\n    \"type_definitions\":[\n      {\n  "
  "      \"type\":\"user\"\n      },\n      {\n   "
  "     \"type\":\"document\",\n        \"relatio"
  "ns\":{\n          \"reader\":{\n            \""
  "union\":{\n              \"child\":[\n       "
  "         {\n                  \"this\":{}\n "
  "               },\n                {\n    "
  "              \"computedUserset\":{\n      "
  "              \"object\":\"\",\n             "
  "       \"relation\":\"writer\"\n             "
  "     }\n                }\n              ]"
  "\n            }\n          },\n          \"w"
  "riter\":{\n            \"this\":{}\n         "
  " }\n        }\n      }\n    ]\n  }\n}\n```\nIn "
  "the above example, there are 2 types (`u"
  "ser` and `document`). The `document` typ"
  "e has 2 relations (`writer` and `reader`"
  ").*\026ReadAuthorizationModel\202\323\344\223\002.\022,/store"
  "s/{store_id}/authorization-models/{id}\022\371"
  "\n\n\027WriteAuthorizationModel\022*.openfga.v1."
  "WriteAuthorizationModelRequest\032+.openfga"
  ".v1.WriteAuthorizationModelResponse\"\204\n\222A"
  "\316\t\n\024Authorization Models\022 Create a new a"
  "uthorization model\032\250\010The WriteAuthorizat"
  "ionModel API will add a new authorizatio"
  "n model to a store.\nEach item in the `ty"
  "pe_definitions` array is a type definiti"
  "on as specified in the field `type_defin"
  "ition`.\nThe response will return the aut"
  "horization model\'s ID in the `id` field."
  "\n\n## Example\nTo add an authorization mod"
  "el with `user` and `document` type defin"
  "itions, call POST authorization-models A"
  "PI with the body: \n```json\n{\n  \"type_def"
  "initions\":[\n    {\n      \"type\":\"user\"\n  "
  "  },\n    {\n      \"type\":\"document\",\n    "
  "  \"relations\":{\n        \"reader\":{\n     "
  "     \"union\":{\n            \"child\":[\n   "
  "           {\n                \"this\":{}\n "
  "             },\n              {\n        "
  "        \"computedUserset\":{\n            "
  "      \"object\":\"\",\n                  \"re"
  "lation\":\"writer\"\n                }\n     "
  "         }\n            ]\n          }\n   "
  "     },\n        \"writer\":{\n          \"th"
  "is\":{}\n        }\n      }\n    }\n  ]\n}\n```"
  "\nOpenFGA\'s response will include the ver"
  "sion id for this authorization model, wh"
  "ich will look like \n```\n{\"authorization_"
  "model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\"}"
  "\n```\n*\027WriteAuthorizationModelJP\n\003201\022I\n"
  "\026A successful response.\022/\n-\032+.openfga.v1"
  ".WriteAuthorizationModelResponse\202\323\344\223\002,:\001"
  "*\"\'/stores/{store_id}/authorization-mode"
  "ls\022\357\004\n\017WriteAssertions\022\".openfga.v1.Writ"
  "eAssertionsRequest\032#.openfga.v1.WriteAss"
  "ertionsResponse\"\222\004\222A\315\003\n\nAssertions\022/Upse"
  "rt assertions for an authorization model"
  " ID\032\262\002The WriteAssertions API will upser"
  "t new assertions for an authorization mo"
  "del id, or overwrite the existing ones. "
  "An assertion is an object that contains "
  "a tuple key, the expectation of whether "
  "a call to the Check API of that tuple ke"
  "y will return true or false, and optiona"
  "lly a list of contextual tuples.*\017WriteA"
  "ssertionsJH\n\003204\022A\n\026A successful respons"
  "e.\022\'\n%\032#.openfga.v1.WriteAssertionsRespo"
  "nse\202\323\344\223\002;:\001*\0326/stores/{store_id}/asserti"
  "ons/{authorization_model_id}\022\323\002\n\016ReadAss"
  "ertions\022!.openfga.v1.ReadAssertionsReque"
  "st\032\".openfga.v1.ReadAssertionsResponse\"\371"
  "\001\222A\267\001\n\nAssertions\022-Read assertions for a"
  "n authorization model ID\032jThe ReadAssert"
  "ions API will return, for a given author"
  "ization model id, all the assertions sto"
  "red for it. *\016ReadAssertions\202\323\344\223\0028\0226/sto"
  "res/{store_id}/assertions/{authorization"
  "_model_id}\022\343\007\n\013ReadChanges\022\036.openfga.v1."
  "ReadChangesRequest\032\037.openfga.v1.ReadChan"
  "gesResponse\"\222\007\222A\354\006\n\023Relationship Tuples\022"
  "&Return a list of all the tuple changes\032"
  "\237\006The ReadChanges API will return a pagi"
  "nated list of tuple changes (additions a"
  "nd deletions) that occurred in a given s"
  "tore, sorted by ascending time. The resp"
  "onse will include a continuation token t"
  "hat is used to get the next set of chang"
  "es. If there are no changes after the pr"
  "ovided continuation token, the same toke"
  "n will be returned in order for it to be"
  " used when new changes are recorded. If "
  "the store never had any tuples added or "
  "removed, this token will be empty.\nYou c"
  "an use the `type` parameter to only get "
  "the list of tuple changes that affect ob"
  "jects of that type.\nWhen reading a write"
  " tuple change, if it was conditioned, th"
  "e condition will be returned.\nWhen readi"
  "ng a delete tuple change, the condition "
  "will NOT be returned regardless of wheth"
  "er it was originally conditioned or not."
  "\n*\013ReadChanges\202\323\344\223\002\034\022\032/stores/{store_id}"
  "/changes\022\273\002\n\013CreateStore\022\036.openfga.v1.Cr"
  "eateStoreRequest\032\037.openfga.v1.CreateStor"
  "eResponse\"\352\001\222A\324\001\n\006Stores\022\016Create a store"
  "\032gCreate a unique OpenFGA store which wi"
  "ll be used to store authorization models"
  " and relationship tuples.*\013CreateStoreJD"
  "\n\003201\022=\n\026A successful response.\022#\n!\032\037.op"
  "enfga.v1.CreateStoreResponse\202\323\344\223\002\014:\001*\"\007/"
  "stores\022\216\002\n\013UpdateStore\022\036.openfga.v1.Upda"
  "teStoreRequest\032\037.openfga.v1.UpdateStoreR"
  "esponse\"\275\001\222A\207\001\n\006Stores\022\016Update a store\032\032"
  "Updates an existing store.*\013UpdateStoreJ"
  "D\n\003200\022=\n\026A successful response.\022#\n!\032\037.o"
  "penfga.v1.UpdateStoreResponse\372\322\344\223\002\017\022\rUNI"
  "MPLEMENTED\202\323\344\223\002\027:\001*2\022/stores/{store_id}\022"
  "\322\002\n\013DeleteStore\022\036.openfga.v1.DeleteStore"
  "Request\032\037.openfga.v1.DeleteStoreResponse"
  "\"\201\002\222A\343\001\n\006Stores\022\016Delete a store\032vDelete "
  "an OpenFGA store. This does not delete t"
  "he data associated with the store, like "
  "tuples or authorization models.*\013DeleteS"
  "toreJD\n\003204\022=\n\026A successful response.\022#\n"
  "!\032\037.openfga.v1.DeleteStoreResponse\202\323\344\223\002\024"
  "*\022/stores/{store_id}\022\257\001\n\010GetStore\022\033.open"
  "fga.v1.GetStoreRequest\032\034.openfga.v1.GetS"
  "toreResponse\"h\222AK\n\006Stores\022\013Get a store\032*"
  "Returns an OpenFGA store by its identifi"
  "er*\010GetStore\202\323\344\223\002\024\022\022/stores/{store_id}\022\251"
  "\002\n\nListStores\022\035.openfga.v1.ListStoresReq"
  "uest\032\036.openfga.v1.ListStoresResponse\"\333\001\222"
  "A\310\001\n\006Stores\022\017List all stores\032\240\001Returns a"
  " paginated list of OpenFGA stores and a "
  "continuation token to get additional sto"
  "res.\nThe continuation token will be empt"
  "y if there are no more stores.\n*\nListSto"
  "res\202\323\344\223\002\t\022\007/stores\022\361\004\n\023StreamedListObjec"
  "ts\022&.openfga.v1.StreamedListObjectsReque"
  "st\032\'.openfga.v1.StreamedListObjectsRespo"
  "nse\"\206\004\222A\317\003\n\024Relationship Queries\022FStream"
  " all objects of the given type that the "
  "user has a relation with\032\331\002The Streamed "
  "ListObjects API is very similar to the t"
  "he ListObjects API, with two differences"
  ": \n1. Instead of collecting all objects "
  "before returning a response, it streams "
  "them to the client as they are collected"
  ". \n2. The number of results returned is "
  "only limited by the execution timeout sp"
  "ecified in the flag OPENFGA_LIST_OBJECTS"
  "_DEADLINE. \n*\023StreamedListObjects\202\323\344\223\002-:"
  "\001*\"(/stores/{store_id}/streamed-list-obj"
  "ects0\001\022\335\021\n\013ListObjects\022\036.openfga.v1.List"
  "ObjectsRequest\032\037.openfga.v1.ListObjectsR"
  "esponse\"\214\021\222A\336\020\n\024Relationship Queries\022DLi"
  "st all objects of the given type that th"
  "e user has a relation with\032\362\017The ListObj"
  "ects API returns a list of all the objec"
  "ts of the given type that the user has a"
  " relation with.\n To arrive at a result, "
  "the API uses: an authorization model, ex"
  "plicit tuples written through the Write "
  "API, contextual tuples present in the re"
  "quest, and implicit tuples that exist by"
  " virtue of applying set theory (such as "
  "`document:2021-budget#viewer@document:20"
  "21-budget#viewer`; the set of users who "
  "are viewers of `document:2021-budget` ar"
  "e the set of users who are the viewers o"
  "f `document:2021-budget`).\nAn `authoriza"
  "tion_model_id` may be specified in the b"
  "ody. If it is not specified, the latest "
  "authorization model ID will be used. It "
  "is strongly recommended to specify autho"
  "rization model id for better performance"
  ".\nYou may also specify `contextual_tuple"
  "s` that will be treated as regular tuple"
  "s. Each of these tuples may have an asso"
  "ciated `condition`.\nYou may also provide"
  " a `context` object that will be used to"
  " evaluate the conditioned tuples in the "
  "system. It is strongly recommended to pr"
  "ovide a value for all the input paramete"
  "rs of all the conditions, to ensure that"
  " all tuples be evaluated correctly.\nBy d"
  "efault, the Check API caches results for"
  " a short time to optimize performance. Y"
  "ou may specify a value of `HIGHER_CONSIS"
  "TENCY` for the optional `consistency` pa"
  "rameter in the body to inform the server"
  " that higher conisistency is preferred a"
  "t the expense of increased latency. Cons"
  "ideration should be given to the increas"
  "ed latency if requesting higher consiste"
  "ncy.\nThe response will contain the relat"
  "ed objects in an array in the \"objects\" "
  "field of the response and they will be s"
  "trings in the object format `<type>:<id>"
  "` (e.g. \"document:roadmap\").\nThe number "
  "of objects in the response array will be"
  " limited by the execution timeout specif"
  "ied in the flag OPENFGA_LIST_OBJECTS_DEA"
  "DLINE and by the upper bound specified i"
  "n the flag OPENFGA_LIST_OBJECTS_MAX_RESU"
  "LTS, whichever is hit first.\nThe objects"
  " given will not be sorted, and therefore"
  " two identical calls can give a given di"
  "fferent set of objects.*\013ListObjects\202\323\344\223"
  "\002$:\001*\"\037/stores/{store_id}/list-objects\022\345"
  "\021\n\tListUsers\022\034.openfga.v1.ListUsersReque"
  "st\032\035.openfga.v1.ListUsersResponse\"\232\021\222A\356\020"
  "\n\024Relationship Queries\022]List the users m"
  "atching the provided filter who have a c"
  "ertain relation to a particular type.\032\353\017"
  "The ListUsers API returns a list of all "
  "the users of a specific type that have a"
  " relation to a given object.\n To arrive "
  "at a result, the API uses: an authorizat"
  "ion model, explicit tuples written throu"
  "gh the Write API, contextual tuples pres"
  "ent in the request, and implicit tuples "
  "that exist by virtue of applying set the"
  "ory (such as `document:2021-budget#viewe"
  "r@document:2021-budget#viewer`; the set "
  "of users who are viewers of `document:20"
  "21-budget` are the set of users who are "
  "the viewers of `document:2021-budget`).\n"
  "An `authorization_model_id` may be speci"
  "fied in the body. If it is not specified"
  ", the latest authorization model ID will"
  " be used. It is strongly recommended to "
  "specify authorization model id for bette"
  "r performance.\nYou may also specify `con"
  "textual_tuples` that will be treated as "
  "regular tuples. Each of these tuples may"
  " have an associated `condition`.\nYou may"
  " also provide a `context` object that wi"
  "ll be used to evaluate the conditioned t"
  "uples in the system. It is strongly reco"
  "mmended to provide a value for all the i"
  "nput parameters of all the conditions, t"
  "o ensure that all tuples be evaluated co"
  "rrectly.\nThe response will contain the r"
  "elated users in an array in the \"users\" "
  "field of the response. These results may"
  " include specific objects, usersets \nor "
  "type-bound public access. Each of these "
  "types of results is encoded in its own t"
  "ype and not represented as a string.In c"
  "ases where a type-bound public access re"
  "sult is returned (e.g. `user:*`), it can"
  "not be inferred that all subjects\nof tha"
  "t type have a relation to the object; it"
  " is possible that negations exist and ch"
  "ecks should still be queried\non individu"
  "al subjects to ensure access to that doc"
  "ument.The number of users in the respons"
  "e array will be limited by the execution"
  " timeout specified in the flag OPENFGA_L"
  "IST_USERS_DEADLINE and by the upper boun"
  "d specified in the flag OPENFGA_LIST_USE"
  "RS_MAX_RESULTS, whichever is hit first.\n"
  "The returned users will not be sorted, a"
  "nd therefore two identical calls may yie"
  "ld different sets of users.*\tListUsers\202\323"
  "\344\223\002\":\001*\"\035/stores/{store_id}/list-usersBn"
  "\n\016com.openfga.v1B\023OpenfgaServiceProtoP\001\242"
  "\002\003OXX\252\002\nOpenfga.V1\312\002\nOpenfga\\V1\342\002\026Openfg"
  "a\\V1\\GPBMetadata\352\002\013Openfga::V1b\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_deps[12] = {
  &::descriptor_table_google_2fapi_2fannotations_2eproto,
  &::descriptor_table_google_2fapi_2ffield_5fbehavior_2eproto,
  &::descriptor_table_google_2fapi_2fvisibility_2eproto,
  &::descriptor_table_google_2fprotobuf_2fstruct_2eproto,
  &::descriptor_table_google_2fprotobuf_2ftimestamp_2eproto,
  &::descriptor_table_google_2fprotobuf_2fwrappers_2eproto,
  &::descriptor_table_openfga_2fv1_2fauthzmodel_2eproto,
  &::descriptor_table_openfga_2fv1_2ferrors_5fignore_2eproto,
  &::descriptor_table_openfga_2fv1_2fopenfga_2eproto,
  &::descriptor_table_openfga_2fv1_2fopenfga_5fservice_5fconsistency_2eproto,
  &::descriptor_table_protoc_2dgen_2dopenapiv2_2foptions_2fannotations_2eproto,
  &::descriptor_table_validate_2fvalidate_2eproto,
};
static ::_pbi::once_flag descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto = {
    false, false, 45878, descriptor_table_protodef_openfga_2fv1_2fopenfga_5fservice_2eproto,
    "openfga/v1/openfga_service.proto",
    &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once, descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_deps, 12, 51,
    schemas, file_default_instances, TableStruct_openfga_2fv1_2fopenfga_5fservice_2eproto::offsets,
    file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto, file_level_enum_descriptors_openfga_2fv1_2fopenfga_5fservice_2eproto,
    file_level_service_descriptors_openfga_2fv1_2fopenfga_5fservice_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter() {
  return &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_openfga_2fv1_2fopenfga_5fservice_2eproto(&descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto);
namespace openfga {
namespace v1 {

// ===================================================================

class ListObjectsRequest::_Internal {
 public:
  static const ::openfga::v1::ContextualTupleKeys& contextual_tuples(const ListObjectsRequest* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Struct& context(const ListObjectsRequest* msg);
};

const ::openfga::v1::ContextualTupleKeys&
ListObjectsRequest::_Internal::contextual_tuples(const ListObjectsRequest* msg) {
  return *msg->_impl_.contextual_tuples_;
}
const ::PROTOBUF_NAMESPACE_ID::Struct&
ListObjectsRequest::_Internal::context(const ListObjectsRequest* msg) {
  return *msg->_impl_.context_;
}
void ListObjectsRequest::clear_contextual_tuples() {
  if (GetArenaForAllocation() == nullptr && _impl_.contextual_tuples_ != nullptr) {
    delete _impl_.contextual_tuples_;
  }
  _impl_.contextual_tuples_ = nullptr;
}
void ListObjectsRequest::clear_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
    delete _impl_.context_;
  }
  _impl_.context_ = nullptr;
}
ListObjectsRequest::ListObjectsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.ListObjectsRequest)
}
ListObjectsRequest::ListObjectsRequest(const ListObjectsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListObjectsRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.store_id_){}
    , decltype(_impl_.authorization_model_id_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.relation_){}
    , decltype(_impl_.user_){}
    , decltype(_impl_.contextual_tuples_){nullptr}
    , decltype(_impl_.context_){nullptr}
    , decltype(_impl_.consistency_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_store_id().empty()) {
    _this->_impl_.store_id_.Set(from._internal_store_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.authorization_model_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_authorization_model_id().empty()) {
    _this->_impl_.authorization_model_id_.Set(from._internal_authorization_model_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type().empty()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.relation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_relation().empty()) {
    _this->_impl_.relation_.Set(from._internal_relation(), 
      _this->GetArenaForAllocation());
  }
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user().empty()) {
    _this->_impl_.user_.Set(from._internal_user(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_contextual_tuples()) {
    _this->_impl_.contextual_tuples_ = new ::openfga::v1::ContextualTupleKeys(*from._impl_.contextual_tuples_);
  }
  if (from._internal_has_context()) {
    _this->_impl_.context_ = new ::PROTOBUF_NAMESPACE_ID::Struct(*from._impl_.context_);
  }
  _this->_impl_.consistency_ = from._impl_.consistency_;
  // @@protoc_insertion_point(copy_constructor:openfga.v1.ListObjectsRequest)
}

inline void ListObjectsRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.store_id_){}
    , decltype(_impl_.authorization_model_id_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.relation_){}
    , decltype(_impl_.user_){}
    , decltype(_impl_.contextual_tuples_){nullptr}
    , decltype(_impl_.context_){nullptr}
    , decltype(_impl_.consistency_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.authorization_model_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.relation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListObjectsRequest::~ListObjectsRequest() {
  // @@protoc_insertion_point(destructor:openfga.v1.ListObjectsRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListObjectsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.store_id_.Destroy();
  _impl_.authorization_model_id_.Destroy();
  _impl_.type_.Destroy();
  _impl_.relation_.Destroy();
  _impl_.user_.Destroy();
  if (this != internal_default_instance()) delete _impl_.contextual_tuples_;
  if (this != internal_default_instance()) delete _impl_.context_;
}

void ListObjectsRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListObjectsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.ListObjectsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.store_id_.ClearToEmpty();
  _impl_.authorization_model_id_.ClearToEmpty();
  _impl_.type_.ClearToEmpty();
  _impl_.relation_.ClearToEmpty();
  _impl_.user_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.contextual_tuples_ != nullptr) {
    delete _impl_.contextual_tuples_;
  }
  _impl_.contextual_tuples_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
    delete _impl_.context_;
  }
  _impl_.context_ = nullptr;
  _impl_.consistency_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListObjectsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_store_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ListObjectsRequest.store_id"));
        } else
          goto handle_unusual;
        continue;
      // string authorization_model_id = 2 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_authorization_model_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ListObjectsRequest.authorization_model_id"));
        } else
          goto handle_unusual;
        continue;
      // string type = 3 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ListObjectsRequest.type"));
        } else
          goto handle_unusual;
        continue;
      // string relation = 4 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_relation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ListObjectsRequest.relation"));
        } else
          goto handle_unusual;
        continue;
      // string user = 5 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_user();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ListObjectsRequest.user"));
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.ContextualTupleKeys contextual_tuples = 6 [json_name = "contextual_tuples"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_contextual_tuples(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Struct context = 7 [json_name = "context"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_context(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.ConsistencyPreference consistency = 8 [json_name = "consistency", (.validate.rules) = {
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_consistency(static_cast<::openfga::v1::ConsistencyPreference>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListObjectsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.ListObjectsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_store_id().data(), static_cast<int>(this->_internal_store_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ListObjectsRequest.store_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_store_id(), target);
  }

  // string authorization_model_id = 2 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_authorization_model_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_authorization_model_id().data(), static_cast<int>(this->_internal_authorization_model_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ListObjectsRequest.authorization_model_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_authorization_model_id(), target);
  }

  // string type = 3 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ListObjectsRequest.type");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_type(), target);
  }

  // string relation = 4 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_relation().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_relation().data(), static_cast<int>(this->_internal_relation().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ListObjectsRequest.relation");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_relation(), target);
  }

  // string user = 5 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_user().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user().data(), static_cast<int>(this->_internal_user().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ListObjectsRequest.user");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_user(), target);
  }

  // .openfga.v1.ContextualTupleKeys contextual_tuples = 6 [json_name = "contextual_tuples"];
  if (this->_internal_has_contextual_tuples()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::contextual_tuples(this),
        _Internal::contextual_tuples(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Struct context = 7 [json_name = "context"];
  if (this->_internal_has_context()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::context(this),
        _Internal::context(this).GetCachedSize(), target, stream);
  }

  // .openfga.v1.ConsistencyPreference consistency = 8 [json_name = "consistency", (.validate.rules) = {
  if (this->_internal_consistency() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_consistency(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.ListObjectsRequest)
  return target;
}

size_t ListObjectsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.ListObjectsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_store_id());
  }

  // string authorization_model_id = 2 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_authorization_model_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_authorization_model_id());
  }

  // string type = 3 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());
  }

  // string relation = 4 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_relation().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_relation());
  }

  // string user = 5 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_user().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user());
  }

  // .openfga.v1.ContextualTupleKeys contextual_tuples = 6 [json_name = "contextual_tuples"];
  if (this->_internal_has_contextual_tuples()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.contextual_tuples_);
  }

  // .google.protobuf.Struct context = 7 [json_name = "context"];
  if (this->_internal_has_context()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.context_);
  }

  // .openfga.v1.ConsistencyPreference consistency = 8 [json_name = "consistency", (.validate.rules) = {
  if (this->_internal_consistency() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_consistency());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListObjectsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListObjectsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListObjectsRequest::GetClassData() const { return &_class_data_; }


void ListObjectsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListObjectsRequest*>(&to_msg);
  auto& from = static_cast<const ListObjectsRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.ListObjectsRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_store_id().empty()) {
    _this->_internal_set_store_id(from._internal_store_id());
  }
  if (!from._internal_authorization_model_id().empty()) {
    _this->_internal_set_authorization_model_id(from._internal_authorization_model_id());
  }
  if (!from._internal_type().empty()) {
    _this->_internal_set_type(from._internal_type());
  }
  if (!from._internal_relation().empty()) {
    _this->_internal_set_relation(from._internal_relation());
  }
  if (!from._internal_user().empty()) {
    _this->_internal_set_user(from._internal_user());
  }
  if (from._internal_has_contextual_tuples()) {
    _this->_internal_mutable_contextual_tuples()->::openfga::v1::ContextualTupleKeys::MergeFrom(
        from._internal_contextual_tuples());
  }
  if (from._internal_has_context()) {
    _this->_internal_mutable_context()->::PROTOBUF_NAMESPACE_ID::Struct::MergeFrom(
        from._internal_context());
  }
  if (from._internal_consistency() != 0) {
    _this->_internal_set_consistency(from._internal_consistency());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListObjectsRequest::CopyFrom(const ListObjectsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.ListObjectsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListObjectsRequest::IsInitialized() const {
  return true;
}

void ListObjectsRequest::InternalSwap(ListObjectsRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.store_id_, lhs_arena,
      &other->_impl_.store_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.authorization_model_id_, lhs_arena,
      &other->_impl_.authorization_model_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.relation_, lhs_arena,
      &other->_impl_.relation_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_, lhs_arena,
      &other->_impl_.user_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ListObjectsRequest, _impl_.consistency_)
      + sizeof(ListObjectsRequest::_impl_.consistency_)
      - PROTOBUF_FIELD_OFFSET(ListObjectsRequest, _impl_.contextual_tuples_)>(
          reinterpret_cast<char*>(&_impl_.contextual_tuples_),
          reinterpret_cast<char*>(&other->_impl_.contextual_tuples_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ListObjectsRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[0]);
}

// ===================================================================

class ListObjectsResponse::_Internal {
 public:
};

ListObjectsResponse::ListObjectsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.ListObjectsResponse)
}
ListObjectsResponse::ListObjectsResponse(const ListObjectsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListObjectsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.objects_){from._impl_.objects_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:openfga.v1.ListObjectsResponse)
}

inline void ListObjectsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.objects_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ListObjectsResponse::~ListObjectsResponse() {
  // @@protoc_insertion_point(destructor:openfga.v1.ListObjectsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListObjectsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.objects_.~RepeatedPtrField();
}

void ListObjectsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListObjectsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.ListObjectsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.objects_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListObjectsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string objects = 1 [json_name = "objects", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_objects();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ListObjectsResponse.objects"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListObjectsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.ListObjectsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string objects = 1 [json_name = "objects", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  for (int i = 0, n = this->_internal_objects_size(); i < n; i++) {
    const auto& s = this->_internal_objects(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ListObjectsResponse.objects");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.ListObjectsResponse)
  return target;
}

size_t ListObjectsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.ListObjectsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string objects = 1 [json_name = "objects", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.objects_.size());
  for (int i = 0, n = _impl_.objects_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.objects_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListObjectsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListObjectsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListObjectsResponse::GetClassData() const { return &_class_data_; }


void ListObjectsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListObjectsResponse*>(&to_msg);
  auto& from = static_cast<const ListObjectsResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.ListObjectsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.objects_.MergeFrom(from._impl_.objects_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListObjectsResponse::CopyFrom(const ListObjectsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.ListObjectsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListObjectsResponse::IsInitialized() const {
  return true;
}

void ListObjectsResponse::InternalSwap(ListObjectsResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.objects_.InternalSwap(&other->_impl_.objects_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListObjectsResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[1]);
}

// ===================================================================

class ListUsersRequest::_Internal {
 public:
  static const ::openfga::v1::Object& object(const ListUsersRequest* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Struct& context(const ListUsersRequest* msg);
};

const ::openfga::v1::Object&
ListUsersRequest::_Internal::object(const ListUsersRequest* msg) {
  return *msg->_impl_.object_;
}
const ::PROTOBUF_NAMESPACE_ID::Struct&
ListUsersRequest::_Internal::context(const ListUsersRequest* msg) {
  return *msg->_impl_.context_;
}
void ListUsersRequest::clear_object() {
  if (GetArenaForAllocation() == nullptr && _impl_.object_ != nullptr) {
    delete _impl_.object_;
  }
  _impl_.object_ = nullptr;
}
void ListUsersRequest::clear_user_filters() {
  _impl_.user_filters_.Clear();
}
void ListUsersRequest::clear_contextual_tuples() {
  _impl_.contextual_tuples_.Clear();
}
void ListUsersRequest::clear_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
    delete _impl_.context_;
  }
  _impl_.context_ = nullptr;
}
ListUsersRequest::ListUsersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.ListUsersRequest)
}
ListUsersRequest::ListUsersRequest(const ListUsersRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListUsersRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.user_filters_){from._impl_.user_filters_}
    , decltype(_impl_.contextual_tuples_){from._impl_.contextual_tuples_}
    , decltype(_impl_.store_id_){}
    , decltype(_impl_.authorization_model_id_){}
    , decltype(_impl_.relation_){}
    , decltype(_impl_.object_){nullptr}
    , decltype(_impl_.context_){nullptr}
    , decltype(_impl_.consistency_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_store_id().empty()) {
    _this->_impl_.store_id_.Set(from._internal_store_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.authorization_model_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_authorization_model_id().empty()) {
    _this->_impl_.authorization_model_id_.Set(from._internal_authorization_model_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.relation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_relation().empty()) {
    _this->_impl_.relation_.Set(from._internal_relation(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_object()) {
    _this->_impl_.object_ = new ::openfga::v1::Object(*from._impl_.object_);
  }
  if (from._internal_has_context()) {
    _this->_impl_.context_ = new ::PROTOBUF_NAMESPACE_ID::Struct(*from._impl_.context_);
  }
  _this->_impl_.consistency_ = from._impl_.consistency_;
  // @@protoc_insertion_point(copy_constructor:openfga.v1.ListUsersRequest)
}

inline void ListUsersRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.user_filters_){arena}
    , decltype(_impl_.contextual_tuples_){arena}
    , decltype(_impl_.store_id_){}
    , decltype(_impl_.authorization_model_id_){}
    , decltype(_impl_.relation_){}
    , decltype(_impl_.object_){nullptr}
    , decltype(_impl_.context_){nullptr}
    , decltype(_impl_.consistency_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.authorization_model_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.relation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListUsersRequest::~ListUsersRequest() {
  // @@protoc_insertion_point(destructor:openfga.v1.ListUsersRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListUsersRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_filters_.~RepeatedPtrField();
  _impl_.contextual_tuples_.~RepeatedPtrField();
  _impl_.store_id_.Destroy();
  _impl_.authorization_model_id_.Destroy();
  _impl_.relation_.Destroy();
  if (this != internal_default_instance()) delete _impl_.object_;
  if (this != internal_default_instance()) delete _impl_.context_;
}

void ListUsersRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListUsersRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.ListUsersRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_filters_.Clear();
  _impl_.contextual_tuples_.Clear();
  _impl_.store_id_.ClearToEmpty();
  _impl_.authorization_model_id_.ClearToEmpty();
  _impl_.relation_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.object_ != nullptr) {
    delete _impl_.object_;
  }
  _impl_.object_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
    delete _impl_.context_;
  }
  _impl_.context_ = nullptr;
  _impl_.consistency_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListUsersRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_store_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ListUsersRequest.store_id"));
        } else
          goto handle_unusual;
        continue;
      // string authorization_model_id = 2 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_authorization_model_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ListUsersRequest.authorization_model_id"));
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.Object object = 3 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_object(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string relation = 4 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_relation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ListUsersRequest.relation"));
        } else
          goto handle_unusual;
        continue;
      // repeated .openfga.v1.UserTypeFilter user_filters = 5 [json_name = "user_filters", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_user_filters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .openfga.v1.TupleKey contextual_tuples = 6 [json_name = "contextual_tuples", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_contextual_tuples(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Struct context = 7 [json_name = "context"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_context(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.ConsistencyPreference consistency = 8 [json_name = "consistency", (.validate.rules) = {
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_consistency(static_cast<::openfga::v1::ConsistencyPreference>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListUsersRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.ListUsersRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_store_id().data(), static_cast<int>(this->_internal_store_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ListUsersRequest.store_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_store_id(), target);
  }

  // string authorization_model_id = 2 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_authorization_model_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_authorization_model_id().data(), static_cast<int>(this->_internal_authorization_model_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ListUsersRequest.authorization_model_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_authorization_model_id(), target);
  }

  // .openfga.v1.Object object = 3 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (this->_internal_has_object()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::object(this),
        _Internal::object(this).GetCachedSize(), target, stream);
  }

  // string relation = 4 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_relation().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_relation().data(), static_cast<int>(this->_internal_relation().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ListUsersRequest.relation");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_relation(), target);
  }

  // repeated .openfga.v1.UserTypeFilter user_filters = 5 [json_name = "user_filters", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_user_filters_size()); i < n; i++) {
    const auto& repfield = this->_internal_user_filters(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .openfga.v1.TupleKey contextual_tuples = 6 [json_name = "contextual_tuples", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_contextual_tuples_size()); i < n; i++) {
    const auto& repfield = this->_internal_contextual_tuples(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .google.protobuf.Struct context = 7 [json_name = "context"];
  if (this->_internal_has_context()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::context(this),
        _Internal::context(this).GetCachedSize(), target, stream);
  }

  // .openfga.v1.ConsistencyPreference consistency = 8 [json_name = "consistency", (.validate.rules) = {
  if (this->_internal_consistency() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_consistency(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.ListUsersRequest)
  return target;
}

size_t ListUsersRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.ListUsersRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .openfga.v1.UserTypeFilter user_filters = 5 [json_name = "user_filters", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  total_size += 1UL * this->_internal_user_filters_size();
  for (const auto& msg : this->_impl_.user_filters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .openfga.v1.TupleKey contextual_tuples = 6 [json_name = "contextual_tuples", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  total_size += 1UL * this->_internal_contextual_tuples_size();
  for (const auto& msg : this->_impl_.contextual_tuples_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_store_id());
  }

  // string authorization_model_id = 2 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_authorization_model_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_authorization_model_id());
  }

  // string relation = 4 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_relation().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_relation());
  }

  // .openfga.v1.Object object = 3 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (this->_internal_has_object()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.object_);
  }

  // .google.protobuf.Struct context = 7 [json_name = "context"];
  if (this->_internal_has_context()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.context_);
  }

  // .openfga.v1.ConsistencyPreference consistency = 8 [json_name = "consistency", (.validate.rules) = {
  if (this->_internal_consistency() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_consistency());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListUsersRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListUsersRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListUsersRequest::GetClassData() const { return &_class_data_; }


void ListUsersRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListUsersRequest*>(&to_msg);
  auto& from = static_cast<const ListUsersRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.ListUsersRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.user_filters_.MergeFrom(from._impl_.user_filters_);
  _this->_impl_.contextual_tuples_.MergeFrom(from._impl_.contextual_tuples_);
  if (!from._internal_store_id().empty()) {
    _this->_internal_set_store_id(from._internal_store_id());
  }
  if (!from._internal_authorization_model_id().empty()) {
    _this->_internal_set_authorization_model_id(from._internal_authorization_model_id());
  }
  if (!from._internal_relation().empty()) {
    _this->_internal_set_relation(from._internal_relation());
  }
  if (from._internal_has_object()) {
    _this->_internal_mutable_object()->::openfga::v1::Object::MergeFrom(
        from._internal_object());
  }
  if (from._internal_has_context()) {
    _this->_internal_mutable_context()->::PROTOBUF_NAMESPACE_ID::Struct::MergeFrom(
        from._internal_context());
  }
  if (from._internal_consistency() != 0) {
    _this->_internal_set_consistency(from._internal_consistency());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListUsersRequest::CopyFrom(const ListUsersRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.ListUsersRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListUsersRequest::IsInitialized() const {
  return true;
}

void ListUsersRequest::InternalSwap(ListUsersRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.user_filters_.InternalSwap(&other->_impl_.user_filters_);
  _impl_.contextual_tuples_.InternalSwap(&other->_impl_.contextual_tuples_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.store_id_, lhs_arena,
      &other->_impl_.store_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.authorization_model_id_, lhs_arena,
      &other->_impl_.authorization_model_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.relation_, lhs_arena,
      &other->_impl_.relation_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ListUsersRequest, _impl_.consistency_)
      + sizeof(ListUsersRequest::_impl_.consistency_)
      - PROTOBUF_FIELD_OFFSET(ListUsersRequest, _impl_.object_)>(
          reinterpret_cast<char*>(&_impl_.object_),
          reinterpret_cast<char*>(&other->_impl_.object_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ListUsersRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[2]);
}

// ===================================================================

class ListUsersResponse::_Internal {
 public:
};

void ListUsersResponse::clear_users() {
  _impl_.users_.Clear();
}
ListUsersResponse::ListUsersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.ListUsersResponse)
}
ListUsersResponse::ListUsersResponse(const ListUsersResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListUsersResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.users_){from._impl_.users_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:openfga.v1.ListUsersResponse)
}

inline void ListUsersResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.users_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ListUsersResponse::~ListUsersResponse() {
  // @@protoc_insertion_point(destructor:openfga.v1.ListUsersResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListUsersResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.users_.~RepeatedPtrField();
}

void ListUsersResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListUsersResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.ListUsersResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.users_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListUsersResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .openfga.v1.User users = 1 [json_name = "users", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_users(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListUsersResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.ListUsersResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .openfga.v1.User users = 1 [json_name = "users", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_users_size()); i < n; i++) {
    const auto& repfield = this->_internal_users(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.ListUsersResponse)
  return target;
}

size_t ListUsersResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.ListUsersResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .openfga.v1.User users = 1 [json_name = "users", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  total_size += 1UL * this->_internal_users_size();
  for (const auto& msg : this->_impl_.users_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListUsersResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListUsersResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListUsersResponse::GetClassData() const { return &_class_data_; }


void ListUsersResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListUsersResponse*>(&to_msg);
  auto& from = static_cast<const ListUsersResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.ListUsersResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.users_.MergeFrom(from._impl_.users_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListUsersResponse::CopyFrom(const ListUsersResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.ListUsersResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListUsersResponse::IsInitialized() const {
  return true;
}

void ListUsersResponse::InternalSwap(ListUsersResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.users_.InternalSwap(&other->_impl_.users_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListUsersResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[3]);
}

// ===================================================================

class StreamedListObjectsRequest::_Internal {
 public:
  static const ::openfga::v1::ContextualTupleKeys& contextual_tuples(const StreamedListObjectsRequest* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Struct& context(const StreamedListObjectsRequest* msg);
};

const ::openfga::v1::ContextualTupleKeys&
StreamedListObjectsRequest::_Internal::contextual_tuples(const StreamedListObjectsRequest* msg) {
  return *msg->_impl_.contextual_tuples_;
}
const ::PROTOBUF_NAMESPACE_ID::Struct&
StreamedListObjectsRequest::_Internal::context(const StreamedListObjectsRequest* msg) {
  return *msg->_impl_.context_;
}
void StreamedListObjectsRequest::clear_contextual_tuples() {
  if (GetArenaForAllocation() == nullptr && _impl_.contextual_tuples_ != nullptr) {
    delete _impl_.contextual_tuples_;
  }
  _impl_.contextual_tuples_ = nullptr;
}
void StreamedListObjectsRequest::clear_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
    delete _impl_.context_;
  }
  _impl_.context_ = nullptr;
}
StreamedListObjectsRequest::StreamedListObjectsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.StreamedListObjectsRequest)
}
StreamedListObjectsRequest::StreamedListObjectsRequest(const StreamedListObjectsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamedListObjectsRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.store_id_){}
    , decltype(_impl_.authorization_model_id_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.relation_){}
    , decltype(_impl_.user_){}
    , decltype(_impl_.contextual_tuples_){nullptr}
    , decltype(_impl_.context_){nullptr}
    , decltype(_impl_.consistency_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_store_id().empty()) {
    _this->_impl_.store_id_.Set(from._internal_store_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.authorization_model_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_authorization_model_id().empty()) {
    _this->_impl_.authorization_model_id_.Set(from._internal_authorization_model_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type().empty()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.relation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_relation().empty()) {
    _this->_impl_.relation_.Set(from._internal_relation(), 
      _this->GetArenaForAllocation());
  }
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user().empty()) {
    _this->_impl_.user_.Set(from._internal_user(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_contextual_tuples()) {
    _this->_impl_.contextual_tuples_ = new ::openfga::v1::ContextualTupleKeys(*from._impl_.contextual_tuples_);
  }
  if (from._internal_has_context()) {
    _this->_impl_.context_ = new ::PROTOBUF_NAMESPACE_ID::Struct(*from._impl_.context_);
  }
  _this->_impl_.consistency_ = from._impl_.consistency_;
  // @@protoc_insertion_point(copy_constructor:openfga.v1.StreamedListObjectsRequest)
}

inline void StreamedListObjectsRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.store_id_){}
    , decltype(_impl_.authorization_model_id_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.relation_){}
    , decltype(_impl_.user_){}
    , decltype(_impl_.contextual_tuples_){nullptr}
    , decltype(_impl_.context_){nullptr}
    , decltype(_impl_.consistency_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.authorization_model_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.relation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StreamedListObjectsRequest::~StreamedListObjectsRequest() {
  // @@protoc_insertion_point(destructor:openfga.v1.StreamedListObjectsRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamedListObjectsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.store_id_.Destroy();
  _impl_.authorization_model_id_.Destroy();
  _impl_.type_.Destroy();
  _impl_.relation_.Destroy();
  _impl_.user_.Destroy();
  if (this != internal_default_instance()) delete _impl_.contextual_tuples_;
  if (this != internal_default_instance()) delete _impl_.context_;
}

void StreamedListObjectsRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamedListObjectsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.StreamedListObjectsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.store_id_.ClearToEmpty();
  _impl_.authorization_model_id_.ClearToEmpty();
  _impl_.type_.ClearToEmpty();
  _impl_.relation_.ClearToEmpty();
  _impl_.user_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.contextual_tuples_ != nullptr) {
    delete _impl_.contextual_tuples_;
  }
  _impl_.contextual_tuples_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
    delete _impl_.context_;
  }
  _impl_.context_ = nullptr;
  _impl_.consistency_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamedListObjectsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_store_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.StreamedListObjectsRequest.store_id"));
        } else
          goto handle_unusual;
        continue;
      // string authorization_model_id = 2 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_authorization_model_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.StreamedListObjectsRequest.authorization_model_id"));
        } else
          goto handle_unusual;
        continue;
      // string type = 3 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.StreamedListObjectsRequest.type"));
        } else
          goto handle_unusual;
        continue;
      // string relation = 4 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_relation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.StreamedListObjectsRequest.relation"));
        } else
          goto handle_unusual;
        continue;
      // string user = 5 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_user();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.StreamedListObjectsRequest.user"));
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.ContextualTupleKeys contextual_tuples = 6 [json_name = "contextual_tuples"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_contextual_tuples(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Struct context = 7 [json_name = "context"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_context(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.ConsistencyPreference consistency = 8 [json_name = "consistency", (.validate.rules) = {
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_consistency(static_cast<::openfga::v1::ConsistencyPreference>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StreamedListObjectsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.StreamedListObjectsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_store_id().data(), static_cast<int>(this->_internal_store_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.StreamedListObjectsRequest.store_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_store_id(), target);
  }

  // string authorization_model_id = 2 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_authorization_model_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_authorization_model_id().data(), static_cast<int>(this->_internal_authorization_model_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.StreamedListObjectsRequest.authorization_model_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_authorization_model_id(), target);
  }

  // string type = 3 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.StreamedListObjectsRequest.type");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_type(), target);
  }

  // string relation = 4 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_relation().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_relation().data(), static_cast<int>(this->_internal_relation().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.StreamedListObjectsRequest.relation");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_relation(), target);
  }

  // string user = 5 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_user().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user().data(), static_cast<int>(this->_internal_user().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.StreamedListObjectsRequest.user");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_user(), target);
  }

  // .openfga.v1.ContextualTupleKeys contextual_tuples = 6 [json_name = "contextual_tuples"];
  if (this->_internal_has_contextual_tuples()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::contextual_tuples(this),
        _Internal::contextual_tuples(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Struct context = 7 [json_name = "context"];
  if (this->_internal_has_context()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::context(this),
        _Internal::context(this).GetCachedSize(), target, stream);
  }

  // .openfga.v1.ConsistencyPreference consistency = 8 [json_name = "consistency", (.validate.rules) = {
  if (this->_internal_consistency() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_consistency(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.StreamedListObjectsRequest)
  return target;
}

size_t StreamedListObjectsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.StreamedListObjectsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_store_id());
  }

  // string authorization_model_id = 2 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_authorization_model_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_authorization_model_id());
  }

  // string type = 3 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());
  }

  // string relation = 4 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_relation().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_relation());
  }

  // string user = 5 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_user().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user());
  }

  // .openfga.v1.ContextualTupleKeys contextual_tuples = 6 [json_name = "contextual_tuples"];
  if (this->_internal_has_contextual_tuples()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.contextual_tuples_);
  }

  // .google.protobuf.Struct context = 7 [json_name = "context"];
  if (this->_internal_has_context()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.context_);
  }

  // .openfga.v1.ConsistencyPreference consistency = 8 [json_name = "consistency", (.validate.rules) = {
  if (this->_internal_consistency() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_consistency());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamedListObjectsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamedListObjectsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamedListObjectsRequest::GetClassData() const { return &_class_data_; }


void StreamedListObjectsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamedListObjectsRequest*>(&to_msg);
  auto& from = static_cast<const StreamedListObjectsRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.StreamedListObjectsRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_store_id().empty()) {
    _this->_internal_set_store_id(from._internal_store_id());
  }
  if (!from._internal_authorization_model_id().empty()) {
    _this->_internal_set_authorization_model_id(from._internal_authorization_model_id());
  }
  if (!from._internal_type().empty()) {
    _this->_internal_set_type(from._internal_type());
  }
  if (!from._internal_relation().empty()) {
    _this->_internal_set_relation(from._internal_relation());
  }
  if (!from._internal_user().empty()) {
    _this->_internal_set_user(from._internal_user());
  }
  if (from._internal_has_contextual_tuples()) {
    _this->_internal_mutable_contextual_tuples()->::openfga::v1::ContextualTupleKeys::MergeFrom(
        from._internal_contextual_tuples());
  }
  if (from._internal_has_context()) {
    _this->_internal_mutable_context()->::PROTOBUF_NAMESPACE_ID::Struct::MergeFrom(
        from._internal_context());
  }
  if (from._internal_consistency() != 0) {
    _this->_internal_set_consistency(from._internal_consistency());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamedListObjectsRequest::CopyFrom(const StreamedListObjectsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.StreamedListObjectsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamedListObjectsRequest::IsInitialized() const {
  return true;
}

void StreamedListObjectsRequest::InternalSwap(StreamedListObjectsRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.store_id_, lhs_arena,
      &other->_impl_.store_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.authorization_model_id_, lhs_arena,
      &other->_impl_.authorization_model_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.relation_, lhs_arena,
      &other->_impl_.relation_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_, lhs_arena,
      &other->_impl_.user_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StreamedListObjectsRequest, _impl_.consistency_)
      + sizeof(StreamedListObjectsRequest::_impl_.consistency_)
      - PROTOBUF_FIELD_OFFSET(StreamedListObjectsRequest, _impl_.contextual_tuples_)>(
          reinterpret_cast<char*>(&_impl_.contextual_tuples_),
          reinterpret_cast<char*>(&other->_impl_.contextual_tuples_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamedListObjectsRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[4]);
}

// ===================================================================

class StreamedListObjectsResponse::_Internal {
 public:
};

StreamedListObjectsResponse::StreamedListObjectsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.StreamedListObjectsResponse)
}
StreamedListObjectsResponse::StreamedListObjectsResponse(const StreamedListObjectsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamedListObjectsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.object_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.object_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.object_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_object().empty()) {
    _this->_impl_.object_.Set(from._internal_object(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.StreamedListObjectsResponse)
}

inline void StreamedListObjectsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.object_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.object_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.object_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StreamedListObjectsResponse::~StreamedListObjectsResponse() {
  // @@protoc_insertion_point(destructor:openfga.v1.StreamedListObjectsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamedListObjectsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.object_.Destroy();
}

void StreamedListObjectsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamedListObjectsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.StreamedListObjectsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.object_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamedListObjectsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string object = 1 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_object();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.StreamedListObjectsResponse.object"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StreamedListObjectsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.StreamedListObjectsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string object = 1 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_object().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_object().data(), static_cast<int>(this->_internal_object().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.StreamedListObjectsResponse.object");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_object(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.StreamedListObjectsResponse)
  return target;
}

size_t StreamedListObjectsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.StreamedListObjectsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string object = 1 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_object().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_object());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamedListObjectsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamedListObjectsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamedListObjectsResponse::GetClassData() const { return &_class_data_; }


void StreamedListObjectsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamedListObjectsResponse*>(&to_msg);
  auto& from = static_cast<const StreamedListObjectsResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.StreamedListObjectsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_object().empty()) {
    _this->_internal_set_object(from._internal_object());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamedListObjectsResponse::CopyFrom(const StreamedListObjectsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.StreamedListObjectsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamedListObjectsResponse::IsInitialized() const {
  return true;
}

void StreamedListObjectsResponse::InternalSwap(StreamedListObjectsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.object_, lhs_arena,
      &other->_impl_.object_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamedListObjectsResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[5]);
}

// ===================================================================

class ReadRequest::_Internal {
 public:
  static const ::openfga::v1::ReadRequestTupleKey& tuple_key(const ReadRequest* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Int32Value& page_size(const ReadRequest* msg);
};

const ::openfga::v1::ReadRequestTupleKey&
ReadRequest::_Internal::tuple_key(const ReadRequest* msg) {
  return *msg->_impl_.tuple_key_;
}
const ::PROTOBUF_NAMESPACE_ID::Int32Value&
ReadRequest::_Internal::page_size(const ReadRequest* msg) {
  return *msg->_impl_.page_size_;
}
void ReadRequest::clear_page_size() {
  if (GetArenaForAllocation() == nullptr && _impl_.page_size_ != nullptr) {
    delete _impl_.page_size_;
  }
  _impl_.page_size_ = nullptr;
}
ReadRequest::ReadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.ReadRequest)
}
ReadRequest::ReadRequest(const ReadRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReadRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.store_id_){}
    , decltype(_impl_.continuation_token_){}
    , decltype(_impl_.tuple_key_){nullptr}
    , decltype(_impl_.page_size_){nullptr}
    , decltype(_impl_.consistency_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_store_id().empty()) {
    _this->_impl_.store_id_.Set(from._internal_store_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.continuation_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.continuation_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_continuation_token().empty()) {
    _this->_impl_.continuation_token_.Set(from._internal_continuation_token(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_tuple_key()) {
    _this->_impl_.tuple_key_ = new ::openfga::v1::ReadRequestTupleKey(*from._impl_.tuple_key_);
  }
  if (from._internal_has_page_size()) {
    _this->_impl_.page_size_ = new ::PROTOBUF_NAMESPACE_ID::Int32Value(*from._impl_.page_size_);
  }
  _this->_impl_.consistency_ = from._impl_.consistency_;
  // @@protoc_insertion_point(copy_constructor:openfga.v1.ReadRequest)
}

inline void ReadRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.store_id_){}
    , decltype(_impl_.continuation_token_){}
    , decltype(_impl_.tuple_key_){nullptr}
    , decltype(_impl_.page_size_){nullptr}
    , decltype(_impl_.consistency_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.continuation_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.continuation_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReadRequest::~ReadRequest() {
  // @@protoc_insertion_point(destructor:openfga.v1.ReadRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReadRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.store_id_.Destroy();
  _impl_.continuation_token_.Destroy();
  if (this != internal_default_instance()) delete _impl_.tuple_key_;
  if (this != internal_default_instance()) delete _impl_.page_size_;
}

void ReadRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReadRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.ReadRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.store_id_.ClearToEmpty();
  _impl_.continuation_token_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.tuple_key_ != nullptr) {
    delete _impl_.tuple_key_;
  }
  _impl_.tuple_key_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.page_size_ != nullptr) {
    delete _impl_.page_size_;
  }
  _impl_.page_size_ = nullptr;
  _impl_.consistency_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReadRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_store_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ReadRequest.store_id"));
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.ReadRequestTupleKey tuple_key = 2 [json_name = "tuple_key"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_tuple_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Int32Value page_size = 3 [json_name = "page_size", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_page_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string continuation_token = 4 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_continuation_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ReadRequest.continuation_token"));
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.ConsistencyPreference consistency = 5 [json_name = "consistency", (.validate.rules) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_consistency(static_cast<::openfga::v1::ConsistencyPreference>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReadRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.ReadRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_store_id().data(), static_cast<int>(this->_internal_store_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ReadRequest.store_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_store_id(), target);
  }

  // .openfga.v1.ReadRequestTupleKey tuple_key = 2 [json_name = "tuple_key"];
  if (this->_internal_has_tuple_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::tuple_key(this),
        _Internal::tuple_key(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Int32Value page_size = 3 [json_name = "page_size", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (this->_internal_has_page_size()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::page_size(this),
        _Internal::page_size(this).GetCachedSize(), target, stream);
  }

  // string continuation_token = 4 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_continuation_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_continuation_token().data(), static_cast<int>(this->_internal_continuation_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ReadRequest.continuation_token");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_continuation_token(), target);
  }

  // .openfga.v1.ConsistencyPreference consistency = 5 [json_name = "consistency", (.validate.rules) = {
  if (this->_internal_consistency() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_consistency(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.ReadRequest)
  return target;
}

size_t ReadRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.ReadRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_store_id());
  }

  // string continuation_token = 4 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_continuation_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_continuation_token());
  }

  // .openfga.v1.ReadRequestTupleKey tuple_key = 2 [json_name = "tuple_key"];
  if (this->_internal_has_tuple_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tuple_key_);
  }

  // .google.protobuf.Int32Value page_size = 3 [json_name = "page_size", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (this->_internal_has_page_size()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.page_size_);
  }

  // .openfga.v1.ConsistencyPreference consistency = 5 [json_name = "consistency", (.validate.rules) = {
  if (this->_internal_consistency() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_consistency());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReadRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReadRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReadRequest::GetClassData() const { return &_class_data_; }


void ReadRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReadRequest*>(&to_msg);
  auto& from = static_cast<const ReadRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.ReadRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_store_id().empty()) {
    _this->_internal_set_store_id(from._internal_store_id());
  }
  if (!from._internal_continuation_token().empty()) {
    _this->_internal_set_continuation_token(from._internal_continuation_token());
  }
  if (from._internal_has_tuple_key()) {
    _this->_internal_mutable_tuple_key()->::openfga::v1::ReadRequestTupleKey::MergeFrom(
        from._internal_tuple_key());
  }
  if (from._internal_has_page_size()) {
    _this->_internal_mutable_page_size()->::PROTOBUF_NAMESPACE_ID::Int32Value::MergeFrom(
        from._internal_page_size());
  }
  if (from._internal_consistency() != 0) {
    _this->_internal_set_consistency(from._internal_consistency());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReadRequest::CopyFrom(const ReadRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.ReadRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadRequest::IsInitialized() const {
  return true;
}

void ReadRequest::InternalSwap(ReadRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.store_id_, lhs_arena,
      &other->_impl_.store_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.continuation_token_, lhs_arena,
      &other->_impl_.continuation_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReadRequest, _impl_.consistency_)
      + sizeof(ReadRequest::_impl_.consistency_)
      - PROTOBUF_FIELD_OFFSET(ReadRequest, _impl_.tuple_key_)>(
          reinterpret_cast<char*>(&_impl_.tuple_key_),
          reinterpret_cast<char*>(&other->_impl_.tuple_key_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReadRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[6]);
}

// ===================================================================

class ReadRequestTupleKey::_Internal {
 public:
};

ReadRequestTupleKey::ReadRequestTupleKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.ReadRequestTupleKey)
}
ReadRequestTupleKey::ReadRequestTupleKey(const ReadRequestTupleKey& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReadRequestTupleKey* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.user_){}
    , decltype(_impl_.relation_){}
    , decltype(_impl_.object_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user().empty()) {
    _this->_impl_.user_.Set(from._internal_user(), 
      _this->GetArenaForAllocation());
  }
  _impl_.relation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_relation().empty()) {
    _this->_impl_.relation_.Set(from._internal_relation(), 
      _this->GetArenaForAllocation());
  }
  _impl_.object_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.object_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_object().empty()) {
    _this->_impl_.object_.Set(from._internal_object(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.ReadRequestTupleKey)
}

inline void ReadRequestTupleKey::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.user_){}
    , decltype(_impl_.relation_){}
    , decltype(_impl_.object_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.relation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.object_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.object_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReadRequestTupleKey::~ReadRequestTupleKey() {
  // @@protoc_insertion_point(destructor:openfga.v1.ReadRequestTupleKey)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReadRequestTupleKey::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_.Destroy();
  _impl_.relation_.Destroy();
  _impl_.object_.Destroy();
}

void ReadRequestTupleKey::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReadRequestTupleKey::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.ReadRequestTupleKey)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_.ClearToEmpty();
  _impl_.relation_.ClearToEmpty();
  _impl_.object_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReadRequestTupleKey::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string user = 1 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ReadRequestTupleKey.user"));
        } else
          goto handle_unusual;
        continue;
      // string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_relation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ReadRequestTupleKey.relation"));
        } else
          goto handle_unusual;
        continue;
      // string object = 3 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_object();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ReadRequestTupleKey.object"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReadRequestTupleKey::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.ReadRequestTupleKey)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string user = 1 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_user().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user().data(), static_cast<int>(this->_internal_user().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ReadRequestTupleKey.user");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user(), target);
  }

  // string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_relation().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_relation().data(), static_cast<int>(this->_internal_relation().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ReadRequestTupleKey.relation");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_relation(), target);
  }

  // string object = 3 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_object().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_object().data(), static_cast<int>(this->_internal_object().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ReadRequestTupleKey.object");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_object(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.ReadRequestTupleKey)
  return target;
}

size_t ReadRequestTupleKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.ReadRequestTupleKey)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string user = 1 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_user().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user());
  }

  // string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_relation().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_relation());
  }

  // string object = 3 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_object().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_object());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReadRequestTupleKey::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReadRequestTupleKey::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReadRequestTupleKey::GetClassData() const { return &_class_data_; }


void ReadRequestTupleKey::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReadRequestTupleKey*>(&to_msg);
  auto& from = static_cast<const ReadRequestTupleKey&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.ReadRequestTupleKey)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_user().empty()) {
    _this->_internal_set_user(from._internal_user());
  }
  if (!from._internal_relation().empty()) {
    _this->_internal_set_relation(from._internal_relation());
  }
  if (!from._internal_object().empty()) {
    _this->_internal_set_object(from._internal_object());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReadRequestTupleKey::CopyFrom(const ReadRequestTupleKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.ReadRequestTupleKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadRequestTupleKey::IsInitialized() const {
  return true;
}

void ReadRequestTupleKey::InternalSwap(ReadRequestTupleKey* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_, lhs_arena,
      &other->_impl_.user_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.relation_, lhs_arena,
      &other->_impl_.relation_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.object_, lhs_arena,
      &other->_impl_.object_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ReadRequestTupleKey::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[7]);
}

// ===================================================================

class ReadResponse::_Internal {
 public:
};

void ReadResponse::clear_tuples() {
  _impl_.tuples_.Clear();
}
ReadResponse::ReadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.ReadResponse)
}
ReadResponse::ReadResponse(const ReadResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReadResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tuples_){from._impl_.tuples_}
    , decltype(_impl_.continuation_token_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.continuation_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.continuation_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_continuation_token().empty()) {
    _this->_impl_.continuation_token_.Set(from._internal_continuation_token(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.ReadResponse)
}

inline void ReadResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tuples_){arena}
    , decltype(_impl_.continuation_token_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.continuation_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.continuation_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReadResponse::~ReadResponse() {
  // @@protoc_insertion_point(destructor:openfga.v1.ReadResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReadResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tuples_.~RepeatedPtrField();
  _impl_.continuation_token_.Destroy();
}

void ReadResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReadResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.ReadResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tuples_.Clear();
  _impl_.continuation_token_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReadResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .openfga.v1.Tuple tuples = 1 [json_name = "tuples", (.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tuples(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string continuation_token = 2 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_continuation_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ReadResponse.continuation_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReadResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.ReadResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .openfga.v1.Tuple tuples = 1 [json_name = "tuples", (.google.api.field_behavior) = REQUIRED];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tuples_size()); i < n; i++) {
    const auto& repfield = this->_internal_tuples(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string continuation_token = 2 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_continuation_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_continuation_token().data(), static_cast<int>(this->_internal_continuation_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ReadResponse.continuation_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_continuation_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.ReadResponse)
  return target;
}

size_t ReadResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.ReadResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .openfga.v1.Tuple tuples = 1 [json_name = "tuples", (.google.api.field_behavior) = REQUIRED];
  total_size += 1UL * this->_internal_tuples_size();
  for (const auto& msg : this->_impl_.tuples_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string continuation_token = 2 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_continuation_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_continuation_token());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReadResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReadResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReadResponse::GetClassData() const { return &_class_data_; }


void ReadResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReadResponse*>(&to_msg);
  auto& from = static_cast<const ReadResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.ReadResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tuples_.MergeFrom(from._impl_.tuples_);
  if (!from._internal_continuation_token().empty()) {
    _this->_internal_set_continuation_token(from._internal_continuation_token());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReadResponse::CopyFrom(const ReadResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.ReadResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadResponse::IsInitialized() const {
  return true;
}

void ReadResponse::InternalSwap(ReadResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tuples_.InternalSwap(&other->_impl_.tuples_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.continuation_token_, lhs_arena,
      &other->_impl_.continuation_token_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ReadResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[8]);
}

// ===================================================================

class WriteRequestWrites::_Internal {
 public:
};

void WriteRequestWrites::clear_tuple_keys() {
  _impl_.tuple_keys_.Clear();
}
WriteRequestWrites::WriteRequestWrites(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.WriteRequestWrites)
}
WriteRequestWrites::WriteRequestWrites(const WriteRequestWrites& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WriteRequestWrites* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tuple_keys_){from._impl_.tuple_keys_}
    , decltype(_impl_.on_duplicate_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.on_duplicate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.on_duplicate_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_on_duplicate().empty()) {
    _this->_impl_.on_duplicate_.Set(from._internal_on_duplicate(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.WriteRequestWrites)
}

inline void WriteRequestWrites::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tuple_keys_){arena}
    , decltype(_impl_.on_duplicate_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.on_duplicate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.on_duplicate_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WriteRequestWrites::~WriteRequestWrites() {
  // @@protoc_insertion_point(destructor:openfga.v1.WriteRequestWrites)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WriteRequestWrites::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tuple_keys_.~RepeatedPtrField();
  _impl_.on_duplicate_.Destroy();
}

void WriteRequestWrites::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WriteRequestWrites::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.WriteRequestWrites)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tuple_keys_.Clear();
  _impl_.on_duplicate_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WriteRequestWrites::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .openfga.v1.TupleKey tuple_keys = 1 [json_name = "tuple_keys", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tuple_keys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string on_duplicate = 2 [json_name = "on_duplicate", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_on_duplicate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.WriteRequestWrites.on_duplicate"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WriteRequestWrites::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.WriteRequestWrites)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .openfga.v1.TupleKey tuple_keys = 1 [json_name = "tuple_keys", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tuple_keys_size()); i < n; i++) {
    const auto& repfield = this->_internal_tuple_keys(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string on_duplicate = 2 [json_name = "on_duplicate", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_on_duplicate().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_on_duplicate().data(), static_cast<int>(this->_internal_on_duplicate().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.WriteRequestWrites.on_duplicate");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_on_duplicate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.WriteRequestWrites)
  return target;
}

size_t WriteRequestWrites::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.WriteRequestWrites)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .openfga.v1.TupleKey tuple_keys = 1 [json_name = "tuple_keys", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  total_size += 1UL * this->_internal_tuple_keys_size();
  for (const auto& msg : this->_impl_.tuple_keys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string on_duplicate = 2 [json_name = "on_duplicate", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_on_duplicate().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_on_duplicate());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WriteRequestWrites::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WriteRequestWrites::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WriteRequestWrites::GetClassData() const { return &_class_data_; }


void WriteRequestWrites::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WriteRequestWrites*>(&to_msg);
  auto& from = static_cast<const WriteRequestWrites&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.WriteRequestWrites)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tuple_keys_.MergeFrom(from._impl_.tuple_keys_);
  if (!from._internal_on_duplicate().empty()) {
    _this->_internal_set_on_duplicate(from._internal_on_duplicate());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WriteRequestWrites::CopyFrom(const WriteRequestWrites& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.WriteRequestWrites)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WriteRequestWrites::IsInitialized() const {
  return true;
}

void WriteRequestWrites::InternalSwap(WriteRequestWrites* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tuple_keys_.InternalSwap(&other->_impl_.tuple_keys_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.on_duplicate_, lhs_arena,
      &other->_impl_.on_duplicate_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata WriteRequestWrites::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[9]);
}

// ===================================================================

class WriteRequestDeletes::_Internal {
 public:
};

void WriteRequestDeletes::clear_tuple_keys() {
  _impl_.tuple_keys_.Clear();
}
WriteRequestDeletes::WriteRequestDeletes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.WriteRequestDeletes)
}
WriteRequestDeletes::WriteRequestDeletes(const WriteRequestDeletes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WriteRequestDeletes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tuple_keys_){from._impl_.tuple_keys_}
    , decltype(_impl_.on_missing_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.on_missing_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.on_missing_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_on_missing().empty()) {
    _this->_impl_.on_missing_.Set(from._internal_on_missing(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.WriteRequestDeletes)
}

inline void WriteRequestDeletes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tuple_keys_){arena}
    , decltype(_impl_.on_missing_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.on_missing_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.on_missing_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WriteRequestDeletes::~WriteRequestDeletes() {
  // @@protoc_insertion_point(destructor:openfga.v1.WriteRequestDeletes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WriteRequestDeletes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tuple_keys_.~RepeatedPtrField();
  _impl_.on_missing_.Destroy();
}

void WriteRequestDeletes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WriteRequestDeletes::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.WriteRequestDeletes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tuple_keys_.Clear();
  _impl_.on_missing_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WriteRequestDeletes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .openfga.v1.TupleKeyWithoutCondition tuple_keys = 1 [json_name = "tuple_keys", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tuple_keys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string on_missing = 2 [json_name = "on_missing", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_on_missing();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.WriteRequestDeletes.on_missing"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WriteRequestDeletes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.WriteRequestDeletes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .openfga.v1.TupleKeyWithoutCondition tuple_keys = 1 [json_name = "tuple_keys", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tuple_keys_size()); i < n; i++) {
    const auto& repfield = this->_internal_tuple_keys(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string on_missing = 2 [json_name = "on_missing", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_on_missing().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_on_missing().data(), static_cast<int>(this->_internal_on_missing().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.WriteRequestDeletes.on_missing");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_on_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.WriteRequestDeletes)
  return target;
}

size_t WriteRequestDeletes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.WriteRequestDeletes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .openfga.v1.TupleKeyWithoutCondition tuple_keys = 1 [json_name = "tuple_keys", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  total_size += 1UL * this->_internal_tuple_keys_size();
  for (const auto& msg : this->_impl_.tuple_keys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string on_missing = 2 [json_name = "on_missing", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_on_missing().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_on_missing());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WriteRequestDeletes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WriteRequestDeletes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WriteRequestDeletes::GetClassData() const { return &_class_data_; }


void WriteRequestDeletes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WriteRequestDeletes*>(&to_msg);
  auto& from = static_cast<const WriteRequestDeletes&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.WriteRequestDeletes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tuple_keys_.MergeFrom(from._impl_.tuple_keys_);
  if (!from._internal_on_missing().empty()) {
    _this->_internal_set_on_missing(from._internal_on_missing());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WriteRequestDeletes::CopyFrom(const WriteRequestDeletes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.WriteRequestDeletes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WriteRequestDeletes::IsInitialized() const {
  return true;
}

void WriteRequestDeletes::InternalSwap(WriteRequestDeletes* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tuple_keys_.InternalSwap(&other->_impl_.tuple_keys_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.on_missing_, lhs_arena,
      &other->_impl_.on_missing_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata WriteRequestDeletes::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[10]);
}

// ===================================================================

class WriteRequest::_Internal {
 public:
  static const ::openfga::v1::WriteRequestWrites& writes(const WriteRequest* msg);
  static const ::openfga::v1::WriteRequestDeletes& deletes(const WriteRequest* msg);
};

const ::openfga::v1::WriteRequestWrites&
WriteRequest::_Internal::writes(const WriteRequest* msg) {
  return *msg->_impl_.writes_;
}
const ::openfga::v1::WriteRequestDeletes&
WriteRequest::_Internal::deletes(const WriteRequest* msg) {
  return *msg->_impl_.deletes_;
}
WriteRequest::WriteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.WriteRequest)
}
WriteRequest::WriteRequest(const WriteRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WriteRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.store_id_){}
    , decltype(_impl_.authorization_model_id_){}
    , decltype(_impl_.writes_){nullptr}
    , decltype(_impl_.deletes_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_store_id().empty()) {
    _this->_impl_.store_id_.Set(from._internal_store_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.authorization_model_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_authorization_model_id().empty()) {
    _this->_impl_.authorization_model_id_.Set(from._internal_authorization_model_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_writes()) {
    _this->_impl_.writes_ = new ::openfga::v1::WriteRequestWrites(*from._impl_.writes_);
  }
  if (from._internal_has_deletes()) {
    _this->_impl_.deletes_ = new ::openfga::v1::WriteRequestDeletes(*from._impl_.deletes_);
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.WriteRequest)
}

inline void WriteRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.store_id_){}
    , decltype(_impl_.authorization_model_id_){}
    , decltype(_impl_.writes_){nullptr}
    , decltype(_impl_.deletes_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.authorization_model_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WriteRequest::~WriteRequest() {
  // @@protoc_insertion_point(destructor:openfga.v1.WriteRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WriteRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.store_id_.Destroy();
  _impl_.authorization_model_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.writes_;
  if (this != internal_default_instance()) delete _impl_.deletes_;
}

void WriteRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WriteRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.WriteRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.store_id_.ClearToEmpty();
  _impl_.authorization_model_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.writes_ != nullptr) {
    delete _impl_.writes_;
  }
  _impl_.writes_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.deletes_ != nullptr) {
    delete _impl_.deletes_;
  }
  _impl_.deletes_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WriteRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_store_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.WriteRequest.store_id"));
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.WriteRequestWrites writes = 2 [json_name = "writes"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_writes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.WriteRequestDeletes deletes = 3 [json_name = "deletes"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_deletes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string authorization_model_id = 4 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_authorization_model_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.WriteRequest.authorization_model_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WriteRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.WriteRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_store_id().data(), static_cast<int>(this->_internal_store_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.WriteRequest.store_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_store_id(), target);
  }

  // .openfga.v1.WriteRequestWrites writes = 2 [json_name = "writes"];
  if (this->_internal_has_writes()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::writes(this),
        _Internal::writes(this).GetCachedSize(), target, stream);
  }

  // .openfga.v1.WriteRequestDeletes deletes = 3 [json_name = "deletes"];
  if (this->_internal_has_deletes()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::deletes(this),
        _Internal::deletes(this).GetCachedSize(), target, stream);
  }

  // string authorization_model_id = 4 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_authorization_model_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_authorization_model_id().data(), static_cast<int>(this->_internal_authorization_model_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.WriteRequest.authorization_model_id");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_authorization_model_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.WriteRequest)
  return target;
}

size_t WriteRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.WriteRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_store_id());
  }

  // string authorization_model_id = 4 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_authorization_model_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_authorization_model_id());
  }

  // .openfga.v1.WriteRequestWrites writes = 2 [json_name = "writes"];
  if (this->_internal_has_writes()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.writes_);
  }

  // .openfga.v1.WriteRequestDeletes deletes = 3 [json_name = "deletes"];
  if (this->_internal_has_deletes()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.deletes_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WriteRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WriteRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WriteRequest::GetClassData() const { return &_class_data_; }


void WriteRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WriteRequest*>(&to_msg);
  auto& from = static_cast<const WriteRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.WriteRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_store_id().empty()) {
    _this->_internal_set_store_id(from._internal_store_id());
  }
  if (!from._internal_authorization_model_id().empty()) {
    _this->_internal_set_authorization_model_id(from._internal_authorization_model_id());
  }
  if (from._internal_has_writes()) {
    _this->_internal_mutable_writes()->::openfga::v1::WriteRequestWrites::MergeFrom(
        from._internal_writes());
  }
  if (from._internal_has_deletes()) {
    _this->_internal_mutable_deletes()->::openfga::v1::WriteRequestDeletes::MergeFrom(
        from._internal_deletes());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WriteRequest::CopyFrom(const WriteRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.WriteRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WriteRequest::IsInitialized() const {
  return true;
}

void WriteRequest::InternalSwap(WriteRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.store_id_, lhs_arena,
      &other->_impl_.store_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.authorization_model_id_, lhs_arena,
      &other->_impl_.authorization_model_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WriteRequest, _impl_.deletes_)
      + sizeof(WriteRequest::_impl_.deletes_)
      - PROTOBUF_FIELD_OFFSET(WriteRequest, _impl_.writes_)>(
          reinterpret_cast<char*>(&_impl_.writes_),
          reinterpret_cast<char*>(&other->_impl_.writes_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WriteRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[11]);
}

// ===================================================================

class WriteResponse::_Internal {
 public:
};

WriteResponse::WriteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:openfga.v1.WriteResponse)
}
WriteResponse::WriteResponse(const WriteResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  WriteResponse* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:openfga.v1.WriteResponse)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WriteResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WriteResponse::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata WriteResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[12]);
}

// ===================================================================

class CheckRequest::_Internal {
 public:
  static const ::openfga::v1::CheckRequestTupleKey& tuple_key(const CheckRequest* msg);
  static const ::openfga::v1::ContextualTupleKeys& contextual_tuples(const CheckRequest* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Struct& context(const CheckRequest* msg);
};

const ::openfga::v1::CheckRequestTupleKey&
CheckRequest::_Internal::tuple_key(const CheckRequest* msg) {
  return *msg->_impl_.tuple_key_;
}
const ::openfga::v1::ContextualTupleKeys&
CheckRequest::_Internal::contextual_tuples(const CheckRequest* msg) {
  return *msg->_impl_.contextual_tuples_;
}
const ::PROTOBUF_NAMESPACE_ID::Struct&
CheckRequest::_Internal::context(const CheckRequest* msg) {
  return *msg->_impl_.context_;
}
void CheckRequest::clear_contextual_tuples() {
  if (GetArenaForAllocation() == nullptr && _impl_.contextual_tuples_ != nullptr) {
    delete _impl_.contextual_tuples_;
  }
  _impl_.contextual_tuples_ = nullptr;
}
void CheckRequest::clear_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
    delete _impl_.context_;
  }
  _impl_.context_ = nullptr;
}
CheckRequest::CheckRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.CheckRequest)
}
CheckRequest::CheckRequest(const CheckRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CheckRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.store_id_){}
    , decltype(_impl_.authorization_model_id_){}
    , decltype(_impl_.tuple_key_){nullptr}
    , decltype(_impl_.contextual_tuples_){nullptr}
    , decltype(_impl_.context_){nullptr}
    , decltype(_impl_.trace_){}
    , decltype(_impl_.consistency_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_store_id().empty()) {
    _this->_impl_.store_id_.Set(from._internal_store_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.authorization_model_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_authorization_model_id().empty()) {
    _this->_impl_.authorization_model_id_.Set(from._internal_authorization_model_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_tuple_key()) {
    _this->_impl_.tuple_key_ = new ::openfga::v1::CheckRequestTupleKey(*from._impl_.tuple_key_);
  }
  if (from._internal_has_contextual_tuples()) {
    _this->_impl_.contextual_tuples_ = new ::openfga::v1::ContextualTupleKeys(*from._impl_.contextual_tuples_);
  }
  if (from._internal_has_context()) {
    _this->_impl_.context_ = new ::PROTOBUF_NAMESPACE_ID::Struct(*from._impl_.context_);
  }
  ::memcpy(&_impl_.trace_, &from._impl_.trace_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.consistency_) -
    reinterpret_cast<char*>(&_impl_.trace_)) + sizeof(_impl_.consistency_));
  // @@protoc_insertion_point(copy_constructor:openfga.v1.CheckRequest)
}

inline void CheckRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.store_id_){}
    , decltype(_impl_.authorization_model_id_){}
    , decltype(_impl_.tuple_key_){nullptr}
    , decltype(_impl_.contextual_tuples_){nullptr}
    , decltype(_impl_.context_){nullptr}
    , decltype(_impl_.trace_){false}
    , decltype(_impl_.consistency_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.authorization_model_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CheckRequest::~CheckRequest() {
  // @@protoc_insertion_point(destructor:openfga.v1.CheckRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CheckRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.store_id_.Destroy();
  _impl_.authorization_model_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.tuple_key_;
  if (this != internal_default_instance()) delete _impl_.contextual_tuples_;
  if (this != internal_default_instance()) delete _impl_.context_;
}

void CheckRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CheckRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.CheckRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.store_id_.ClearToEmpty();
  _impl_.authorization_model_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.tuple_key_ != nullptr) {
    delete _impl_.tuple_key_;
  }
  _impl_.tuple_key_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.contextual_tuples_ != nullptr) {
    delete _impl_.contextual_tuples_;
  }
  _impl_.contextual_tuples_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
    delete _impl_.context_;
  }
  _impl_.context_ = nullptr;
  ::memset(&_impl_.trace_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.consistency_) -
      reinterpret_cast<char*>(&_impl_.trace_)) + sizeof(_impl_.consistency_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CheckRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_store_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.CheckRequest.store_id"));
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.CheckRequestTupleKey tuple_key = 2 [json_name = "tuple_key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_tuple_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.ContextualTupleKeys contextual_tuples = 3 [json_name = "contextual_tuples"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_contextual_tuples(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string authorization_model_id = 4 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_authorization_model_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.CheckRequest.authorization_model_id"));
        } else
          goto handle_unusual;
        continue;
      // bool trace = 5 [json_name = "trace", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.trace_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Struct context = 6 [json_name = "context"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_context(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.ConsistencyPreference consistency = 7 [json_name = "consistency", (.validate.rules) = {
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_consistency(static_cast<::openfga::v1::ConsistencyPreference>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CheckRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.CheckRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_store_id().data(), static_cast<int>(this->_internal_store_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.CheckRequest.store_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_store_id(), target);
  }

  // .openfga.v1.CheckRequestTupleKey tuple_key = 2 [json_name = "tuple_key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (this->_internal_has_tuple_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::tuple_key(this),
        _Internal::tuple_key(this).GetCachedSize(), target, stream);
  }

  // .openfga.v1.ContextualTupleKeys contextual_tuples = 3 [json_name = "contextual_tuples"];
  if (this->_internal_has_contextual_tuples()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::contextual_tuples(this),
        _Internal::contextual_tuples(this).GetCachedSize(), target, stream);
  }

  // string authorization_model_id = 4 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_authorization_model_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_authorization_model_id().data(), static_cast<int>(this->_internal_authorization_model_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.CheckRequest.authorization_model_id");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_authorization_model_id(), target);
  }

  // bool trace = 5 [json_name = "trace", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (this->_internal_trace() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_trace(), target);
  }

  // .google.protobuf.Struct context = 6 [json_name = "context"];
  if (this->_internal_has_context()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::context(this),
        _Internal::context(this).GetCachedSize(), target, stream);
  }

  // .openfga.v1.ConsistencyPreference consistency = 7 [json_name = "consistency", (.validate.rules) = {
  if (this->_internal_consistency() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_consistency(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.CheckRequest)
  return target;
}

size_t CheckRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.CheckRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_store_id());
  }

  // string authorization_model_id = 4 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_authorization_model_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_authorization_model_id());
  }

  // .openfga.v1.CheckRequestTupleKey tuple_key = 2 [json_name = "tuple_key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (this->_internal_has_tuple_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tuple_key_);
  }

  // .openfga.v1.ContextualTupleKeys contextual_tuples = 3 [json_name = "contextual_tuples"];
  if (this->_internal_has_contextual_tuples()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.contextual_tuples_);
  }

  // .google.protobuf.Struct context = 6 [json_name = "context"];
  if (this->_internal_has_context()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.context_);
  }

  // bool trace = 5 [json_name = "trace", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (this->_internal_trace() != 0) {
    total_size += 1 + 1;
  }

  // .openfga.v1.ConsistencyPreference consistency = 7 [json_name = "consistency", (.validate.rules) = {
  if (this->_internal_consistency() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_consistency());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CheckRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CheckRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CheckRequest::GetClassData() const { return &_class_data_; }


void CheckRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CheckRequest*>(&to_msg);
  auto& from = static_cast<const CheckRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.CheckRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_store_id().empty()) {
    _this->_internal_set_store_id(from._internal_store_id());
  }
  if (!from._internal_authorization_model_id().empty()) {
    _this->_internal_set_authorization_model_id(from._internal_authorization_model_id());
  }
  if (from._internal_has_tuple_key()) {
    _this->_internal_mutable_tuple_key()->::openfga::v1::CheckRequestTupleKey::MergeFrom(
        from._internal_tuple_key());
  }
  if (from._internal_has_contextual_tuples()) {
    _this->_internal_mutable_contextual_tuples()->::openfga::v1::ContextualTupleKeys::MergeFrom(
        from._internal_contextual_tuples());
  }
  if (from._internal_has_context()) {
    _this->_internal_mutable_context()->::PROTOBUF_NAMESPACE_ID::Struct::MergeFrom(
        from._internal_context());
  }
  if (from._internal_trace() != 0) {
    _this->_internal_set_trace(from._internal_trace());
  }
  if (from._internal_consistency() != 0) {
    _this->_internal_set_consistency(from._internal_consistency());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CheckRequest::CopyFrom(const CheckRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.CheckRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckRequest::IsInitialized() const {
  return true;
}

void CheckRequest::InternalSwap(CheckRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.store_id_, lhs_arena,
      &other->_impl_.store_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.authorization_model_id_, lhs_arena,
      &other->_impl_.authorization_model_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CheckRequest, _impl_.consistency_)
      + sizeof(CheckRequest::_impl_.consistency_)
      - PROTOBUF_FIELD_OFFSET(CheckRequest, _impl_.tuple_key_)>(
          reinterpret_cast<char*>(&_impl_.tuple_key_),
          reinterpret_cast<char*>(&other->_impl_.tuple_key_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CheckRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[13]);
}

// ===================================================================

class CheckRequestTupleKey::_Internal {
 public:
};

CheckRequestTupleKey::CheckRequestTupleKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.CheckRequestTupleKey)
}
CheckRequestTupleKey::CheckRequestTupleKey(const CheckRequestTupleKey& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CheckRequestTupleKey* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.user_){}
    , decltype(_impl_.relation_){}
    , decltype(_impl_.object_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user().empty()) {
    _this->_impl_.user_.Set(from._internal_user(), 
      _this->GetArenaForAllocation());
  }
  _impl_.relation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_relation().empty()) {
    _this->_impl_.relation_.Set(from._internal_relation(), 
      _this->GetArenaForAllocation());
  }
  _impl_.object_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.object_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_object().empty()) {
    _this->_impl_.object_.Set(from._internal_object(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.CheckRequestTupleKey)
}

inline void CheckRequestTupleKey::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.user_){}
    , decltype(_impl_.relation_){}
    , decltype(_impl_.object_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.relation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.object_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.object_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CheckRequestTupleKey::~CheckRequestTupleKey() {
  // @@protoc_insertion_point(destructor:openfga.v1.CheckRequestTupleKey)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CheckRequestTupleKey::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_.Destroy();
  _impl_.relation_.Destroy();
  _impl_.object_.Destroy();
}

void CheckRequestTupleKey::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CheckRequestTupleKey::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.CheckRequestTupleKey)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_.ClearToEmpty();
  _impl_.relation_.ClearToEmpty();
  _impl_.object_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CheckRequestTupleKey::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string user = 1 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.CheckRequestTupleKey.user"));
        } else
          goto handle_unusual;
        continue;
      // string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_relation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.CheckRequestTupleKey.relation"));
        } else
          goto handle_unusual;
        continue;
      // string object = 3 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_object();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.CheckRequestTupleKey.object"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CheckRequestTupleKey::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.CheckRequestTupleKey)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string user = 1 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_user().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user().data(), static_cast<int>(this->_internal_user().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.CheckRequestTupleKey.user");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user(), target);
  }

  // string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_relation().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_relation().data(), static_cast<int>(this->_internal_relation().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.CheckRequestTupleKey.relation");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_relation(), target);
  }

  // string object = 3 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_object().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_object().data(), static_cast<int>(this->_internal_object().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.CheckRequestTupleKey.object");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_object(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.CheckRequestTupleKey)
  return target;
}

size_t CheckRequestTupleKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.CheckRequestTupleKey)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string user = 1 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_user().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user());
  }

  // string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_relation().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_relation());
  }

  // string object = 3 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_object().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_object());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CheckRequestTupleKey::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CheckRequestTupleKey::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CheckRequestTupleKey::GetClassData() const { return &_class_data_; }


void CheckRequestTupleKey::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CheckRequestTupleKey*>(&to_msg);
  auto& from = static_cast<const CheckRequestTupleKey&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.CheckRequestTupleKey)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_user().empty()) {
    _this->_internal_set_user(from._internal_user());
  }
  if (!from._internal_relation().empty()) {
    _this->_internal_set_relation(from._internal_relation());
  }
  if (!from._internal_object().empty()) {
    _this->_internal_set_object(from._internal_object());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CheckRequestTupleKey::CopyFrom(const CheckRequestTupleKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.CheckRequestTupleKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckRequestTupleKey::IsInitialized() const {
  return true;
}

void CheckRequestTupleKey::InternalSwap(CheckRequestTupleKey* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_, lhs_arena,
      &other->_impl_.user_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.relation_, lhs_arena,
      &other->_impl_.relation_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.object_, lhs_arena,
      &other->_impl_.object_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CheckRequestTupleKey::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[14]);
}

// ===================================================================

class CheckResponse::_Internal {
 public:
};

CheckResponse::CheckResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.CheckResponse)
}
CheckResponse::CheckResponse(const CheckResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CheckResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.resolution_){}
    , decltype(_impl_.allowed_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.resolution_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resolution_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_resolution().empty()) {
    _this->_impl_.resolution_.Set(from._internal_resolution(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.allowed_ = from._impl_.allowed_;
  // @@protoc_insertion_point(copy_constructor:openfga.v1.CheckResponse)
}

inline void CheckResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.resolution_){}
    , decltype(_impl_.allowed_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.resolution_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resolution_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CheckResponse::~CheckResponse() {
  // @@protoc_insertion_point(destructor:openfga.v1.CheckResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CheckResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.resolution_.Destroy();
}

void CheckResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CheckResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.CheckResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.resolution_.ClearToEmpty();
  _impl_.allowed_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CheckResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool allowed = 1 [json_name = "allowed", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.allowed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string resolution = 2 [json_name = "resolution"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_resolution();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.CheckResponse.resolution"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CheckResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.CheckResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool allowed = 1 [json_name = "allowed", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (this->_internal_allowed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_allowed(), target);
  }

  // string resolution = 2 [json_name = "resolution"];
  if (!this->_internal_resolution().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_resolution().data(), static_cast<int>(this->_internal_resolution().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.CheckResponse.resolution");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_resolution(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.CheckResponse)
  return target;
}

size_t CheckResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.CheckResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string resolution = 2 [json_name = "resolution"];
  if (!this->_internal_resolution().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_resolution());
  }

  // bool allowed = 1 [json_name = "allowed", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (this->_internal_allowed() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CheckResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CheckResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CheckResponse::GetClassData() const { return &_class_data_; }


void CheckResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CheckResponse*>(&to_msg);
  auto& from = static_cast<const CheckResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.CheckResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_resolution().empty()) {
    _this->_internal_set_resolution(from._internal_resolution());
  }
  if (from._internal_allowed() != 0) {
    _this->_internal_set_allowed(from._internal_allowed());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CheckResponse::CopyFrom(const CheckResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.CheckResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckResponse::IsInitialized() const {
  return true;
}

void CheckResponse::InternalSwap(CheckResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.resolution_, lhs_arena,
      &other->_impl_.resolution_, rhs_arena
  );
  swap(_impl_.allowed_, other->_impl_.allowed_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CheckResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[15]);
}

// ===================================================================

class BatchCheckRequest::_Internal {
 public:
};

BatchCheckRequest::BatchCheckRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.BatchCheckRequest)
}
BatchCheckRequest::BatchCheckRequest(const BatchCheckRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BatchCheckRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.checks_){from._impl_.checks_}
    , decltype(_impl_.store_id_){}
    , decltype(_impl_.authorization_model_id_){}
    , decltype(_impl_.consistency_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_store_id().empty()) {
    _this->_impl_.store_id_.Set(from._internal_store_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.authorization_model_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_authorization_model_id().empty()) {
    _this->_impl_.authorization_model_id_.Set(from._internal_authorization_model_id(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.consistency_ = from._impl_.consistency_;
  // @@protoc_insertion_point(copy_constructor:openfga.v1.BatchCheckRequest)
}

inline void BatchCheckRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.checks_){arena}
    , decltype(_impl_.store_id_){}
    , decltype(_impl_.authorization_model_id_){}
    , decltype(_impl_.consistency_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.authorization_model_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BatchCheckRequest::~BatchCheckRequest() {
  // @@protoc_insertion_point(destructor:openfga.v1.BatchCheckRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchCheckRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.checks_.~RepeatedPtrField();
  _impl_.store_id_.Destroy();
  _impl_.authorization_model_id_.Destroy();
}

void BatchCheckRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchCheckRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.BatchCheckRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.checks_.Clear();
  _impl_.store_id_.ClearToEmpty();
  _impl_.authorization_model_id_.ClearToEmpty();
  _impl_.consistency_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchCheckRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_store_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.BatchCheckRequest.store_id"));
        } else
          goto handle_unusual;
        continue;
      // repeated .openfga.v1.BatchCheckItem checks = 2 [json_name = "checks", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_checks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string authorization_model_id = 3 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_authorization_model_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.BatchCheckRequest.authorization_model_id"));
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.ConsistencyPreference consistency = 4 [json_name = "consistency", (.validate.rules) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_consistency(static_cast<::openfga::v1::ConsistencyPreference>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BatchCheckRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.BatchCheckRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_store_id().data(), static_cast<int>(this->_internal_store_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.BatchCheckRequest.store_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_store_id(), target);
  }

  // repeated .openfga.v1.BatchCheckItem checks = 2 [json_name = "checks", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_checks_size()); i < n; i++) {
    const auto& repfield = this->_internal_checks(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string authorization_model_id = 3 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_authorization_model_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_authorization_model_id().data(), static_cast<int>(this->_internal_authorization_model_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.BatchCheckRequest.authorization_model_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_authorization_model_id(), target);
  }

  // .openfga.v1.ConsistencyPreference consistency = 4 [json_name = "consistency", (.validate.rules) = {
  if (this->_internal_consistency() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_consistency(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.BatchCheckRequest)
  return target;
}

size_t BatchCheckRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.BatchCheckRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .openfga.v1.BatchCheckItem checks = 2 [json_name = "checks", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  total_size += 1UL * this->_internal_checks_size();
  for (const auto& msg : this->_impl_.checks_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_store_id());
  }

  // string authorization_model_id = 3 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_authorization_model_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_authorization_model_id());
  }

  // .openfga.v1.ConsistencyPreference consistency = 4 [json_name = "consistency", (.validate.rules) = {
  if (this->_internal_consistency() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_consistency());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchCheckRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BatchCheckRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchCheckRequest::GetClassData() const { return &_class_data_; }


void BatchCheckRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BatchCheckRequest*>(&to_msg);
  auto& from = static_cast<const BatchCheckRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.BatchCheckRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.checks_.MergeFrom(from._impl_.checks_);
  if (!from._internal_store_id().empty()) {
    _this->_internal_set_store_id(from._internal_store_id());
  }
  if (!from._internal_authorization_model_id().empty()) {
    _this->_internal_set_authorization_model_id(from._internal_authorization_model_id());
  }
  if (from._internal_consistency() != 0) {
    _this->_internal_set_consistency(from._internal_consistency());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchCheckRequest::CopyFrom(const BatchCheckRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.BatchCheckRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchCheckRequest::IsInitialized() const {
  return true;
}

void BatchCheckRequest::InternalSwap(BatchCheckRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.checks_.InternalSwap(&other->_impl_.checks_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.store_id_, lhs_arena,
      &other->_impl_.store_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.authorization_model_id_, lhs_arena,
      &other->_impl_.authorization_model_id_, rhs_arena
  );
  swap(_impl_.consistency_, other->_impl_.consistency_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchCheckRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[16]);
}

// ===================================================================

class BatchCheckItem::_Internal {
 public:
  static const ::openfga::v1::CheckRequestTupleKey& tuple_key(const BatchCheckItem* msg);
  static const ::openfga::v1::ContextualTupleKeys& contextual_tuples(const BatchCheckItem* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Struct& context(const BatchCheckItem* msg);
};

const ::openfga::v1::CheckRequestTupleKey&
BatchCheckItem::_Internal::tuple_key(const BatchCheckItem* msg) {
  return *msg->_impl_.tuple_key_;
}
const ::openfga::v1::ContextualTupleKeys&
BatchCheckItem::_Internal::contextual_tuples(const BatchCheckItem* msg) {
  return *msg->_impl_.contextual_tuples_;
}
const ::PROTOBUF_NAMESPACE_ID::Struct&
BatchCheckItem::_Internal::context(const BatchCheckItem* msg) {
  return *msg->_impl_.context_;
}
void BatchCheckItem::clear_contextual_tuples() {
  if (GetArenaForAllocation() == nullptr && _impl_.contextual_tuples_ != nullptr) {
    delete _impl_.contextual_tuples_;
  }
  _impl_.contextual_tuples_ = nullptr;
}
void BatchCheckItem::clear_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
    delete _impl_.context_;
  }
  _impl_.context_ = nullptr;
}
BatchCheckItem::BatchCheckItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.BatchCheckItem)
}
BatchCheckItem::BatchCheckItem(const BatchCheckItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BatchCheckItem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.correlation_id_){}
    , decltype(_impl_.tuple_key_){nullptr}
    , decltype(_impl_.contextual_tuples_){nullptr}
    , decltype(_impl_.context_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.correlation_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.correlation_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_correlation_id().empty()) {
    _this->_impl_.correlation_id_.Set(from._internal_correlation_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_tuple_key()) {
    _this->_impl_.tuple_key_ = new ::openfga::v1::CheckRequestTupleKey(*from._impl_.tuple_key_);
  }
  if (from._internal_has_contextual_tuples()) {
    _this->_impl_.contextual_tuples_ = new ::openfga::v1::ContextualTupleKeys(*from._impl_.contextual_tuples_);
  }
  if (from._internal_has_context()) {
    _this->_impl_.context_ = new ::PROTOBUF_NAMESPACE_ID::Struct(*from._impl_.context_);
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.BatchCheckItem)
}

inline void BatchCheckItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.correlation_id_){}
    , decltype(_impl_.tuple_key_){nullptr}
    , decltype(_impl_.contextual_tuples_){nullptr}
    , decltype(_impl_.context_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.correlation_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.correlation_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BatchCheckItem::~BatchCheckItem() {
  // @@protoc_insertion_point(destructor:openfga.v1.BatchCheckItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchCheckItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.correlation_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.tuple_key_;
  if (this != internal_default_instance()) delete _impl_.contextual_tuples_;
  if (this != internal_default_instance()) delete _impl_.context_;
}

void BatchCheckItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchCheckItem::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.BatchCheckItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.correlation_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.tuple_key_ != nullptr) {
    delete _impl_.tuple_key_;
  }
  _impl_.tuple_key_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.contextual_tuples_ != nullptr) {
    delete _impl_.contextual_tuples_;
  }
  _impl_.contextual_tuples_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
    delete _impl_.context_;
  }
  _impl_.context_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchCheckItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .openfga.v1.CheckRequestTupleKey tuple_key = 1 [json_name = "tuple_key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_tuple_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.ContextualTupleKeys contextual_tuples = 2 [json_name = "contextual_tuples"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_contextual_tuples(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Struct context = 3 [json_name = "context"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_context(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string correlation_id = 4 [json_name = "correlation_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_correlation_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.BatchCheckItem.correlation_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BatchCheckItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.BatchCheckItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .openfga.v1.CheckRequestTupleKey tuple_key = 1 [json_name = "tuple_key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (this->_internal_has_tuple_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::tuple_key(this),
        _Internal::tuple_key(this).GetCachedSize(), target, stream);
  }

  // .openfga.v1.ContextualTupleKeys contextual_tuples = 2 [json_name = "contextual_tuples"];
  if (this->_internal_has_contextual_tuples()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::contextual_tuples(this),
        _Internal::contextual_tuples(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Struct context = 3 [json_name = "context"];
  if (this->_internal_has_context()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::context(this),
        _Internal::context(this).GetCachedSize(), target, stream);
  }

  // string correlation_id = 4 [json_name = "correlation_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_correlation_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_correlation_id().data(), static_cast<int>(this->_internal_correlation_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.BatchCheckItem.correlation_id");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_correlation_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.BatchCheckItem)
  return target;
}

size_t BatchCheckItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.BatchCheckItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string correlation_id = 4 [json_name = "correlation_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_correlation_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_correlation_id());
  }

  // .openfga.v1.CheckRequestTupleKey tuple_key = 1 [json_name = "tuple_key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (this->_internal_has_tuple_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tuple_key_);
  }

  // .openfga.v1.ContextualTupleKeys contextual_tuples = 2 [json_name = "contextual_tuples"];
  if (this->_internal_has_contextual_tuples()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.contextual_tuples_);
  }

  // .google.protobuf.Struct context = 3 [json_name = "context"];
  if (this->_internal_has_context()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.context_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchCheckItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BatchCheckItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchCheckItem::GetClassData() const { return &_class_data_; }


void BatchCheckItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BatchCheckItem*>(&to_msg);
  auto& from = static_cast<const BatchCheckItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.BatchCheckItem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_correlation_id().empty()) {
    _this->_internal_set_correlation_id(from._internal_correlation_id());
  }
  if (from._internal_has_tuple_key()) {
    _this->_internal_mutable_tuple_key()->::openfga::v1::CheckRequestTupleKey::MergeFrom(
        from._internal_tuple_key());
  }
  if (from._internal_has_contextual_tuples()) {
    _this->_internal_mutable_contextual_tuples()->::openfga::v1::ContextualTupleKeys::MergeFrom(
        from._internal_contextual_tuples());
  }
  if (from._internal_has_context()) {
    _this->_internal_mutable_context()->::PROTOBUF_NAMESPACE_ID::Struct::MergeFrom(
        from._internal_context());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchCheckItem::CopyFrom(const BatchCheckItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.BatchCheckItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchCheckItem::IsInitialized() const {
  return true;
}

void BatchCheckItem::InternalSwap(BatchCheckItem* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.correlation_id_, lhs_arena,
      &other->_impl_.correlation_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BatchCheckItem, _impl_.context_)
      + sizeof(BatchCheckItem::_impl_.context_)
      - PROTOBUF_FIELD_OFFSET(BatchCheckItem, _impl_.tuple_key_)>(
          reinterpret_cast<char*>(&_impl_.tuple_key_),
          reinterpret_cast<char*>(&other->_impl_.tuple_key_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchCheckItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[17]);
}

// ===================================================================

BatchCheckResponse_ResultEntry_DoNotUse::BatchCheckResponse_ResultEntry_DoNotUse() {}
BatchCheckResponse_ResultEntry_DoNotUse::BatchCheckResponse_ResultEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void BatchCheckResponse_ResultEntry_DoNotUse::MergeFrom(const BatchCheckResponse_ResultEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata BatchCheckResponse_ResultEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[18]);
}

// ===================================================================

class BatchCheckResponse::_Internal {
 public:
};

BatchCheckResponse::BatchCheckResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &BatchCheckResponse::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:openfga.v1.BatchCheckResponse)
}
BatchCheckResponse::BatchCheckResponse(const BatchCheckResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BatchCheckResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.result_)*/{}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.result_.MergeFrom(from._impl_.result_);
  // @@protoc_insertion_point(copy_constructor:openfga.v1.BatchCheckResponse)
}

inline void BatchCheckResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.result_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BatchCheckResponse::~BatchCheckResponse() {
  // @@protoc_insertion_point(destructor:openfga.v1.BatchCheckResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void BatchCheckResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.result_.Destruct();
  _impl_.result_.~MapField();
}

void BatchCheckResponse::ArenaDtor(void* object) {
  BatchCheckResponse* _this = reinterpret_cast< BatchCheckResponse* >(object);
  _this->_impl_.result_.Destruct();
}
void BatchCheckResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchCheckResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.BatchCheckResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.result_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchCheckResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, .openfga.v1.BatchCheckSingleResult> result = 1 [json_name = "result", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.result_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BatchCheckResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.BatchCheckResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, .openfga.v1.BatchCheckSingleResult> result = 1 [json_name = "result", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_result().empty()) {
    using MapType = ::_pb::Map<std::string, ::openfga::v1::BatchCheckSingleResult>;
    using WireHelper = BatchCheckResponse_ResultEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_result();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "openfga.v1.BatchCheckResponse.ResultEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.BatchCheckResponse)
  return target;
}

size_t BatchCheckResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.BatchCheckResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .openfga.v1.BatchCheckSingleResult> result = 1 [json_name = "result", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_result_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::BatchCheckSingleResult >::const_iterator
      it = this->_internal_result().begin();
      it != this->_internal_result().end(); ++it) {
    total_size += BatchCheckResponse_ResultEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchCheckResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BatchCheckResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchCheckResponse::GetClassData() const { return &_class_data_; }


void BatchCheckResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BatchCheckResponse*>(&to_msg);
  auto& from = static_cast<const BatchCheckResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.BatchCheckResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.result_.MergeFrom(from._impl_.result_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchCheckResponse::CopyFrom(const BatchCheckResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.BatchCheckResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchCheckResponse::IsInitialized() const {
  return true;
}

void BatchCheckResponse::InternalSwap(BatchCheckResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.result_.InternalSwap(&other->_impl_.result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchCheckResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[19]);
}

// ===================================================================

class BatchCheckSingleResult::_Internal {
 public:
  static const ::openfga::v1::CheckError& error(const BatchCheckSingleResult* msg);
};

const ::openfga::v1::CheckError&
BatchCheckSingleResult::_Internal::error(const BatchCheckSingleResult* msg) {
  return *msg->_impl_.check_result_.error_;
}
void BatchCheckSingleResult::set_allocated_error(::openfga::v1::CheckError* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_check_result();
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    set_has_error();
    _impl_.check_result_.error_ = error;
  }
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.BatchCheckSingleResult.error)
}
BatchCheckSingleResult::BatchCheckSingleResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.BatchCheckSingleResult)
}
BatchCheckSingleResult::BatchCheckSingleResult(const BatchCheckSingleResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BatchCheckSingleResult* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.check_result_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_check_result();
  switch (from.check_result_case()) {
    case kAllowed: {
      _this->_internal_set_allowed(from._internal_allowed());
      break;
    }
    case kError: {
      _this->_internal_mutable_error()->::openfga::v1::CheckError::MergeFrom(
          from._internal_error());
      break;
    }
    case CHECK_RESULT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.BatchCheckSingleResult)
}

inline void BatchCheckSingleResult::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.check_result_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_check_result();
}

BatchCheckSingleResult::~BatchCheckSingleResult() {
  // @@protoc_insertion_point(destructor:openfga.v1.BatchCheckSingleResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchCheckSingleResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_check_result()) {
    clear_check_result();
  }
}

void BatchCheckSingleResult::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchCheckSingleResult::clear_check_result() {
// @@protoc_insertion_point(one_of_clear_start:openfga.v1.BatchCheckSingleResult)
  switch (check_result_case()) {
    case kAllowed: {
      // No need to clear
      break;
    }
    case kError: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.check_result_.error_;
      }
      break;
    }
    case CHECK_RESULT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = CHECK_RESULT_NOT_SET;
}


void BatchCheckSingleResult::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.BatchCheckSingleResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_check_result();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchCheckSingleResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool allowed = 1 [json_name = "allowed"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_allowed(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.CheckError error = 2 [json_name = "error"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_error(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BatchCheckSingleResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.BatchCheckSingleResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool allowed = 1 [json_name = "allowed"];
  if (_internal_has_allowed()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_allowed(), target);
  }

  // .openfga.v1.CheckError error = 2 [json_name = "error"];
  if (_internal_has_error()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::error(this),
        _Internal::error(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.BatchCheckSingleResult)
  return target;
}

size_t BatchCheckSingleResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.BatchCheckSingleResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (check_result_case()) {
    // bool allowed = 1 [json_name = "allowed"];
    case kAllowed: {
      total_size += 1 + 1;
      break;
    }
    // .openfga.v1.CheckError error = 2 [json_name = "error"];
    case kError: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.check_result_.error_);
      break;
    }
    case CHECK_RESULT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchCheckSingleResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BatchCheckSingleResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchCheckSingleResult::GetClassData() const { return &_class_data_; }


void BatchCheckSingleResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BatchCheckSingleResult*>(&to_msg);
  auto& from = static_cast<const BatchCheckSingleResult&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.BatchCheckSingleResult)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.check_result_case()) {
    case kAllowed: {
      _this->_internal_set_allowed(from._internal_allowed());
      break;
    }
    case kError: {
      _this->_internal_mutable_error()->::openfga::v1::CheckError::MergeFrom(
          from._internal_error());
      break;
    }
    case CHECK_RESULT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchCheckSingleResult::CopyFrom(const BatchCheckSingleResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.BatchCheckSingleResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchCheckSingleResult::IsInitialized() const {
  return true;
}

void BatchCheckSingleResult::InternalSwap(BatchCheckSingleResult* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.check_result_, other->_impl_.check_result_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchCheckSingleResult::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[20]);
}

// ===================================================================

class CheckError::_Internal {
 public:
};

CheckError::CheckError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.CheckError)
}
CheckError::CheckError(const CheckError& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CheckError* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , decltype(_impl_.code_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_message().empty()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  clear_has_code();
  switch (from.code_case()) {
    case kInputError: {
      _this->_internal_set_input_error(from._internal_input_error());
      break;
    }
    case kInternalError: {
      _this->_internal_set_internal_error(from._internal_internal_error());
      break;
    }
    case CODE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.CheckError)
}

inline void CheckError::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , decltype(_impl_.code_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_code();
}

CheckError::~CheckError() {
  // @@protoc_insertion_point(destructor:openfga.v1.CheckError)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CheckError::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
  if (has_code()) {
    clear_code();
  }
}

void CheckError::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CheckError::clear_code() {
// @@protoc_insertion_point(one_of_clear_start:openfga.v1.CheckError)
  switch (code_case()) {
    case kInputError: {
      // No need to clear
      break;
    }
    case kInternalError: {
      // No need to clear
      break;
    }
    case CODE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = CODE_NOT_SET;
}


void CheckError::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.CheckError)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_.ClearToEmpty();
  clear_code();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CheckError::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .openfga.v1.ErrorCode input_error = 1 [json_name = "input_error"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_input_error(static_cast<::openfga::v1::ErrorCode>(val));
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.InternalErrorCode internal_error = 2 [json_name = "internal_error"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_internal_error(static_cast<::openfga::v1::InternalErrorCode>(val));
        } else
          goto handle_unusual;
        continue;
      // string message = 3 [json_name = "message"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.CheckError.message"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CheckError::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.CheckError)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .openfga.v1.ErrorCode input_error = 1 [json_name = "input_error"];
  if (_internal_has_input_error()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_input_error(), target);
  }

  // .openfga.v1.InternalErrorCode internal_error = 2 [json_name = "internal_error"];
  if (_internal_has_internal_error()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_internal_error(), target);
  }

  // string message = 3 [json_name = "message"];
  if (!this->_internal_message().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.CheckError.message");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.CheckError)
  return target;
}

size_t CheckError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.CheckError)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string message = 3 [json_name = "message"];
  if (!this->_internal_message().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  switch (code_case()) {
    // .openfga.v1.ErrorCode input_error = 1 [json_name = "input_error"];
    case kInputError: {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_input_error());
      break;
    }
    // .openfga.v1.InternalErrorCode internal_error = 2 [json_name = "internal_error"];
    case kInternalError: {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_internal_error());
      break;
    }
    case CODE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CheckError::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CheckError::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CheckError::GetClassData() const { return &_class_data_; }


void CheckError::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CheckError*>(&to_msg);
  auto& from = static_cast<const CheckError&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.CheckError)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_message().empty()) {
    _this->_internal_set_message(from._internal_message());
  }
  switch (from.code_case()) {
    case kInputError: {
      _this->_internal_set_input_error(from._internal_input_error());
      break;
    }
    case kInternalError: {
      _this->_internal_set_internal_error(from._internal_internal_error());
      break;
    }
    case CODE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CheckError::CopyFrom(const CheckError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.CheckError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckError::IsInitialized() const {
  return true;
}

void CheckError::InternalSwap(CheckError* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  swap(_impl_.code_, other->_impl_.code_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata CheckError::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[21]);
}

// ===================================================================

class ExpandRequest::_Internal {
 public:
  static const ::openfga::v1::ExpandRequestTupleKey& tuple_key(const ExpandRequest* msg);
  static const ::openfga::v1::ContextualTupleKeys& contextual_tuples(const ExpandRequest* msg);
};

const ::openfga::v1::ExpandRequestTupleKey&
ExpandRequest::_Internal::tuple_key(const ExpandRequest* msg) {
  return *msg->_impl_.tuple_key_;
}
const ::openfga::v1::ContextualTupleKeys&
ExpandRequest::_Internal::contextual_tuples(const ExpandRequest* msg) {
  return *msg->_impl_.contextual_tuples_;
}
void ExpandRequest::clear_contextual_tuples() {
  if (GetArenaForAllocation() == nullptr && _impl_.contextual_tuples_ != nullptr) {
    delete _impl_.contextual_tuples_;
  }
  _impl_.contextual_tuples_ = nullptr;
}
ExpandRequest::ExpandRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.ExpandRequest)
}
ExpandRequest::ExpandRequest(const ExpandRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ExpandRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.store_id_){}
    , decltype(_impl_.authorization_model_id_){}
    , decltype(_impl_.tuple_key_){nullptr}
    , decltype(_impl_.contextual_tuples_){nullptr}
    , decltype(_impl_.consistency_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_store_id().empty()) {
    _this->_impl_.store_id_.Set(from._internal_store_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.authorization_model_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_authorization_model_id().empty()) {
    _this->_impl_.authorization_model_id_.Set(from._internal_authorization_model_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_tuple_key()) {
    _this->_impl_.tuple_key_ = new ::openfga::v1::ExpandRequestTupleKey(*from._impl_.tuple_key_);
  }
  if (from._internal_has_contextual_tuples()) {
    _this->_impl_.contextual_tuples_ = new ::openfga::v1::ContextualTupleKeys(*from._impl_.contextual_tuples_);
  }
  _this->_impl_.consistency_ = from._impl_.consistency_;
  // @@protoc_insertion_point(copy_constructor:openfga.v1.ExpandRequest)
}

inline void ExpandRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.store_id_){}
    , decltype(_impl_.authorization_model_id_){}
    , decltype(_impl_.tuple_key_){nullptr}
    , decltype(_impl_.contextual_tuples_){nullptr}
    , decltype(_impl_.consistency_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.authorization_model_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ExpandRequest::~ExpandRequest() {
  // @@protoc_insertion_point(destructor:openfga.v1.ExpandRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExpandRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.store_id_.Destroy();
  _impl_.authorization_model_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.tuple_key_;
  if (this != internal_default_instance()) delete _impl_.contextual_tuples_;
}

void ExpandRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExpandRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.ExpandRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.store_id_.ClearToEmpty();
  _impl_.authorization_model_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.tuple_key_ != nullptr) {
    delete _impl_.tuple_key_;
  }
  _impl_.tuple_key_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.contextual_tuples_ != nullptr) {
    delete _impl_.contextual_tuples_;
  }
  _impl_.contextual_tuples_ = nullptr;
  _impl_.consistency_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExpandRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_store_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ExpandRequest.store_id"));
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.ExpandRequestTupleKey tuple_key = 2 [json_name = "tuple_key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_tuple_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string authorization_model_id = 3 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_authorization_model_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ExpandRequest.authorization_model_id"));
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.ConsistencyPreference consistency = 4 [json_name = "consistency", (.validate.rules) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_consistency(static_cast<::openfga::v1::ConsistencyPreference>(val));
        } else
          goto handle_unusual;
        continue;
      // .openfga.v1.ContextualTupleKeys contextual_tuples = 5 [json_name = "contextual_tuples"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_contextual_tuples(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExpandRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.ExpandRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_store_id().data(), static_cast<int>(this->_internal_store_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ExpandRequest.store_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_store_id(), target);
  }

  // .openfga.v1.ExpandRequestTupleKey tuple_key = 2 [json_name = "tuple_key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (this->_internal_has_tuple_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::tuple_key(this),
        _Internal::tuple_key(this).GetCachedSize(), target, stream);
  }

  // string authorization_model_id = 3 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_authorization_model_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_authorization_model_id().data(), static_cast<int>(this->_internal_authorization_model_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ExpandRequest.authorization_model_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_authorization_model_id(), target);
  }

  // .openfga.v1.ConsistencyPreference consistency = 4 [json_name = "consistency", (.validate.rules) = {
  if (this->_internal_consistency() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_consistency(), target);
  }

  // .openfga.v1.ContextualTupleKeys contextual_tuples = 5 [json_name = "contextual_tuples"];
  if (this->_internal_has_contextual_tuples()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::contextual_tuples(this),
        _Internal::contextual_tuples(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.ExpandRequest)
  return target;
}

size_t ExpandRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.ExpandRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_store_id());
  }

  // string authorization_model_id = 3 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_authorization_model_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_authorization_model_id());
  }

  // .openfga.v1.ExpandRequestTupleKey tuple_key = 2 [json_name = "tuple_key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (this->_internal_has_tuple_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tuple_key_);
  }

  // .openfga.v1.ContextualTupleKeys contextual_tuples = 5 [json_name = "contextual_tuples"];
  if (this->_internal_has_contextual_tuples()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.contextual_tuples_);
  }

  // .openfga.v1.ConsistencyPreference consistency = 4 [json_name = "consistency", (.validate.rules) = {
  if (this->_internal_consistency() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_consistency());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExpandRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ExpandRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExpandRequest::GetClassData() const { return &_class_data_; }


void ExpandRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ExpandRequest*>(&to_msg);
  auto& from = static_cast<const ExpandRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.ExpandRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_store_id().empty()) {
    _this->_internal_set_store_id(from._internal_store_id());
  }
  if (!from._internal_authorization_model_id().empty()) {
    _this->_internal_set_authorization_model_id(from._internal_authorization_model_id());
  }
  if (from._internal_has_tuple_key()) {
    _this->_internal_mutable_tuple_key()->::openfga::v1::ExpandRequestTupleKey::MergeFrom(
        from._internal_tuple_key());
  }
  if (from._internal_has_contextual_tuples()) {
    _this->_internal_mutable_contextual_tuples()->::openfga::v1::ContextualTupleKeys::MergeFrom(
        from._internal_contextual_tuples());
  }
  if (from._internal_consistency() != 0) {
    _this->_internal_set_consistency(from._internal_consistency());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExpandRequest::CopyFrom(const ExpandRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.ExpandRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExpandRequest::IsInitialized() const {
  return true;
}

void ExpandRequest::InternalSwap(ExpandRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.store_id_, lhs_arena,
      &other->_impl_.store_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.authorization_model_id_, lhs_arena,
      &other->_impl_.authorization_model_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ExpandRequest, _impl_.consistency_)
      + sizeof(ExpandRequest::_impl_.consistency_)
      - PROTOBUF_FIELD_OFFSET(ExpandRequest, _impl_.tuple_key_)>(
          reinterpret_cast<char*>(&_impl_.tuple_key_),
          reinterpret_cast<char*>(&other->_impl_.tuple_key_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ExpandRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[22]);
}

// ===================================================================

class ExpandRequestTupleKey::_Internal {
 public:
};

ExpandRequestTupleKey::ExpandRequestTupleKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.ExpandRequestTupleKey)
}
ExpandRequestTupleKey::ExpandRequestTupleKey(const ExpandRequestTupleKey& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ExpandRequestTupleKey* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.relation_){}
    , decltype(_impl_.object_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.relation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_relation().empty()) {
    _this->_impl_.relation_.Set(from._internal_relation(), 
      _this->GetArenaForAllocation());
  }
  _impl_.object_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.object_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_object().empty()) {
    _this->_impl_.object_.Set(from._internal_object(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.ExpandRequestTupleKey)
}

inline void ExpandRequestTupleKey::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.relation_){}
    , decltype(_impl_.object_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.relation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.object_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.object_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ExpandRequestTupleKey::~ExpandRequestTupleKey() {
  // @@protoc_insertion_point(destructor:openfga.v1.ExpandRequestTupleKey)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExpandRequestTupleKey::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.relation_.Destroy();
  _impl_.object_.Destroy();
}

void ExpandRequestTupleKey::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExpandRequestTupleKey::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.ExpandRequestTupleKey)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.relation_.ClearToEmpty();
  _impl_.object_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExpandRequestTupleKey::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string relation = 1 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_relation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ExpandRequestTupleKey.relation"));
        } else
          goto handle_unusual;
        continue;
      // string object = 2 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_object();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ExpandRequestTupleKey.object"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExpandRequestTupleKey::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.ExpandRequestTupleKey)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string relation = 1 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_relation().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_relation().data(), static_cast<int>(this->_internal_relation().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ExpandRequestTupleKey.relation");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_relation(), target);
  }

  // string object = 2 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_object().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_object().data(), static_cast<int>(this->_internal_object().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ExpandRequestTupleKey.object");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_object(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.ExpandRequestTupleKey)
  return target;
}

size_t ExpandRequestTupleKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.ExpandRequestTupleKey)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string relation = 1 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_relation().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_relation());
  }

  // string object = 2 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_object().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_object());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExpandRequestTupleKey::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ExpandRequestTupleKey::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExpandRequestTupleKey::GetClassData() const { return &_class_data_; }


void ExpandRequestTupleKey::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ExpandRequestTupleKey*>(&to_msg);
  auto& from = static_cast<const ExpandRequestTupleKey&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.ExpandRequestTupleKey)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_relation().empty()) {
    _this->_internal_set_relation(from._internal_relation());
  }
  if (!from._internal_object().empty()) {
    _this->_internal_set_object(from._internal_object());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExpandRequestTupleKey::CopyFrom(const ExpandRequestTupleKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.ExpandRequestTupleKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExpandRequestTupleKey::IsInitialized() const {
  return true;
}

void ExpandRequestTupleKey::InternalSwap(ExpandRequestTupleKey* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.relation_, lhs_arena,
      &other->_impl_.relation_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.object_, lhs_arena,
      &other->_impl_.object_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ExpandRequestTupleKey::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[23]);
}

// ===================================================================

class ExpandResponse::_Internal {
 public:
  static const ::openfga::v1::UsersetTree& tree(const ExpandResponse* msg);
};

const ::openfga::v1::UsersetTree&
ExpandResponse::_Internal::tree(const ExpandResponse* msg) {
  return *msg->_impl_.tree_;
}
void ExpandResponse::clear_tree() {
  if (GetArenaForAllocation() == nullptr && _impl_.tree_ != nullptr) {
    delete _impl_.tree_;
  }
  _impl_.tree_ = nullptr;
}
ExpandResponse::ExpandResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.ExpandResponse)
}
ExpandResponse::ExpandResponse(const ExpandResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ExpandResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tree_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_tree()) {
    _this->_impl_.tree_ = new ::openfga::v1::UsersetTree(*from._impl_.tree_);
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.ExpandResponse)
}

inline void ExpandResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tree_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ExpandResponse::~ExpandResponse() {
  // @@protoc_insertion_point(destructor:openfga.v1.ExpandResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExpandResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.tree_;
}

void ExpandResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExpandResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.ExpandResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.tree_ != nullptr) {
    delete _impl_.tree_;
  }
  _impl_.tree_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExpandResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .openfga.v1.UsersetTree tree = 1 [json_name = "tree"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_tree(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExpandResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.ExpandResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .openfga.v1.UsersetTree tree = 1 [json_name = "tree"];
  if (this->_internal_has_tree()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::tree(this),
        _Internal::tree(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.ExpandResponse)
  return target;
}

size_t ExpandResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.ExpandResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .openfga.v1.UsersetTree tree = 1 [json_name = "tree"];
  if (this->_internal_has_tree()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tree_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExpandResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ExpandResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExpandResponse::GetClassData() const { return &_class_data_; }


void ExpandResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ExpandResponse*>(&to_msg);
  auto& from = static_cast<const ExpandResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.ExpandResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tree()) {
    _this->_internal_mutable_tree()->::openfga::v1::UsersetTree::MergeFrom(
        from._internal_tree());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExpandResponse::CopyFrom(const ExpandResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.ExpandResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExpandResponse::IsInitialized() const {
  return true;
}

void ExpandResponse::InternalSwap(ExpandResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.tree_, other->_impl_.tree_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ExpandResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[24]);
}

// ===================================================================

class ReadAuthorizationModelRequest::_Internal {
 public:
};

ReadAuthorizationModelRequest::ReadAuthorizationModelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.ReadAuthorizationModelRequest)
}
ReadAuthorizationModelRequest::ReadAuthorizationModelRequest(const ReadAuthorizationModelRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReadAuthorizationModelRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.store_id_){}
    , decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_store_id().empty()) {
    _this->_impl_.store_id_.Set(from._internal_store_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.ReadAuthorizationModelRequest)
}

inline void ReadAuthorizationModelRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.store_id_){}
    , decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReadAuthorizationModelRequest::~ReadAuthorizationModelRequest() {
  // @@protoc_insertion_point(destructor:openfga.v1.ReadAuthorizationModelRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReadAuthorizationModelRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.store_id_.Destroy();
  _impl_.id_.Destroy();
}

void ReadAuthorizationModelRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReadAuthorizationModelRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.ReadAuthorizationModelRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.store_id_.ClearToEmpty();
  _impl_.id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReadAuthorizationModelRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_store_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ReadAuthorizationModelRequest.store_id"));
        } else
          goto handle_unusual;
        continue;
      // string id = 2 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ReadAuthorizationModelRequest.id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReadAuthorizationModelRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.ReadAuthorizationModelRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_store_id().data(), static_cast<int>(this->_internal_store_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ReadAuthorizationModelRequest.store_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_store_id(), target);
  }

  // string id = 2 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ReadAuthorizationModelRequest.id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.ReadAuthorizationModelRequest)
  return target;
}

size_t ReadAuthorizationModelRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.ReadAuthorizationModelRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_store_id());
  }

  // string id = 2 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReadAuthorizationModelRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReadAuthorizationModelRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReadAuthorizationModelRequest::GetClassData() const { return &_class_data_; }


void ReadAuthorizationModelRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReadAuthorizationModelRequest*>(&to_msg);
  auto& from = static_cast<const ReadAuthorizationModelRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.ReadAuthorizationModelRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_store_id().empty()) {
    _this->_internal_set_store_id(from._internal_store_id());
  }
  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReadAuthorizationModelRequest::CopyFrom(const ReadAuthorizationModelRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.ReadAuthorizationModelRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadAuthorizationModelRequest::IsInitialized() const {
  return true;
}

void ReadAuthorizationModelRequest::InternalSwap(ReadAuthorizationModelRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.store_id_, lhs_arena,
      &other->_impl_.store_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ReadAuthorizationModelRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[25]);
}

// ===================================================================

class ReadAuthorizationModelResponse::_Internal {
 public:
  static const ::openfga::v1::AuthorizationModel& authorization_model(const ReadAuthorizationModelResponse* msg);
};

const ::openfga::v1::AuthorizationModel&
ReadAuthorizationModelResponse::_Internal::authorization_model(const ReadAuthorizationModelResponse* msg) {
  return *msg->_impl_.authorization_model_;
}
void ReadAuthorizationModelResponse::clear_authorization_model() {
  if (GetArenaForAllocation() == nullptr && _impl_.authorization_model_ != nullptr) {
    delete _impl_.authorization_model_;
  }
  _impl_.authorization_model_ = nullptr;
}
ReadAuthorizationModelResponse::ReadAuthorizationModelResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.ReadAuthorizationModelResponse)
}
ReadAuthorizationModelResponse::ReadAuthorizationModelResponse(const ReadAuthorizationModelResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReadAuthorizationModelResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.authorization_model_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_authorization_model()) {
    _this->_impl_.authorization_model_ = new ::openfga::v1::AuthorizationModel(*from._impl_.authorization_model_);
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.ReadAuthorizationModelResponse)
}

inline void ReadAuthorizationModelResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.authorization_model_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ReadAuthorizationModelResponse::~ReadAuthorizationModelResponse() {
  // @@protoc_insertion_point(destructor:openfga.v1.ReadAuthorizationModelResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReadAuthorizationModelResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.authorization_model_;
}

void ReadAuthorizationModelResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReadAuthorizationModelResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.ReadAuthorizationModelResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.authorization_model_ != nullptr) {
    delete _impl_.authorization_model_;
  }
  _impl_.authorization_model_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReadAuthorizationModelResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .openfga.v1.AuthorizationModel authorization_model = 1 [json_name = "authorization_model"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_authorization_model(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReadAuthorizationModelResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.ReadAuthorizationModelResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .openfga.v1.AuthorizationModel authorization_model = 1 [json_name = "authorization_model"];
  if (this->_internal_has_authorization_model()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::authorization_model(this),
        _Internal::authorization_model(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.ReadAuthorizationModelResponse)
  return target;
}

size_t ReadAuthorizationModelResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.ReadAuthorizationModelResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .openfga.v1.AuthorizationModel authorization_model = 1 [json_name = "authorization_model"];
  if (this->_internal_has_authorization_model()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.authorization_model_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReadAuthorizationModelResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReadAuthorizationModelResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReadAuthorizationModelResponse::GetClassData() const { return &_class_data_; }


void ReadAuthorizationModelResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReadAuthorizationModelResponse*>(&to_msg);
  auto& from = static_cast<const ReadAuthorizationModelResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.ReadAuthorizationModelResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_authorization_model()) {
    _this->_internal_mutable_authorization_model()->::openfga::v1::AuthorizationModel::MergeFrom(
        from._internal_authorization_model());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReadAuthorizationModelResponse::CopyFrom(const ReadAuthorizationModelResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.ReadAuthorizationModelResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadAuthorizationModelResponse::IsInitialized() const {
  return true;
}

void ReadAuthorizationModelResponse::InternalSwap(ReadAuthorizationModelResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.authorization_model_, other->_impl_.authorization_model_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReadAuthorizationModelResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[26]);
}

// ===================================================================

WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse::WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse() {}
WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse::WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse::MergeFrom(const WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[27]);
}

// ===================================================================

class WriteAuthorizationModelRequest::_Internal {
 public:
};

void WriteAuthorizationModelRequest::clear_type_definitions() {
  _impl_.type_definitions_.Clear();
}
void WriteAuthorizationModelRequest::clear_conditions() {
  _impl_.conditions_.Clear();
}
WriteAuthorizationModelRequest::WriteAuthorizationModelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &WriteAuthorizationModelRequest::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:openfga.v1.WriteAuthorizationModelRequest)
}
WriteAuthorizationModelRequest::WriteAuthorizationModelRequest(const WriteAuthorizationModelRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WriteAuthorizationModelRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.type_definitions_){from._impl_.type_definitions_}
    , /*decltype(_impl_.conditions_)*/{}
    , decltype(_impl_.store_id_){}
    , decltype(_impl_.schema_version_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.conditions_.MergeFrom(from._impl_.conditions_);
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_store_id().empty()) {
    _this->_impl_.store_id_.Set(from._internal_store_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.schema_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.schema_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_schema_version().empty()) {
    _this->_impl_.schema_version_.Set(from._internal_schema_version(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.WriteAuthorizationModelRequest)
}

inline void WriteAuthorizationModelRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.type_definitions_){arena}
    , /*decltype(_impl_.conditions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.store_id_){}
    , decltype(_impl_.schema_version_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.schema_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.schema_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WriteAuthorizationModelRequest::~WriteAuthorizationModelRequest() {
  // @@protoc_insertion_point(destructor:openfga.v1.WriteAuthorizationModelRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void WriteAuthorizationModelRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.type_definitions_.~RepeatedPtrField();
  _impl_.conditions_.Destruct();
  _impl_.conditions_.~MapField();
  _impl_.store_id_.Destroy();
  _impl_.schema_version_.Destroy();
}

void WriteAuthorizationModelRequest::ArenaDtor(void* object) {
  WriteAuthorizationModelRequest* _this = reinterpret_cast< WriteAuthorizationModelRequest* >(object);
  _this->_impl_.conditions_.Destruct();
}
void WriteAuthorizationModelRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WriteAuthorizationModelRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.WriteAuthorizationModelRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.type_definitions_.Clear();
  _impl_.conditions_.Clear();
  _impl_.store_id_.ClearToEmpty();
  _impl_.schema_version_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WriteAuthorizationModelRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_store_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.WriteAuthorizationModelRequest.store_id"));
        } else
          goto handle_unusual;
        continue;
      // repeated .openfga.v1.TypeDefinition type_definitions = 2 [json_name = "type_definitions", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_type_definitions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string schema_version = 3 [json_name = "schema_version", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_schema_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.WriteAuthorizationModelRequest.schema_version"));
        } else
          goto handle_unusual;
        continue;
      // map<string, .openfga.v1.Condition> conditions = 4 [json_name = "conditions", (.validate.rules) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.conditions_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WriteAuthorizationModelRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.WriteAuthorizationModelRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_store_id().data(), static_cast<int>(this->_internal_store_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.WriteAuthorizationModelRequest.store_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_store_id(), target);
  }

  // repeated .openfga.v1.TypeDefinition type_definitions = 2 [json_name = "type_definitions", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_type_definitions_size()); i < n; i++) {
    const auto& repfield = this->_internal_type_definitions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string schema_version = 3 [json_name = "schema_version", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (!this->_internal_schema_version().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_schema_version().data(), static_cast<int>(this->_internal_schema_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.WriteAuthorizationModelRequest.schema_version");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_schema_version(), target);
  }

  // map<string, .openfga.v1.Condition> conditions = 4 [json_name = "conditions", (.validate.rules) = {
  if (!this->_internal_conditions().empty()) {
    using MapType = ::_pb::Map<std::string, ::openfga::v1::Condition>;
    using WireHelper = WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_conditions();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "openfga.v1.WriteAuthorizationModelRequest.ConditionsEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(4, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(4, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.WriteAuthorizationModelRequest)
  return target;
}

size_t WriteAuthorizationModelRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.WriteAuthorizationModelRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .openfga.v1.TypeDefinition type_definitions = 2 [json_name = "type_definitions", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  total_size += 1UL * this->_internal_type_definitions_size();
  for (const auto& msg : this->_impl_.type_definitions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<string, .openfga.v1.Condition> conditions = 4 [json_name = "conditions", (.validate.rules) = {
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_conditions_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::openfga::v1::Condition >::const_iterator
      it = this->_internal_conditions().begin();
      it != this->_internal_conditions().end(); ++it) {
    total_size += WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_store_id());
  }

  // string schema_version = 3 [json_name = "schema_version", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (!this->_internal_schema_version().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_schema_version());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WriteAuthorizationModelRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WriteAuthorizationModelRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WriteAuthorizationModelRequest::GetClassData() const { return &_class_data_; }


void WriteAuthorizationModelRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WriteAuthorizationModelRequest*>(&to_msg);
  auto& from = static_cast<const WriteAuthorizationModelRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.WriteAuthorizationModelRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.type_definitions_.MergeFrom(from._impl_.type_definitions_);
  _this->_impl_.conditions_.MergeFrom(from._impl_.conditions_);
  if (!from._internal_store_id().empty()) {
    _this->_internal_set_store_id(from._internal_store_id());
  }
  if (!from._internal_schema_version().empty()) {
    _this->_internal_set_schema_version(from._internal_schema_version());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WriteAuthorizationModelRequest::CopyFrom(const WriteAuthorizationModelRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.WriteAuthorizationModelRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WriteAuthorizationModelRequest::IsInitialized() const {
  return true;
}

void WriteAuthorizationModelRequest::InternalSwap(WriteAuthorizationModelRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.type_definitions_.InternalSwap(&other->_impl_.type_definitions_);
  _impl_.conditions_.InternalSwap(&other->_impl_.conditions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.store_id_, lhs_arena,
      &other->_impl_.store_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.schema_version_, lhs_arena,
      &other->_impl_.schema_version_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata WriteAuthorizationModelRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[28]);
}

// ===================================================================

class WriteAuthorizationModelResponse::_Internal {
 public:
};

WriteAuthorizationModelResponse::WriteAuthorizationModelResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.WriteAuthorizationModelResponse)
}
WriteAuthorizationModelResponse::WriteAuthorizationModelResponse(const WriteAuthorizationModelResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WriteAuthorizationModelResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.authorization_model_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.authorization_model_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_authorization_model_id().empty()) {
    _this->_impl_.authorization_model_id_.Set(from._internal_authorization_model_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.WriteAuthorizationModelResponse)
}

inline void WriteAuthorizationModelResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.authorization_model_id_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.authorization_model_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WriteAuthorizationModelResponse::~WriteAuthorizationModelResponse() {
  // @@protoc_insertion_point(destructor:openfga.v1.WriteAuthorizationModelResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WriteAuthorizationModelResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.authorization_model_id_.Destroy();
}

void WriteAuthorizationModelResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WriteAuthorizationModelResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.WriteAuthorizationModelResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.authorization_model_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WriteAuthorizationModelResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string authorization_model_id = 1 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_authorization_model_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.WriteAuthorizationModelResponse.authorization_model_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WriteAuthorizationModelResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.WriteAuthorizationModelResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string authorization_model_id = 1 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_authorization_model_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_authorization_model_id().data(), static_cast<int>(this->_internal_authorization_model_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.WriteAuthorizationModelResponse.authorization_model_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_authorization_model_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.WriteAuthorizationModelResponse)
  return target;
}

size_t WriteAuthorizationModelResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.WriteAuthorizationModelResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string authorization_model_id = 1 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_authorization_model_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_authorization_model_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WriteAuthorizationModelResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WriteAuthorizationModelResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WriteAuthorizationModelResponse::GetClassData() const { return &_class_data_; }


void WriteAuthorizationModelResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WriteAuthorizationModelResponse*>(&to_msg);
  auto& from = static_cast<const WriteAuthorizationModelResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.WriteAuthorizationModelResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_authorization_model_id().empty()) {
    _this->_internal_set_authorization_model_id(from._internal_authorization_model_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WriteAuthorizationModelResponse::CopyFrom(const WriteAuthorizationModelResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.WriteAuthorizationModelResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WriteAuthorizationModelResponse::IsInitialized() const {
  return true;
}

void WriteAuthorizationModelResponse::InternalSwap(WriteAuthorizationModelResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.authorization_model_id_, lhs_arena,
      &other->_impl_.authorization_model_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata WriteAuthorizationModelResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[29]);
}

// ===================================================================

class ReadAuthorizationModelsRequest::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::Int32Value& page_size(const ReadAuthorizationModelsRequest* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Int32Value&
ReadAuthorizationModelsRequest::_Internal::page_size(const ReadAuthorizationModelsRequest* msg) {
  return *msg->_impl_.page_size_;
}
void ReadAuthorizationModelsRequest::clear_page_size() {
  if (GetArenaForAllocation() == nullptr && _impl_.page_size_ != nullptr) {
    delete _impl_.page_size_;
  }
  _impl_.page_size_ = nullptr;
}
ReadAuthorizationModelsRequest::ReadAuthorizationModelsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.ReadAuthorizationModelsRequest)
}
ReadAuthorizationModelsRequest::ReadAuthorizationModelsRequest(const ReadAuthorizationModelsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReadAuthorizationModelsRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.store_id_){}
    , decltype(_impl_.continuation_token_){}
    , decltype(_impl_.page_size_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_store_id().empty()) {
    _this->_impl_.store_id_.Set(from._internal_store_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.continuation_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.continuation_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_continuation_token().empty()) {
    _this->_impl_.continuation_token_.Set(from._internal_continuation_token(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_page_size()) {
    _this->_impl_.page_size_ = new ::PROTOBUF_NAMESPACE_ID::Int32Value(*from._impl_.page_size_);
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.ReadAuthorizationModelsRequest)
}

inline void ReadAuthorizationModelsRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.store_id_){}
    , decltype(_impl_.continuation_token_){}
    , decltype(_impl_.page_size_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.continuation_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.continuation_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReadAuthorizationModelsRequest::~ReadAuthorizationModelsRequest() {
  // @@protoc_insertion_point(destructor:openfga.v1.ReadAuthorizationModelsRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReadAuthorizationModelsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.store_id_.Destroy();
  _impl_.continuation_token_.Destroy();
  if (this != internal_default_instance()) delete _impl_.page_size_;
}

void ReadAuthorizationModelsRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReadAuthorizationModelsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.ReadAuthorizationModelsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.store_id_.ClearToEmpty();
  _impl_.continuation_token_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.page_size_ != nullptr) {
    delete _impl_.page_size_;
  }
  _impl_.page_size_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReadAuthorizationModelsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_store_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ReadAuthorizationModelsRequest.store_id"));
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Int32Value page_size = 2 [json_name = "page_size", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_page_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string continuation_token = 3 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_continuation_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ReadAuthorizationModelsRequest.continuation_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReadAuthorizationModelsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.ReadAuthorizationModelsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_store_id().data(), static_cast<int>(this->_internal_store_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ReadAuthorizationModelsRequest.store_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_store_id(), target);
  }

  // .google.protobuf.Int32Value page_size = 2 [json_name = "page_size", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (this->_internal_has_page_size()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::page_size(this),
        _Internal::page_size(this).GetCachedSize(), target, stream);
  }

  // string continuation_token = 3 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_continuation_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_continuation_token().data(), static_cast<int>(this->_internal_continuation_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ReadAuthorizationModelsRequest.continuation_token");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_continuation_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.ReadAuthorizationModelsRequest)
  return target;
}

size_t ReadAuthorizationModelsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.ReadAuthorizationModelsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_store_id());
  }

  // string continuation_token = 3 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_continuation_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_continuation_token());
  }

  // .google.protobuf.Int32Value page_size = 2 [json_name = "page_size", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (this->_internal_has_page_size()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.page_size_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReadAuthorizationModelsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReadAuthorizationModelsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReadAuthorizationModelsRequest::GetClassData() const { return &_class_data_; }


void ReadAuthorizationModelsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReadAuthorizationModelsRequest*>(&to_msg);
  auto& from = static_cast<const ReadAuthorizationModelsRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.ReadAuthorizationModelsRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_store_id().empty()) {
    _this->_internal_set_store_id(from._internal_store_id());
  }
  if (!from._internal_continuation_token().empty()) {
    _this->_internal_set_continuation_token(from._internal_continuation_token());
  }
  if (from._internal_has_page_size()) {
    _this->_internal_mutable_page_size()->::PROTOBUF_NAMESPACE_ID::Int32Value::MergeFrom(
        from._internal_page_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReadAuthorizationModelsRequest::CopyFrom(const ReadAuthorizationModelsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.ReadAuthorizationModelsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadAuthorizationModelsRequest::IsInitialized() const {
  return true;
}

void ReadAuthorizationModelsRequest::InternalSwap(ReadAuthorizationModelsRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.store_id_, lhs_arena,
      &other->_impl_.store_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.continuation_token_, lhs_arena,
      &other->_impl_.continuation_token_, rhs_arena
  );
  swap(_impl_.page_size_, other->_impl_.page_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReadAuthorizationModelsRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[30]);
}

// ===================================================================

class ReadAuthorizationModelsResponse::_Internal {
 public:
};

void ReadAuthorizationModelsResponse::clear_authorization_models() {
  _impl_.authorization_models_.Clear();
}
ReadAuthorizationModelsResponse::ReadAuthorizationModelsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.ReadAuthorizationModelsResponse)
}
ReadAuthorizationModelsResponse::ReadAuthorizationModelsResponse(const ReadAuthorizationModelsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReadAuthorizationModelsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.authorization_models_){from._impl_.authorization_models_}
    , decltype(_impl_.continuation_token_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.continuation_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.continuation_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_continuation_token().empty()) {
    _this->_impl_.continuation_token_.Set(from._internal_continuation_token(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.ReadAuthorizationModelsResponse)
}

inline void ReadAuthorizationModelsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.authorization_models_){arena}
    , decltype(_impl_.continuation_token_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.continuation_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.continuation_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReadAuthorizationModelsResponse::~ReadAuthorizationModelsResponse() {
  // @@protoc_insertion_point(destructor:openfga.v1.ReadAuthorizationModelsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReadAuthorizationModelsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.authorization_models_.~RepeatedPtrField();
  _impl_.continuation_token_.Destroy();
}

void ReadAuthorizationModelsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReadAuthorizationModelsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.ReadAuthorizationModelsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.authorization_models_.Clear();
  _impl_.continuation_token_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReadAuthorizationModelsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .openfga.v1.AuthorizationModel authorization_models = 1 [json_name = "authorization_models", (.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_authorization_models(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string continuation_token = 2 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_continuation_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ReadAuthorizationModelsResponse.continuation_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReadAuthorizationModelsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.ReadAuthorizationModelsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .openfga.v1.AuthorizationModel authorization_models = 1 [json_name = "authorization_models", (.google.api.field_behavior) = REQUIRED];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_authorization_models_size()); i < n; i++) {
    const auto& repfield = this->_internal_authorization_models(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string continuation_token = 2 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_continuation_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_continuation_token().data(), static_cast<int>(this->_internal_continuation_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ReadAuthorizationModelsResponse.continuation_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_continuation_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.ReadAuthorizationModelsResponse)
  return target;
}

size_t ReadAuthorizationModelsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.ReadAuthorizationModelsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .openfga.v1.AuthorizationModel authorization_models = 1 [json_name = "authorization_models", (.google.api.field_behavior) = REQUIRED];
  total_size += 1UL * this->_internal_authorization_models_size();
  for (const auto& msg : this->_impl_.authorization_models_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string continuation_token = 2 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_continuation_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_continuation_token());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReadAuthorizationModelsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReadAuthorizationModelsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReadAuthorizationModelsResponse::GetClassData() const { return &_class_data_; }


void ReadAuthorizationModelsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReadAuthorizationModelsResponse*>(&to_msg);
  auto& from = static_cast<const ReadAuthorizationModelsResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.ReadAuthorizationModelsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.authorization_models_.MergeFrom(from._impl_.authorization_models_);
  if (!from._internal_continuation_token().empty()) {
    _this->_internal_set_continuation_token(from._internal_continuation_token());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReadAuthorizationModelsResponse::CopyFrom(const ReadAuthorizationModelsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.ReadAuthorizationModelsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadAuthorizationModelsResponse::IsInitialized() const {
  return true;
}

void ReadAuthorizationModelsResponse::InternalSwap(ReadAuthorizationModelsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.authorization_models_.InternalSwap(&other->_impl_.authorization_models_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.continuation_token_, lhs_arena,
      &other->_impl_.continuation_token_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ReadAuthorizationModelsResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[31]);
}

// ===================================================================

class WriteAssertionsRequest::_Internal {
 public:
};

WriteAssertionsRequest::WriteAssertionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.WriteAssertionsRequest)
}
WriteAssertionsRequest::WriteAssertionsRequest(const WriteAssertionsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WriteAssertionsRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.assertions_){from._impl_.assertions_}
    , decltype(_impl_.store_id_){}
    , decltype(_impl_.authorization_model_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_store_id().empty()) {
    _this->_impl_.store_id_.Set(from._internal_store_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.authorization_model_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_authorization_model_id().empty()) {
    _this->_impl_.authorization_model_id_.Set(from._internal_authorization_model_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.WriteAssertionsRequest)
}

inline void WriteAssertionsRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.assertions_){arena}
    , decltype(_impl_.store_id_){}
    , decltype(_impl_.authorization_model_id_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.authorization_model_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WriteAssertionsRequest::~WriteAssertionsRequest() {
  // @@protoc_insertion_point(destructor:openfga.v1.WriteAssertionsRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WriteAssertionsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.assertions_.~RepeatedPtrField();
  _impl_.store_id_.Destroy();
  _impl_.authorization_model_id_.Destroy();
}

void WriteAssertionsRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WriteAssertionsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.WriteAssertionsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.assertions_.Clear();
  _impl_.store_id_.ClearToEmpty();
  _impl_.authorization_model_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WriteAssertionsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_store_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.WriteAssertionsRequest.store_id"));
        } else
          goto handle_unusual;
        continue;
      // string authorization_model_id = 2 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_authorization_model_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.WriteAssertionsRequest.authorization_model_id"));
        } else
          goto handle_unusual;
        continue;
      // repeated .openfga.v1.Assertion assertions = 3 [json_name = "assertions", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_assertions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WriteAssertionsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.WriteAssertionsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_store_id().data(), static_cast<int>(this->_internal_store_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.WriteAssertionsRequest.store_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_store_id(), target);
  }

  // string authorization_model_id = 2 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_authorization_model_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_authorization_model_id().data(), static_cast<int>(this->_internal_authorization_model_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.WriteAssertionsRequest.authorization_model_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_authorization_model_id(), target);
  }

  // repeated .openfga.v1.Assertion assertions = 3 [json_name = "assertions", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_assertions_size()); i < n; i++) {
    const auto& repfield = this->_internal_assertions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.WriteAssertionsRequest)
  return target;
}

size_t WriteAssertionsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.WriteAssertionsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .openfga.v1.Assertion assertions = 3 [json_name = "assertions", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  total_size += 1UL * this->_internal_assertions_size();
  for (const auto& msg : this->_impl_.assertions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_store_id());
  }

  // string authorization_model_id = 2 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_authorization_model_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_authorization_model_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WriteAssertionsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WriteAssertionsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WriteAssertionsRequest::GetClassData() const { return &_class_data_; }


void WriteAssertionsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WriteAssertionsRequest*>(&to_msg);
  auto& from = static_cast<const WriteAssertionsRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.WriteAssertionsRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.assertions_.MergeFrom(from._impl_.assertions_);
  if (!from._internal_store_id().empty()) {
    _this->_internal_set_store_id(from._internal_store_id());
  }
  if (!from._internal_authorization_model_id().empty()) {
    _this->_internal_set_authorization_model_id(from._internal_authorization_model_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WriteAssertionsRequest::CopyFrom(const WriteAssertionsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.WriteAssertionsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WriteAssertionsRequest::IsInitialized() const {
  return true;
}

void WriteAssertionsRequest::InternalSwap(WriteAssertionsRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.assertions_.InternalSwap(&other->_impl_.assertions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.store_id_, lhs_arena,
      &other->_impl_.store_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.authorization_model_id_, lhs_arena,
      &other->_impl_.authorization_model_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata WriteAssertionsRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[32]);
}

// ===================================================================

class WriteAssertionsResponse::_Internal {
 public:
};

WriteAssertionsResponse::WriteAssertionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:openfga.v1.WriteAssertionsResponse)
}
WriteAssertionsResponse::WriteAssertionsResponse(const WriteAssertionsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  WriteAssertionsResponse* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:openfga.v1.WriteAssertionsResponse)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WriteAssertionsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WriteAssertionsResponse::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata WriteAssertionsResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[33]);
}

// ===================================================================

class ReadAssertionsRequest::_Internal {
 public:
};

ReadAssertionsRequest::ReadAssertionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.ReadAssertionsRequest)
}
ReadAssertionsRequest::ReadAssertionsRequest(const ReadAssertionsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReadAssertionsRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.store_id_){}
    , decltype(_impl_.authorization_model_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_store_id().empty()) {
    _this->_impl_.store_id_.Set(from._internal_store_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.authorization_model_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_authorization_model_id().empty()) {
    _this->_impl_.authorization_model_id_.Set(from._internal_authorization_model_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.ReadAssertionsRequest)
}

inline void ReadAssertionsRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.store_id_){}
    , decltype(_impl_.authorization_model_id_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.authorization_model_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReadAssertionsRequest::~ReadAssertionsRequest() {
  // @@protoc_insertion_point(destructor:openfga.v1.ReadAssertionsRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReadAssertionsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.store_id_.Destroy();
  _impl_.authorization_model_id_.Destroy();
}

void ReadAssertionsRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReadAssertionsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.ReadAssertionsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.store_id_.ClearToEmpty();
  _impl_.authorization_model_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReadAssertionsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_store_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ReadAssertionsRequest.store_id"));
        } else
          goto handle_unusual;
        continue;
      // string authorization_model_id = 2 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_authorization_model_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ReadAssertionsRequest.authorization_model_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReadAssertionsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.ReadAssertionsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_store_id().data(), static_cast<int>(this->_internal_store_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ReadAssertionsRequest.store_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_store_id(), target);
  }

  // string authorization_model_id = 2 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_authorization_model_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_authorization_model_id().data(), static_cast<int>(this->_internal_authorization_model_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ReadAssertionsRequest.authorization_model_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_authorization_model_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.ReadAssertionsRequest)
  return target;
}

size_t ReadAssertionsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.ReadAssertionsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_store_id());
  }

  // string authorization_model_id = 2 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_authorization_model_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_authorization_model_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReadAssertionsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReadAssertionsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReadAssertionsRequest::GetClassData() const { return &_class_data_; }


void ReadAssertionsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReadAssertionsRequest*>(&to_msg);
  auto& from = static_cast<const ReadAssertionsRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.ReadAssertionsRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_store_id().empty()) {
    _this->_internal_set_store_id(from._internal_store_id());
  }
  if (!from._internal_authorization_model_id().empty()) {
    _this->_internal_set_authorization_model_id(from._internal_authorization_model_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReadAssertionsRequest::CopyFrom(const ReadAssertionsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.ReadAssertionsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadAssertionsRequest::IsInitialized() const {
  return true;
}

void ReadAssertionsRequest::InternalSwap(ReadAssertionsRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.store_id_, lhs_arena,
      &other->_impl_.store_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.authorization_model_id_, lhs_arena,
      &other->_impl_.authorization_model_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ReadAssertionsRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[34]);
}

// ===================================================================

class ReadAssertionsResponse::_Internal {
 public:
};

ReadAssertionsResponse::ReadAssertionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.ReadAssertionsResponse)
}
ReadAssertionsResponse::ReadAssertionsResponse(const ReadAssertionsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReadAssertionsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.assertions_){from._impl_.assertions_}
    , decltype(_impl_.authorization_model_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.authorization_model_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_authorization_model_id().empty()) {
    _this->_impl_.authorization_model_id_.Set(from._internal_authorization_model_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.ReadAssertionsResponse)
}

inline void ReadAssertionsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.assertions_){arena}
    , decltype(_impl_.authorization_model_id_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.authorization_model_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.authorization_model_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReadAssertionsResponse::~ReadAssertionsResponse() {
  // @@protoc_insertion_point(destructor:openfga.v1.ReadAssertionsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReadAssertionsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.assertions_.~RepeatedPtrField();
  _impl_.authorization_model_id_.Destroy();
}

void ReadAssertionsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReadAssertionsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.ReadAssertionsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.assertions_.Clear();
  _impl_.authorization_model_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReadAssertionsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string authorization_model_id = 1 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_authorization_model_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ReadAssertionsResponse.authorization_model_id"));
        } else
          goto handle_unusual;
        continue;
      // repeated .openfga.v1.Assertion assertions = 2 [json_name = "assertions"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_assertions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReadAssertionsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.ReadAssertionsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string authorization_model_id = 1 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_authorization_model_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_authorization_model_id().data(), static_cast<int>(this->_internal_authorization_model_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ReadAssertionsResponse.authorization_model_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_authorization_model_id(), target);
  }

  // repeated .openfga.v1.Assertion assertions = 2 [json_name = "assertions"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_assertions_size()); i < n; i++) {
    const auto& repfield = this->_internal_assertions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.ReadAssertionsResponse)
  return target;
}

size_t ReadAssertionsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.ReadAssertionsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .openfga.v1.Assertion assertions = 2 [json_name = "assertions"];
  total_size += 1UL * this->_internal_assertions_size();
  for (const auto& msg : this->_impl_.assertions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string authorization_model_id = 1 [json_name = "authorization_model_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_authorization_model_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_authorization_model_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReadAssertionsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReadAssertionsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReadAssertionsResponse::GetClassData() const { return &_class_data_; }


void ReadAssertionsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReadAssertionsResponse*>(&to_msg);
  auto& from = static_cast<const ReadAssertionsResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.ReadAssertionsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.assertions_.MergeFrom(from._impl_.assertions_);
  if (!from._internal_authorization_model_id().empty()) {
    _this->_internal_set_authorization_model_id(from._internal_authorization_model_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReadAssertionsResponse::CopyFrom(const ReadAssertionsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.ReadAssertionsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadAssertionsResponse::IsInitialized() const {
  return true;
}

void ReadAssertionsResponse::InternalSwap(ReadAssertionsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.assertions_.InternalSwap(&other->_impl_.assertions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.authorization_model_id_, lhs_arena,
      &other->_impl_.authorization_model_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ReadAssertionsResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[35]);
}

// ===================================================================

class ReadChangesRequest::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::Int32Value& page_size(const ReadChangesRequest* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time(const ReadChangesRequest* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Int32Value&
ReadChangesRequest::_Internal::page_size(const ReadChangesRequest* msg) {
  return *msg->_impl_.page_size_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
ReadChangesRequest::_Internal::start_time(const ReadChangesRequest* msg) {
  return *msg->_impl_.start_time_;
}
void ReadChangesRequest::clear_page_size() {
  if (GetArenaForAllocation() == nullptr && _impl_.page_size_ != nullptr) {
    delete _impl_.page_size_;
  }
  _impl_.page_size_ = nullptr;
}
void ReadChangesRequest::clear_start_time() {
  if (GetArenaForAllocation() == nullptr && _impl_.start_time_ != nullptr) {
    delete _impl_.start_time_;
  }
  _impl_.start_time_ = nullptr;
}
ReadChangesRequest::ReadChangesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.ReadChangesRequest)
}
ReadChangesRequest::ReadChangesRequest(const ReadChangesRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReadChangesRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.store_id_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.continuation_token_){}
    , decltype(_impl_.page_size_){nullptr}
    , decltype(_impl_.start_time_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_store_id().empty()) {
    _this->_impl_.store_id_.Set(from._internal_store_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type().empty()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.continuation_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.continuation_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_continuation_token().empty()) {
    _this->_impl_.continuation_token_.Set(from._internal_continuation_token(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_page_size()) {
    _this->_impl_.page_size_ = new ::PROTOBUF_NAMESPACE_ID::Int32Value(*from._impl_.page_size_);
  }
  if (from._internal_has_start_time()) {
    _this->_impl_.start_time_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.start_time_);
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.ReadChangesRequest)
}

inline void ReadChangesRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.store_id_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.continuation_token_){}
    , decltype(_impl_.page_size_){nullptr}
    , decltype(_impl_.start_time_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.continuation_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.continuation_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReadChangesRequest::~ReadChangesRequest() {
  // @@protoc_insertion_point(destructor:openfga.v1.ReadChangesRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReadChangesRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.store_id_.Destroy();
  _impl_.type_.Destroy();
  _impl_.continuation_token_.Destroy();
  if (this != internal_default_instance()) delete _impl_.page_size_;
  if (this != internal_default_instance()) delete _impl_.start_time_;
}

void ReadChangesRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReadChangesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.ReadChangesRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.store_id_.ClearToEmpty();
  _impl_.type_.ClearToEmpty();
  _impl_.continuation_token_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.page_size_ != nullptr) {
    delete _impl_.page_size_;
  }
  _impl_.page_size_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.start_time_ != nullptr) {
    delete _impl_.start_time_;
  }
  _impl_.start_time_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReadChangesRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_store_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ReadChangesRequest.store_id"));
        } else
          goto handle_unusual;
        continue;
      // string type = 2 [json_name = "type", (.validate.rules) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ReadChangesRequest.type"));
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Int32Value page_size = 3 [json_name = "page_size", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_page_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string continuation_token = 4 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_continuation_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ReadChangesRequest.continuation_token"));
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp start_time = 5 [json_name = "start_time", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_start_time(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReadChangesRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.ReadChangesRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_store_id().data(), static_cast<int>(this->_internal_store_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ReadChangesRequest.store_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_store_id(), target);
  }

  // string type = 2 [json_name = "type", (.validate.rules) = {
  if (!this->_internal_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ReadChangesRequest.type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_type(), target);
  }

  // .google.protobuf.Int32Value page_size = 3 [json_name = "page_size", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (this->_internal_has_page_size()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::page_size(this),
        _Internal::page_size(this).GetCachedSize(), target, stream);
  }

  // string continuation_token = 4 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_continuation_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_continuation_token().data(), static_cast<int>(this->_internal_continuation_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ReadChangesRequest.continuation_token");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_continuation_token(), target);
  }

  // .google.protobuf.Timestamp start_time = 5 [json_name = "start_time", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (this->_internal_has_start_time()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::start_time(this),
        _Internal::start_time(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.ReadChangesRequest)
  return target;
}

size_t ReadChangesRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.ReadChangesRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_store_id());
  }

  // string type = 2 [json_name = "type", (.validate.rules) = {
  if (!this->_internal_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());
  }

  // string continuation_token = 4 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_continuation_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_continuation_token());
  }

  // .google.protobuf.Int32Value page_size = 3 [json_name = "page_size", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (this->_internal_has_page_size()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.page_size_);
  }

  // .google.protobuf.Timestamp start_time = 5 [json_name = "start_time", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (this->_internal_has_start_time()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.start_time_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReadChangesRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReadChangesRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReadChangesRequest::GetClassData() const { return &_class_data_; }


void ReadChangesRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReadChangesRequest*>(&to_msg);
  auto& from = static_cast<const ReadChangesRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.ReadChangesRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_store_id().empty()) {
    _this->_internal_set_store_id(from._internal_store_id());
  }
  if (!from._internal_type().empty()) {
    _this->_internal_set_type(from._internal_type());
  }
  if (!from._internal_continuation_token().empty()) {
    _this->_internal_set_continuation_token(from._internal_continuation_token());
  }
  if (from._internal_has_page_size()) {
    _this->_internal_mutable_page_size()->::PROTOBUF_NAMESPACE_ID::Int32Value::MergeFrom(
        from._internal_page_size());
  }
  if (from._internal_has_start_time()) {
    _this->_internal_mutable_start_time()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_start_time());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReadChangesRequest::CopyFrom(const ReadChangesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.ReadChangesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadChangesRequest::IsInitialized() const {
  return true;
}

void ReadChangesRequest::InternalSwap(ReadChangesRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.store_id_, lhs_arena,
      &other->_impl_.store_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.continuation_token_, lhs_arena,
      &other->_impl_.continuation_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReadChangesRequest, _impl_.start_time_)
      + sizeof(ReadChangesRequest::_impl_.start_time_)
      - PROTOBUF_FIELD_OFFSET(ReadChangesRequest, _impl_.page_size_)>(
          reinterpret_cast<char*>(&_impl_.page_size_),
          reinterpret_cast<char*>(&other->_impl_.page_size_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReadChangesRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[36]);
}

// ===================================================================

class ReadChangesResponse::_Internal {
 public:
};

void ReadChangesResponse::clear_changes() {
  _impl_.changes_.Clear();
}
ReadChangesResponse::ReadChangesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.ReadChangesResponse)
}
ReadChangesResponse::ReadChangesResponse(const ReadChangesResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReadChangesResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.changes_){from._impl_.changes_}
    , decltype(_impl_.continuation_token_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.continuation_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.continuation_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_continuation_token().empty()) {
    _this->_impl_.continuation_token_.Set(from._internal_continuation_token(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.ReadChangesResponse)
}

inline void ReadChangesResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.changes_){arena}
    , decltype(_impl_.continuation_token_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.continuation_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.continuation_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReadChangesResponse::~ReadChangesResponse() {
  // @@protoc_insertion_point(destructor:openfga.v1.ReadChangesResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReadChangesResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.changes_.~RepeatedPtrField();
  _impl_.continuation_token_.Destroy();
}

void ReadChangesResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReadChangesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.ReadChangesResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.changes_.Clear();
  _impl_.continuation_token_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReadChangesResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .openfga.v1.TupleChange changes = 1 [json_name = "changes", (.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_changes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string continuation_token = 2 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_continuation_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ReadChangesResponse.continuation_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReadChangesResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.ReadChangesResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .openfga.v1.TupleChange changes = 1 [json_name = "changes", (.google.api.field_behavior) = REQUIRED];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_changes_size()); i < n; i++) {
    const auto& repfield = this->_internal_changes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string continuation_token = 2 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_continuation_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_continuation_token().data(), static_cast<int>(this->_internal_continuation_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ReadChangesResponse.continuation_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_continuation_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.ReadChangesResponse)
  return target;
}

size_t ReadChangesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.ReadChangesResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .openfga.v1.TupleChange changes = 1 [json_name = "changes", (.google.api.field_behavior) = REQUIRED];
  total_size += 1UL * this->_internal_changes_size();
  for (const auto& msg : this->_impl_.changes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string continuation_token = 2 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_continuation_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_continuation_token());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReadChangesResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReadChangesResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReadChangesResponse::GetClassData() const { return &_class_data_; }


void ReadChangesResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReadChangesResponse*>(&to_msg);
  auto& from = static_cast<const ReadChangesResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.ReadChangesResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.changes_.MergeFrom(from._impl_.changes_);
  if (!from._internal_continuation_token().empty()) {
    _this->_internal_set_continuation_token(from._internal_continuation_token());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReadChangesResponse::CopyFrom(const ReadChangesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.ReadChangesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadChangesResponse::IsInitialized() const {
  return true;
}

void ReadChangesResponse::InternalSwap(ReadChangesResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.changes_.InternalSwap(&other->_impl_.changes_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.continuation_token_, lhs_arena,
      &other->_impl_.continuation_token_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ReadChangesResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[37]);
}

// ===================================================================

class CreateStoreRequest::_Internal {
 public:
};

CreateStoreRequest::CreateStoreRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.CreateStoreRequest)
}
CreateStoreRequest::CreateStoreRequest(const CreateStoreRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateStoreRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.CreateStoreRequest)
}

inline void CreateStoreRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateStoreRequest::~CreateStoreRequest() {
  // @@protoc_insertion_point(destructor:openfga.v1.CreateStoreRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateStoreRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void CreateStoreRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateStoreRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.CreateStoreRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateStoreRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [json_name = "name", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.CreateStoreRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateStoreRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.CreateStoreRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [json_name = "name", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.CreateStoreRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.CreateStoreRequest)
  return target;
}

size_t CreateStoreRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.CreateStoreRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [json_name = "name", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateStoreRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateStoreRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateStoreRequest::GetClassData() const { return &_class_data_; }


void CreateStoreRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateStoreRequest*>(&to_msg);
  auto& from = static_cast<const CreateStoreRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.CreateStoreRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateStoreRequest::CopyFrom(const CreateStoreRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.CreateStoreRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateStoreRequest::IsInitialized() const {
  return true;
}

void CreateStoreRequest::InternalSwap(CreateStoreRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateStoreRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[38]);
}

// ===================================================================

class CreateStoreResponse::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at(const CreateStoreResponse* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& updated_at(const CreateStoreResponse* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
CreateStoreResponse::_Internal::created_at(const CreateStoreResponse* msg) {
  return *msg->_impl_.created_at_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
CreateStoreResponse::_Internal::updated_at(const CreateStoreResponse* msg) {
  return *msg->_impl_.updated_at_;
}
void CreateStoreResponse::clear_created_at() {
  if (GetArenaForAllocation() == nullptr && _impl_.created_at_ != nullptr) {
    delete _impl_.created_at_;
  }
  _impl_.created_at_ = nullptr;
}
void CreateStoreResponse::clear_updated_at() {
  if (GetArenaForAllocation() == nullptr && _impl_.updated_at_ != nullptr) {
    delete _impl_.updated_at_;
  }
  _impl_.updated_at_ = nullptr;
}
CreateStoreResponse::CreateStoreResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.CreateStoreResponse)
}
CreateStoreResponse::CreateStoreResponse(const CreateStoreResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateStoreResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.created_at_){nullptr}
    , decltype(_impl_.updated_at_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_created_at()) {
    _this->_impl_.created_at_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.created_at_);
  }
  if (from._internal_has_updated_at()) {
    _this->_impl_.updated_at_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.updated_at_);
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.CreateStoreResponse)
}

inline void CreateStoreResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.created_at_){nullptr}
    , decltype(_impl_.updated_at_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateStoreResponse::~CreateStoreResponse() {
  // @@protoc_insertion_point(destructor:openfga.v1.CreateStoreResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateStoreResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.created_at_;
  if (this != internal_default_instance()) delete _impl_.updated_at_;
}

void CreateStoreResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateStoreResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.CreateStoreResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.created_at_ != nullptr) {
    delete _impl_.created_at_;
  }
  _impl_.created_at_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.updated_at_ != nullptr) {
    delete _impl_.updated_at_;
  }
  _impl_.updated_at_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateStoreResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.CreateStoreResponse.id"));
        } else
          goto handle_unusual;
        continue;
      // string name = 2 [json_name = "name", (.google.api.field_behavior) = REQUIRED];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.CreateStoreResponse.name"));
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp created_at = 3 [json_name = "created_at", (.google.api.field_behavior) = REQUIRED];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_created_at(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp updated_at = 4 [json_name = "updated_at", (.google.api.field_behavior) = REQUIRED];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_updated_at(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateStoreResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.CreateStoreResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.CreateStoreResponse.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // string name = 2 [json_name = "name", (.google.api.field_behavior) = REQUIRED];
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.CreateStoreResponse.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // .google.protobuf.Timestamp created_at = 3 [json_name = "created_at", (.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_created_at()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::created_at(this),
        _Internal::created_at(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Timestamp updated_at = 4 [json_name = "updated_at", (.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_updated_at()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::updated_at(this),
        _Internal::updated_at(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.CreateStoreResponse)
  return target;
}

size_t CreateStoreResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.CreateStoreResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string id = 1 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // string name = 2 [json_name = "name", (.google.api.field_behavior) = REQUIRED];
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .google.protobuf.Timestamp created_at = 3 [json_name = "created_at", (.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_created_at()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.created_at_);
  }

  // .google.protobuf.Timestamp updated_at = 4 [json_name = "updated_at", (.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_updated_at()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.updated_at_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateStoreResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateStoreResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateStoreResponse::GetClassData() const { return &_class_data_; }


void CreateStoreResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateStoreResponse*>(&to_msg);
  auto& from = static_cast<const CreateStoreResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.CreateStoreResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_created_at()) {
    _this->_internal_mutable_created_at()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_created_at());
  }
  if (from._internal_has_updated_at()) {
    _this->_internal_mutable_updated_at()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_updated_at());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateStoreResponse::CopyFrom(const CreateStoreResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.CreateStoreResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateStoreResponse::IsInitialized() const {
  return true;
}

void CreateStoreResponse::InternalSwap(CreateStoreResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CreateStoreResponse, _impl_.updated_at_)
      + sizeof(CreateStoreResponse::_impl_.updated_at_)
      - PROTOBUF_FIELD_OFFSET(CreateStoreResponse, _impl_.created_at_)>(
          reinterpret_cast<char*>(&_impl_.created_at_),
          reinterpret_cast<char*>(&other->_impl_.created_at_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateStoreResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[39]);
}

// ===================================================================

class UpdateStoreRequest::_Internal {
 public:
};

UpdateStoreRequest::UpdateStoreRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.UpdateStoreRequest)
}
UpdateStoreRequest::UpdateStoreRequest(const UpdateStoreRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateStoreRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.store_id_){}
    , decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_store_id().empty()) {
    _this->_impl_.store_id_.Set(from._internal_store_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.UpdateStoreRequest)
}

inline void UpdateStoreRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.store_id_){}
    , decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UpdateStoreRequest::~UpdateStoreRequest() {
  // @@protoc_insertion_point(destructor:openfga.v1.UpdateStoreRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateStoreRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.store_id_.Destroy();
  _impl_.name_.Destroy();
}

void UpdateStoreRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateStoreRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.UpdateStoreRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.store_id_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateStoreRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_store_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.UpdateStoreRequest.store_id"));
        } else
          goto handle_unusual;
        continue;
      // string name = 2 [json_name = "name", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.UpdateStoreRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateStoreRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.UpdateStoreRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_store_id().data(), static_cast<int>(this->_internal_store_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.UpdateStoreRequest.store_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_store_id(), target);
  }

  // string name = 2 [json_name = "name", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.UpdateStoreRequest.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.UpdateStoreRequest)
  return target;
}

size_t UpdateStoreRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.UpdateStoreRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_store_id());
  }

  // string name = 2 [json_name = "name", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateStoreRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateStoreRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateStoreRequest::GetClassData() const { return &_class_data_; }


void UpdateStoreRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateStoreRequest*>(&to_msg);
  auto& from = static_cast<const UpdateStoreRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.UpdateStoreRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_store_id().empty()) {
    _this->_internal_set_store_id(from._internal_store_id());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateStoreRequest::CopyFrom(const UpdateStoreRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.UpdateStoreRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateStoreRequest::IsInitialized() const {
  return true;
}

void UpdateStoreRequest::InternalSwap(UpdateStoreRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.store_id_, lhs_arena,
      &other->_impl_.store_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateStoreRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[40]);
}

// ===================================================================

class UpdateStoreResponse::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at(const UpdateStoreResponse* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& updated_at(const UpdateStoreResponse* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
UpdateStoreResponse::_Internal::created_at(const UpdateStoreResponse* msg) {
  return *msg->_impl_.created_at_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
UpdateStoreResponse::_Internal::updated_at(const UpdateStoreResponse* msg) {
  return *msg->_impl_.updated_at_;
}
void UpdateStoreResponse::clear_created_at() {
  if (GetArenaForAllocation() == nullptr && _impl_.created_at_ != nullptr) {
    delete _impl_.created_at_;
  }
  _impl_.created_at_ = nullptr;
}
void UpdateStoreResponse::clear_updated_at() {
  if (GetArenaForAllocation() == nullptr && _impl_.updated_at_ != nullptr) {
    delete _impl_.updated_at_;
  }
  _impl_.updated_at_ = nullptr;
}
UpdateStoreResponse::UpdateStoreResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.UpdateStoreResponse)
}
UpdateStoreResponse::UpdateStoreResponse(const UpdateStoreResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateStoreResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.created_at_){nullptr}
    , decltype(_impl_.updated_at_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_created_at()) {
    _this->_impl_.created_at_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.created_at_);
  }
  if (from._internal_has_updated_at()) {
    _this->_impl_.updated_at_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.updated_at_);
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.UpdateStoreResponse)
}

inline void UpdateStoreResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.created_at_){nullptr}
    , decltype(_impl_.updated_at_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UpdateStoreResponse::~UpdateStoreResponse() {
  // @@protoc_insertion_point(destructor:openfga.v1.UpdateStoreResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateStoreResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.created_at_;
  if (this != internal_default_instance()) delete _impl_.updated_at_;
}

void UpdateStoreResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateStoreResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.UpdateStoreResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.created_at_ != nullptr) {
    delete _impl_.created_at_;
  }
  _impl_.created_at_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.updated_at_ != nullptr) {
    delete _impl_.updated_at_;
  }
  _impl_.updated_at_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateStoreResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.UpdateStoreResponse.id"));
        } else
          goto handle_unusual;
        continue;
      // string name = 2 [json_name = "name", (.google.api.field_behavior) = REQUIRED];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.UpdateStoreResponse.name"));
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp created_at = 3 [json_name = "created_at", (.google.api.field_behavior) = REQUIRED];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_created_at(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp updated_at = 4 [json_name = "updated_at", (.google.api.field_behavior) = REQUIRED];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_updated_at(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateStoreResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.UpdateStoreResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.UpdateStoreResponse.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // string name = 2 [json_name = "name", (.google.api.field_behavior) = REQUIRED];
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.UpdateStoreResponse.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // .google.protobuf.Timestamp created_at = 3 [json_name = "created_at", (.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_created_at()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::created_at(this),
        _Internal::created_at(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Timestamp updated_at = 4 [json_name = "updated_at", (.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_updated_at()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::updated_at(this),
        _Internal::updated_at(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.UpdateStoreResponse)
  return target;
}

size_t UpdateStoreResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.UpdateStoreResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string id = 1 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // string name = 2 [json_name = "name", (.google.api.field_behavior) = REQUIRED];
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .google.protobuf.Timestamp created_at = 3 [json_name = "created_at", (.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_created_at()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.created_at_);
  }

  // .google.protobuf.Timestamp updated_at = 4 [json_name = "updated_at", (.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_updated_at()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.updated_at_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateStoreResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateStoreResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateStoreResponse::GetClassData() const { return &_class_data_; }


void UpdateStoreResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateStoreResponse*>(&to_msg);
  auto& from = static_cast<const UpdateStoreResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.UpdateStoreResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_created_at()) {
    _this->_internal_mutable_created_at()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_created_at());
  }
  if (from._internal_has_updated_at()) {
    _this->_internal_mutable_updated_at()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_updated_at());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateStoreResponse::CopyFrom(const UpdateStoreResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.UpdateStoreResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateStoreResponse::IsInitialized() const {
  return true;
}

void UpdateStoreResponse::InternalSwap(UpdateStoreResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateStoreResponse, _impl_.updated_at_)
      + sizeof(UpdateStoreResponse::_impl_.updated_at_)
      - PROTOBUF_FIELD_OFFSET(UpdateStoreResponse, _impl_.created_at_)>(
          reinterpret_cast<char*>(&_impl_.created_at_),
          reinterpret_cast<char*>(&other->_impl_.created_at_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateStoreResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[41]);
}

// ===================================================================

class DeleteStoreRequest::_Internal {
 public:
};

DeleteStoreRequest::DeleteStoreRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.DeleteStoreRequest)
}
DeleteStoreRequest::DeleteStoreRequest(const DeleteStoreRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeleteStoreRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.store_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_store_id().empty()) {
    _this->_impl_.store_id_.Set(from._internal_store_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.DeleteStoreRequest)
}

inline void DeleteStoreRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.store_id_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeleteStoreRequest::~DeleteStoreRequest() {
  // @@protoc_insertion_point(destructor:openfga.v1.DeleteStoreRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeleteStoreRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.store_id_.Destroy();
}

void DeleteStoreRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeleteStoreRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.DeleteStoreRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.store_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteStoreRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_store_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.DeleteStoreRequest.store_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteStoreRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.DeleteStoreRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_store_id().data(), static_cast<int>(this->_internal_store_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.DeleteStoreRequest.store_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_store_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.DeleteStoreRequest)
  return target;
}

size_t DeleteStoreRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.DeleteStoreRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_store_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteStoreRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeleteStoreRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteStoreRequest::GetClassData() const { return &_class_data_; }


void DeleteStoreRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeleteStoreRequest*>(&to_msg);
  auto& from = static_cast<const DeleteStoreRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.DeleteStoreRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_store_id().empty()) {
    _this->_internal_set_store_id(from._internal_store_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteStoreRequest::CopyFrom(const DeleteStoreRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.DeleteStoreRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteStoreRequest::IsInitialized() const {
  return true;
}

void DeleteStoreRequest::InternalSwap(DeleteStoreRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.store_id_, lhs_arena,
      &other->_impl_.store_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteStoreRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[42]);
}

// ===================================================================

class DeleteStoreResponse::_Internal {
 public:
};

DeleteStoreResponse::DeleteStoreResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:openfga.v1.DeleteStoreResponse)
}
DeleteStoreResponse::DeleteStoreResponse(const DeleteStoreResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  DeleteStoreResponse* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:openfga.v1.DeleteStoreResponse)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteStoreResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteStoreResponse::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata DeleteStoreResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[43]);
}

// ===================================================================

class GetStoreRequest::_Internal {
 public:
};

GetStoreRequest::GetStoreRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.GetStoreRequest)
}
GetStoreRequest::GetStoreRequest(const GetStoreRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetStoreRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.store_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_store_id().empty()) {
    _this->_impl_.store_id_.Set(from._internal_store_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.GetStoreRequest)
}

inline void GetStoreRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.store_id_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetStoreRequest::~GetStoreRequest() {
  // @@protoc_insertion_point(destructor:openfga.v1.GetStoreRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetStoreRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.store_id_.Destroy();
}

void GetStoreRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetStoreRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.GetStoreRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.store_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetStoreRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_store_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.GetStoreRequest.store_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetStoreRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.GetStoreRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_store_id().data(), static_cast<int>(this->_internal_store_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.GetStoreRequest.store_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_store_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.GetStoreRequest)
  return target;
}

size_t GetStoreRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.GetStoreRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string store_id = 1 [json_name = "store_id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_store_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_store_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetStoreRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetStoreRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetStoreRequest::GetClassData() const { return &_class_data_; }


void GetStoreRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetStoreRequest*>(&to_msg);
  auto& from = static_cast<const GetStoreRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.GetStoreRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_store_id().empty()) {
    _this->_internal_set_store_id(from._internal_store_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetStoreRequest::CopyFrom(const GetStoreRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.GetStoreRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetStoreRequest::IsInitialized() const {
  return true;
}

void GetStoreRequest::InternalSwap(GetStoreRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.store_id_, lhs_arena,
      &other->_impl_.store_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetStoreRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[44]);
}

// ===================================================================

class GetStoreResponse::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at(const GetStoreResponse* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& updated_at(const GetStoreResponse* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& deleted_at(const GetStoreResponse* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
GetStoreResponse::_Internal::created_at(const GetStoreResponse* msg) {
  return *msg->_impl_.created_at_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
GetStoreResponse::_Internal::updated_at(const GetStoreResponse* msg) {
  return *msg->_impl_.updated_at_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
GetStoreResponse::_Internal::deleted_at(const GetStoreResponse* msg) {
  return *msg->_impl_.deleted_at_;
}
void GetStoreResponse::clear_created_at() {
  if (GetArenaForAllocation() == nullptr && _impl_.created_at_ != nullptr) {
    delete _impl_.created_at_;
  }
  _impl_.created_at_ = nullptr;
}
void GetStoreResponse::clear_updated_at() {
  if (GetArenaForAllocation() == nullptr && _impl_.updated_at_ != nullptr) {
    delete _impl_.updated_at_;
  }
  _impl_.updated_at_ = nullptr;
}
void GetStoreResponse::clear_deleted_at() {
  if (GetArenaForAllocation() == nullptr && _impl_.deleted_at_ != nullptr) {
    delete _impl_.deleted_at_;
  }
  _impl_.deleted_at_ = nullptr;
}
GetStoreResponse::GetStoreResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.GetStoreResponse)
}
GetStoreResponse::GetStoreResponse(const GetStoreResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetStoreResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.created_at_){nullptr}
    , decltype(_impl_.updated_at_){nullptr}
    , decltype(_impl_.deleted_at_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_created_at()) {
    _this->_impl_.created_at_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.created_at_);
  }
  if (from._internal_has_updated_at()) {
    _this->_impl_.updated_at_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.updated_at_);
  }
  if (from._internal_has_deleted_at()) {
    _this->_impl_.deleted_at_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.deleted_at_);
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.GetStoreResponse)
}

inline void GetStoreResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.created_at_){nullptr}
    , decltype(_impl_.updated_at_){nullptr}
    , decltype(_impl_.deleted_at_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetStoreResponse::~GetStoreResponse() {
  // @@protoc_insertion_point(destructor:openfga.v1.GetStoreResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetStoreResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.created_at_;
  if (this != internal_default_instance()) delete _impl_.updated_at_;
  if (this != internal_default_instance()) delete _impl_.deleted_at_;
}

void GetStoreResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetStoreResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.GetStoreResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.created_at_ != nullptr) {
    delete _impl_.created_at_;
  }
  _impl_.created_at_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.updated_at_ != nullptr) {
    delete _impl_.updated_at_;
  }
  _impl_.updated_at_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.deleted_at_ != nullptr) {
    delete _impl_.deleted_at_;
  }
  _impl_.deleted_at_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetStoreResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.GetStoreResponse.id"));
        } else
          goto handle_unusual;
        continue;
      // string name = 2 [json_name = "name", (.google.api.field_behavior) = REQUIRED];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.GetStoreResponse.name"));
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp created_at = 3 [json_name = "created_at", (.google.api.field_behavior) = REQUIRED];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_created_at(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp updated_at = 4 [json_name = "updated_at", (.google.api.field_behavior) = REQUIRED];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_updated_at(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp deleted_at = 5 [json_name = "deleted_at"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_deleted_at(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetStoreResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.GetStoreResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.GetStoreResponse.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // string name = 2 [json_name = "name", (.google.api.field_behavior) = REQUIRED];
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.GetStoreResponse.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // .google.protobuf.Timestamp created_at = 3 [json_name = "created_at", (.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_created_at()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::created_at(this),
        _Internal::created_at(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Timestamp updated_at = 4 [json_name = "updated_at", (.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_updated_at()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::updated_at(this),
        _Internal::updated_at(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Timestamp deleted_at = 5 [json_name = "deleted_at"];
  if (this->_internal_has_deleted_at()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::deleted_at(this),
        _Internal::deleted_at(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.GetStoreResponse)
  return target;
}

size_t GetStoreResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.GetStoreResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string id = 1 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // string name = 2 [json_name = "name", (.google.api.field_behavior) = REQUIRED];
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .google.protobuf.Timestamp created_at = 3 [json_name = "created_at", (.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_created_at()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.created_at_);
  }

  // .google.protobuf.Timestamp updated_at = 4 [json_name = "updated_at", (.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_updated_at()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.updated_at_);
  }

  // .google.protobuf.Timestamp deleted_at = 5 [json_name = "deleted_at"];
  if (this->_internal_has_deleted_at()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.deleted_at_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetStoreResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetStoreResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetStoreResponse::GetClassData() const { return &_class_data_; }


void GetStoreResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetStoreResponse*>(&to_msg);
  auto& from = static_cast<const GetStoreResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.GetStoreResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_created_at()) {
    _this->_internal_mutable_created_at()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_created_at());
  }
  if (from._internal_has_updated_at()) {
    _this->_internal_mutable_updated_at()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_updated_at());
  }
  if (from._internal_has_deleted_at()) {
    _this->_internal_mutable_deleted_at()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_deleted_at());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetStoreResponse::CopyFrom(const GetStoreResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.GetStoreResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetStoreResponse::IsInitialized() const {
  return true;
}

void GetStoreResponse::InternalSwap(GetStoreResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetStoreResponse, _impl_.deleted_at_)
      + sizeof(GetStoreResponse::_impl_.deleted_at_)
      - PROTOBUF_FIELD_OFFSET(GetStoreResponse, _impl_.created_at_)>(
          reinterpret_cast<char*>(&_impl_.created_at_),
          reinterpret_cast<char*>(&other->_impl_.created_at_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetStoreResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[45]);
}

// ===================================================================

class ListStoresRequest::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::Int32Value& page_size(const ListStoresRequest* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Int32Value&
ListStoresRequest::_Internal::page_size(const ListStoresRequest* msg) {
  return *msg->_impl_.page_size_;
}
void ListStoresRequest::clear_page_size() {
  if (GetArenaForAllocation() == nullptr && _impl_.page_size_ != nullptr) {
    delete _impl_.page_size_;
  }
  _impl_.page_size_ = nullptr;
}
ListStoresRequest::ListStoresRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.ListStoresRequest)
}
ListStoresRequest::ListStoresRequest(const ListStoresRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListStoresRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.continuation_token_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.page_size_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.continuation_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.continuation_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_continuation_token().empty()) {
    _this->_impl_.continuation_token_.Set(from._internal_continuation_token(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_page_size()) {
    _this->_impl_.page_size_ = new ::PROTOBUF_NAMESPACE_ID::Int32Value(*from._impl_.page_size_);
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.ListStoresRequest)
}

inline void ListStoresRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.continuation_token_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.page_size_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.continuation_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.continuation_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListStoresRequest::~ListStoresRequest() {
  // @@protoc_insertion_point(destructor:openfga.v1.ListStoresRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListStoresRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.continuation_token_.Destroy();
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.page_size_;
}

void ListStoresRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListStoresRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.ListStoresRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.continuation_token_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.page_size_ != nullptr) {
    delete _impl_.page_size_;
  }
  _impl_.page_size_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListStoresRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .google.protobuf.Int32Value page_size = 1 [json_name = "page_size", (.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_page_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string continuation_token = 2 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_continuation_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ListStoresRequest.continuation_token"));
        } else
          goto handle_unusual;
        continue;
      // string name = 3 [json_name = "name", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ListStoresRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListStoresRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.ListStoresRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .google.protobuf.Int32Value page_size = 1 [json_name = "page_size", (.validate.rules) = {
  if (this->_internal_has_page_size()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::page_size(this),
        _Internal::page_size(this).GetCachedSize(), target, stream);
  }

  // string continuation_token = 2 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_continuation_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_continuation_token().data(), static_cast<int>(this->_internal_continuation_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ListStoresRequest.continuation_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_continuation_token(), target);
  }

  // string name = 3 [json_name = "name", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ListStoresRequest.name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.ListStoresRequest)
  return target;
}

size_t ListStoresRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.ListStoresRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string continuation_token = 2 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_continuation_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_continuation_token());
  }

  // string name = 3 [json_name = "name", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .google.protobuf.Int32Value page_size = 1 [json_name = "page_size", (.validate.rules) = {
  if (this->_internal_has_page_size()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.page_size_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListStoresRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListStoresRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListStoresRequest::GetClassData() const { return &_class_data_; }


void ListStoresRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListStoresRequest*>(&to_msg);
  auto& from = static_cast<const ListStoresRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.ListStoresRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_continuation_token().empty()) {
    _this->_internal_set_continuation_token(from._internal_continuation_token());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_page_size()) {
    _this->_internal_mutable_page_size()->::PROTOBUF_NAMESPACE_ID::Int32Value::MergeFrom(
        from._internal_page_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListStoresRequest::CopyFrom(const ListStoresRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.ListStoresRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListStoresRequest::IsInitialized() const {
  return true;
}

void ListStoresRequest::InternalSwap(ListStoresRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.continuation_token_, lhs_arena,
      &other->_impl_.continuation_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.page_size_, other->_impl_.page_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListStoresRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[46]);
}

// ===================================================================

class ListStoresResponse::_Internal {
 public:
};

void ListStoresResponse::clear_stores() {
  _impl_.stores_.Clear();
}
ListStoresResponse::ListStoresResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.ListStoresResponse)
}
ListStoresResponse::ListStoresResponse(const ListStoresResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListStoresResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.stores_){from._impl_.stores_}
    , decltype(_impl_.continuation_token_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.continuation_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.continuation_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_continuation_token().empty()) {
    _this->_impl_.continuation_token_.Set(from._internal_continuation_token(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.ListStoresResponse)
}

inline void ListStoresResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.stores_){arena}
    , decltype(_impl_.continuation_token_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.continuation_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.continuation_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListStoresResponse::~ListStoresResponse() {
  // @@protoc_insertion_point(destructor:openfga.v1.ListStoresResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListStoresResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stores_.~RepeatedPtrField();
  _impl_.continuation_token_.Destroy();
}

void ListStoresResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListStoresResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.ListStoresResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stores_.Clear();
  _impl_.continuation_token_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListStoresResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .openfga.v1.Store stores = 1 [json_name = "stores", (.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_stores(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string continuation_token = 2 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_continuation_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.ListStoresResponse.continuation_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListStoresResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.ListStoresResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .openfga.v1.Store stores = 1 [json_name = "stores", (.google.api.field_behavior) = REQUIRED];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_stores_size()); i < n; i++) {
    const auto& repfield = this->_internal_stores(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string continuation_token = 2 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_continuation_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_continuation_token().data(), static_cast<int>(this->_internal_continuation_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.ListStoresResponse.continuation_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_continuation_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.ListStoresResponse)
  return target;
}

size_t ListStoresResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.ListStoresResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .openfga.v1.Store stores = 1 [json_name = "stores", (.google.api.field_behavior) = REQUIRED];
  total_size += 1UL * this->_internal_stores_size();
  for (const auto& msg : this->_impl_.stores_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string continuation_token = 2 [json_name = "continuation_token", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_continuation_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_continuation_token());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListStoresResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListStoresResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListStoresResponse::GetClassData() const { return &_class_data_; }


void ListStoresResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListStoresResponse*>(&to_msg);
  auto& from = static_cast<const ListStoresResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.ListStoresResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.stores_.MergeFrom(from._impl_.stores_);
  if (!from._internal_continuation_token().empty()) {
    _this->_internal_set_continuation_token(from._internal_continuation_token());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListStoresResponse::CopyFrom(const ListStoresResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.ListStoresResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListStoresResponse::IsInitialized() const {
  return true;
}

void ListStoresResponse::InternalSwap(ListStoresResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.stores_.InternalSwap(&other->_impl_.stores_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.continuation_token_, lhs_arena,
      &other->_impl_.continuation_token_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ListStoresResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[47]);
}

// ===================================================================

class AssertionTupleKey::_Internal {
 public:
};

AssertionTupleKey::AssertionTupleKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.AssertionTupleKey)
}
AssertionTupleKey::AssertionTupleKey(const AssertionTupleKey& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AssertionTupleKey* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.object_){}
    , decltype(_impl_.relation_){}
    , decltype(_impl_.user_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.object_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.object_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_object().empty()) {
    _this->_impl_.object_.Set(from._internal_object(), 
      _this->GetArenaForAllocation());
  }
  _impl_.relation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_relation().empty()) {
    _this->_impl_.relation_.Set(from._internal_relation(), 
      _this->GetArenaForAllocation());
  }
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user().empty()) {
    _this->_impl_.user_.Set(from._internal_user(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:openfga.v1.AssertionTupleKey)
}

inline void AssertionTupleKey::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.object_){}
    , decltype(_impl_.relation_){}
    , decltype(_impl_.user_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.object_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.object_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.relation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AssertionTupleKey::~AssertionTupleKey() {
  // @@protoc_insertion_point(destructor:openfga.v1.AssertionTupleKey)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AssertionTupleKey::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.object_.Destroy();
  _impl_.relation_.Destroy();
  _impl_.user_.Destroy();
}

void AssertionTupleKey::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AssertionTupleKey::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.AssertionTupleKey)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.object_.ClearToEmpty();
  _impl_.relation_.ClearToEmpty();
  _impl_.user_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AssertionTupleKey::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string object = 1 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_object();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.AssertionTupleKey.object"));
        } else
          goto handle_unusual;
        continue;
      // string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_relation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.AssertionTupleKey.relation"));
        } else
          goto handle_unusual;
        continue;
      // string user = 3 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_user();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "openfga.v1.AssertionTupleKey.user"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AssertionTupleKey::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.AssertionTupleKey)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string object = 1 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_object().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_object().data(), static_cast<int>(this->_internal_object().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.AssertionTupleKey.object");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_object(), target);
  }

  // string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_relation().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_relation().data(), static_cast<int>(this->_internal_relation().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.AssertionTupleKey.relation");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_relation(), target);
  }

  // string user = 3 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_user().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user().data(), static_cast<int>(this->_internal_user().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "openfga.v1.AssertionTupleKey.user");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_user(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.AssertionTupleKey)
  return target;
}

size_t AssertionTupleKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.AssertionTupleKey)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string object = 1 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_object().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_object());
  }

  // string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_relation().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_relation());
  }

  // string user = 3 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (!this->_internal_user().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AssertionTupleKey::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AssertionTupleKey::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AssertionTupleKey::GetClassData() const { return &_class_data_; }


void AssertionTupleKey::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AssertionTupleKey*>(&to_msg);
  auto& from = static_cast<const AssertionTupleKey&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.AssertionTupleKey)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_object().empty()) {
    _this->_internal_set_object(from._internal_object());
  }
  if (!from._internal_relation().empty()) {
    _this->_internal_set_relation(from._internal_relation());
  }
  if (!from._internal_user().empty()) {
    _this->_internal_set_user(from._internal_user());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AssertionTupleKey::CopyFrom(const AssertionTupleKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.AssertionTupleKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AssertionTupleKey::IsInitialized() const {
  return true;
}

void AssertionTupleKey::InternalSwap(AssertionTupleKey* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.object_, lhs_arena,
      &other->_impl_.object_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.relation_, lhs_arena,
      &other->_impl_.relation_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_, lhs_arena,
      &other->_impl_.user_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata AssertionTupleKey::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[48]);
}

// ===================================================================

class Assertion::_Internal {
 public:
  static const ::openfga::v1::AssertionTupleKey& tuple_key(const Assertion* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Struct& context(const Assertion* msg);
};

const ::openfga::v1::AssertionTupleKey&
Assertion::_Internal::tuple_key(const Assertion* msg) {
  return *msg->_impl_.tuple_key_;
}
const ::PROTOBUF_NAMESPACE_ID::Struct&
Assertion::_Internal::context(const Assertion* msg) {
  return *msg->_impl_.context_;
}
void Assertion::clear_contextual_tuples() {
  _impl_.contextual_tuples_.Clear();
}
void Assertion::clear_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
    delete _impl_.context_;
  }
  _impl_.context_ = nullptr;
}
Assertion::Assertion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.Assertion)
}
Assertion::Assertion(const Assertion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Assertion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.contextual_tuples_){from._impl_.contextual_tuples_}
    , decltype(_impl_.tuple_key_){nullptr}
    , decltype(_impl_.context_){nullptr}
    , decltype(_impl_.expectation_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_tuple_key()) {
    _this->_impl_.tuple_key_ = new ::openfga::v1::AssertionTupleKey(*from._impl_.tuple_key_);
  }
  if (from._internal_has_context()) {
    _this->_impl_.context_ = new ::PROTOBUF_NAMESPACE_ID::Struct(*from._impl_.context_);
  }
  _this->_impl_.expectation_ = from._impl_.expectation_;
  // @@protoc_insertion_point(copy_constructor:openfga.v1.Assertion)
}

inline void Assertion::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.contextual_tuples_){arena}
    , decltype(_impl_.tuple_key_){nullptr}
    , decltype(_impl_.context_){nullptr}
    , decltype(_impl_.expectation_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Assertion::~Assertion() {
  // @@protoc_insertion_point(destructor:openfga.v1.Assertion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Assertion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contextual_tuples_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.tuple_key_;
  if (this != internal_default_instance()) delete _impl_.context_;
}

void Assertion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Assertion::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.Assertion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.contextual_tuples_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.tuple_key_ != nullptr) {
    delete _impl_.tuple_key_;
  }
  _impl_.tuple_key_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
    delete _impl_.context_;
  }
  _impl_.context_ = nullptr;
  _impl_.expectation_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Assertion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .openfga.v1.AssertionTupleKey tuple_key = 1 [json_name = "tuple_key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_tuple_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool expectation = 2 [json_name = "expectation", (.google.api.field_behavior) = REQUIRED];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.expectation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .openfga.v1.TupleKey contextual_tuples = 3 [json_name = "contextual_tuples", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_contextual_tuples(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Struct context = 4 [json_name = "context", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_context(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Assertion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.Assertion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .openfga.v1.AssertionTupleKey tuple_key = 1 [json_name = "tuple_key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (this->_internal_has_tuple_key()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::tuple_key(this),
        _Internal::tuple_key(this).GetCachedSize(), target, stream);
  }

  // bool expectation = 2 [json_name = "expectation", (.google.api.field_behavior) = REQUIRED];
  if (this->_internal_expectation() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_expectation(), target);
  }

  // repeated .openfga.v1.TupleKey contextual_tuples = 3 [json_name = "contextual_tuples", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_contextual_tuples_size()); i < n; i++) {
    const auto& repfield = this->_internal_contextual_tuples(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .google.protobuf.Struct context = 4 [json_name = "context", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (this->_internal_has_context()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::context(this),
        _Internal::context(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.Assertion)
  return target;
}

size_t Assertion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.Assertion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .openfga.v1.TupleKey contextual_tuples = 3 [json_name = "contextual_tuples", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  total_size += 1UL * this->_internal_contextual_tuples_size();
  for (const auto& msg : this->_impl_.contextual_tuples_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .openfga.v1.AssertionTupleKey tuple_key = 1 [json_name = "tuple_key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  if (this->_internal_has_tuple_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tuple_key_);
  }

  // .google.protobuf.Struct context = 4 [json_name = "context", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  if (this->_internal_has_context()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.context_);
  }

  // bool expectation = 2 [json_name = "expectation", (.google.api.field_behavior) = REQUIRED];
  if (this->_internal_expectation() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Assertion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Assertion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Assertion::GetClassData() const { return &_class_data_; }


void Assertion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Assertion*>(&to_msg);
  auto& from = static_cast<const Assertion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.Assertion)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.contextual_tuples_.MergeFrom(from._impl_.contextual_tuples_);
  if (from._internal_has_tuple_key()) {
    _this->_internal_mutable_tuple_key()->::openfga::v1::AssertionTupleKey::MergeFrom(
        from._internal_tuple_key());
  }
  if (from._internal_has_context()) {
    _this->_internal_mutable_context()->::PROTOBUF_NAMESPACE_ID::Struct::MergeFrom(
        from._internal_context());
  }
  if (from._internal_expectation() != 0) {
    _this->_internal_set_expectation(from._internal_expectation());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Assertion::CopyFrom(const Assertion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.Assertion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Assertion::IsInitialized() const {
  return true;
}

void Assertion::InternalSwap(Assertion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.contextual_tuples_.InternalSwap(&other->_impl_.contextual_tuples_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Assertion, _impl_.expectation_)
      + sizeof(Assertion::_impl_.expectation_)
      - PROTOBUF_FIELD_OFFSET(Assertion, _impl_.tuple_key_)>(
          reinterpret_cast<char*>(&_impl_.tuple_key_),
          reinterpret_cast<char*>(&other->_impl_.tuple_key_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Assertion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[49]);
}

// ===================================================================

class Assertions::_Internal {
 public:
};

Assertions::Assertions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:openfga.v1.Assertions)
}
Assertions::Assertions(const Assertions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Assertions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.assertions_){from._impl_.assertions_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:openfga.v1.Assertions)
}

inline void Assertions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.assertions_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Assertions::~Assertions() {
  // @@protoc_insertion_point(destructor:openfga.v1.Assertions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Assertions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.assertions_.~RepeatedPtrField();
}

void Assertions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Assertions::Clear() {
// @@protoc_insertion_point(message_clear_start:openfga.v1.Assertions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.assertions_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Assertions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .openfga.v1.Assertion assertions = 1 [json_name = "assertions", (.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_assertions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Assertions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openfga.v1.Assertions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .openfga.v1.Assertion assertions = 1 [json_name = "assertions", (.google.api.field_behavior) = REQUIRED];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_assertions_size()); i < n; i++) {
    const auto& repfield = this->_internal_assertions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openfga.v1.Assertions)
  return target;
}

size_t Assertions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openfga.v1.Assertions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .openfga.v1.Assertion assertions = 1 [json_name = "assertions", (.google.api.field_behavior) = REQUIRED];
  total_size += 1UL * this->_internal_assertions_size();
  for (const auto& msg : this->_impl_.assertions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Assertions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Assertions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Assertions::GetClassData() const { return &_class_data_; }


void Assertions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Assertions*>(&to_msg);
  auto& from = static_cast<const Assertions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:openfga.v1.Assertions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.assertions_.MergeFrom(from._impl_.assertions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Assertions::CopyFrom(const Assertions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openfga.v1.Assertions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Assertions::IsInitialized() const {
  return true;
}

void Assertions::InternalSwap(Assertions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.assertions_.InternalSwap(&other->_impl_.assertions_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Assertions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_getter, &descriptor_table_openfga_2fv1_2fopenfga_5fservice_2eproto_once,
      file_level_metadata_openfga_2fv1_2fopenfga_5fservice_2eproto[50]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace openfga
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::openfga::v1::ListObjectsRequest*
Arena::CreateMaybeMessage< ::openfga::v1::ListObjectsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::ListObjectsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::ListObjectsResponse*
Arena::CreateMaybeMessage< ::openfga::v1::ListObjectsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::ListObjectsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::ListUsersRequest*
Arena::CreateMaybeMessage< ::openfga::v1::ListUsersRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::ListUsersRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::ListUsersResponse*
Arena::CreateMaybeMessage< ::openfga::v1::ListUsersResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::ListUsersResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::StreamedListObjectsRequest*
Arena::CreateMaybeMessage< ::openfga::v1::StreamedListObjectsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::StreamedListObjectsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::StreamedListObjectsResponse*
Arena::CreateMaybeMessage< ::openfga::v1::StreamedListObjectsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::StreamedListObjectsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::ReadRequest*
Arena::CreateMaybeMessage< ::openfga::v1::ReadRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::ReadRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::ReadRequestTupleKey*
Arena::CreateMaybeMessage< ::openfga::v1::ReadRequestTupleKey >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::ReadRequestTupleKey >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::ReadResponse*
Arena::CreateMaybeMessage< ::openfga::v1::ReadResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::ReadResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::WriteRequestWrites*
Arena::CreateMaybeMessage< ::openfga::v1::WriteRequestWrites >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::WriteRequestWrites >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::WriteRequestDeletes*
Arena::CreateMaybeMessage< ::openfga::v1::WriteRequestDeletes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::WriteRequestDeletes >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::WriteRequest*
Arena::CreateMaybeMessage< ::openfga::v1::WriteRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::WriteRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::WriteResponse*
Arena::CreateMaybeMessage< ::openfga::v1::WriteResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::WriteResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::CheckRequest*
Arena::CreateMaybeMessage< ::openfga::v1::CheckRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::CheckRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::CheckRequestTupleKey*
Arena::CreateMaybeMessage< ::openfga::v1::CheckRequestTupleKey >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::CheckRequestTupleKey >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::CheckResponse*
Arena::CreateMaybeMessage< ::openfga::v1::CheckResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::CheckResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::BatchCheckRequest*
Arena::CreateMaybeMessage< ::openfga::v1::BatchCheckRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::BatchCheckRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::BatchCheckItem*
Arena::CreateMaybeMessage< ::openfga::v1::BatchCheckItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::BatchCheckItem >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::BatchCheckResponse_ResultEntry_DoNotUse*
Arena::CreateMaybeMessage< ::openfga::v1::BatchCheckResponse_ResultEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::BatchCheckResponse_ResultEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::BatchCheckResponse*
Arena::CreateMaybeMessage< ::openfga::v1::BatchCheckResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::BatchCheckResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::BatchCheckSingleResult*
Arena::CreateMaybeMessage< ::openfga::v1::BatchCheckSingleResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::BatchCheckSingleResult >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::CheckError*
Arena::CreateMaybeMessage< ::openfga::v1::CheckError >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::CheckError >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::ExpandRequest*
Arena::CreateMaybeMessage< ::openfga::v1::ExpandRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::ExpandRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::ExpandRequestTupleKey*
Arena::CreateMaybeMessage< ::openfga::v1::ExpandRequestTupleKey >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::ExpandRequestTupleKey >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::ExpandResponse*
Arena::CreateMaybeMessage< ::openfga::v1::ExpandResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::ExpandResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::ReadAuthorizationModelRequest*
Arena::CreateMaybeMessage< ::openfga::v1::ReadAuthorizationModelRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::ReadAuthorizationModelRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::ReadAuthorizationModelResponse*
Arena::CreateMaybeMessage< ::openfga::v1::ReadAuthorizationModelResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::ReadAuthorizationModelResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::openfga::v1::WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::WriteAuthorizationModelRequest_ConditionsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::WriteAuthorizationModelRequest*
Arena::CreateMaybeMessage< ::openfga::v1::WriteAuthorizationModelRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::WriteAuthorizationModelRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::WriteAuthorizationModelResponse*
Arena::CreateMaybeMessage< ::openfga::v1::WriteAuthorizationModelResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::WriteAuthorizationModelResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::ReadAuthorizationModelsRequest*
Arena::CreateMaybeMessage< ::openfga::v1::ReadAuthorizationModelsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::ReadAuthorizationModelsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::ReadAuthorizationModelsResponse*
Arena::CreateMaybeMessage< ::openfga::v1::ReadAuthorizationModelsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::ReadAuthorizationModelsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::WriteAssertionsRequest*
Arena::CreateMaybeMessage< ::openfga::v1::WriteAssertionsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::WriteAssertionsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::WriteAssertionsResponse*
Arena::CreateMaybeMessage< ::openfga::v1::WriteAssertionsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::WriteAssertionsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::ReadAssertionsRequest*
Arena::CreateMaybeMessage< ::openfga::v1::ReadAssertionsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::ReadAssertionsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::ReadAssertionsResponse*
Arena::CreateMaybeMessage< ::openfga::v1::ReadAssertionsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::ReadAssertionsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::ReadChangesRequest*
Arena::CreateMaybeMessage< ::openfga::v1::ReadChangesRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::ReadChangesRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::ReadChangesResponse*
Arena::CreateMaybeMessage< ::openfga::v1::ReadChangesResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::ReadChangesResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::CreateStoreRequest*
Arena::CreateMaybeMessage< ::openfga::v1::CreateStoreRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::CreateStoreRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::CreateStoreResponse*
Arena::CreateMaybeMessage< ::openfga::v1::CreateStoreResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::CreateStoreResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::UpdateStoreRequest*
Arena::CreateMaybeMessage< ::openfga::v1::UpdateStoreRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::UpdateStoreRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::UpdateStoreResponse*
Arena::CreateMaybeMessage< ::openfga::v1::UpdateStoreResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::UpdateStoreResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::DeleteStoreRequest*
Arena::CreateMaybeMessage< ::openfga::v1::DeleteStoreRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::DeleteStoreRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::DeleteStoreResponse*
Arena::CreateMaybeMessage< ::openfga::v1::DeleteStoreResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::DeleteStoreResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::GetStoreRequest*
Arena::CreateMaybeMessage< ::openfga::v1::GetStoreRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::GetStoreRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::GetStoreResponse*
Arena::CreateMaybeMessage< ::openfga::v1::GetStoreResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::GetStoreResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::ListStoresRequest*
Arena::CreateMaybeMessage< ::openfga::v1::ListStoresRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::ListStoresRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::ListStoresResponse*
Arena::CreateMaybeMessage< ::openfga::v1::ListStoresResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::ListStoresResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::AssertionTupleKey*
Arena::CreateMaybeMessage< ::openfga::v1::AssertionTupleKey >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::AssertionTupleKey >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::Assertion*
Arena::CreateMaybeMessage< ::openfga::v1::Assertion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::Assertion >(arena);
}
template<> PROTOBUF_NOINLINE ::openfga::v1::Assertions*
Arena::CreateMaybeMessage< ::openfga::v1::Assertions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openfga::v1::Assertions >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
