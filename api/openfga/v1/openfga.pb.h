// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: openfga/v1/openfga.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_openfga_2fv1_2fopenfga_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_openfga_2fv1_2fopenfga_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/field_behavior.pb.h"
#include <google/protobuf/struct.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include "protoc-gen-openapiv2/options/annotations.pb.h"
#include "validate/validate.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_openfga_2fv1_2fopenfga_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_openfga_2fv1_2fopenfga_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_openfga_2fv1_2fopenfga_2eproto;
namespace openfga {
namespace v1 {
class ContextualTupleKeys;
struct ContextualTupleKeysDefaultTypeInternal;
extern ContextualTupleKeysDefaultTypeInternal _ContextualTupleKeys_default_instance_;
class Object;
struct ObjectDefaultTypeInternal;
extern ObjectDefaultTypeInternal _Object_default_instance_;
class RelationshipCondition;
struct RelationshipConditionDefaultTypeInternal;
extern RelationshipConditionDefaultTypeInternal _RelationshipCondition_default_instance_;
class Store;
struct StoreDefaultTypeInternal;
extern StoreDefaultTypeInternal _Store_default_instance_;
class Tuple;
struct TupleDefaultTypeInternal;
extern TupleDefaultTypeInternal _Tuple_default_instance_;
class TupleChange;
struct TupleChangeDefaultTypeInternal;
extern TupleChangeDefaultTypeInternal _TupleChange_default_instance_;
class TupleKey;
struct TupleKeyDefaultTypeInternal;
extern TupleKeyDefaultTypeInternal _TupleKey_default_instance_;
class TupleKeyWithoutCondition;
struct TupleKeyWithoutConditionDefaultTypeInternal;
extern TupleKeyWithoutConditionDefaultTypeInternal _TupleKeyWithoutCondition_default_instance_;
class TupleKeys;
struct TupleKeysDefaultTypeInternal;
extern TupleKeysDefaultTypeInternal _TupleKeys_default_instance_;
class TypedWildcard;
struct TypedWildcardDefaultTypeInternal;
extern TypedWildcardDefaultTypeInternal _TypedWildcard_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class UserTypeFilter;
struct UserTypeFilterDefaultTypeInternal;
extern UserTypeFilterDefaultTypeInternal _UserTypeFilter_default_instance_;
class UsersetTree;
struct UsersetTreeDefaultTypeInternal;
extern UsersetTreeDefaultTypeInternal _UsersetTree_default_instance_;
class UsersetTree_Computed;
struct UsersetTree_ComputedDefaultTypeInternal;
extern UsersetTree_ComputedDefaultTypeInternal _UsersetTree_Computed_default_instance_;
class UsersetTree_Difference;
struct UsersetTree_DifferenceDefaultTypeInternal;
extern UsersetTree_DifferenceDefaultTypeInternal _UsersetTree_Difference_default_instance_;
class UsersetTree_Leaf;
struct UsersetTree_LeafDefaultTypeInternal;
extern UsersetTree_LeafDefaultTypeInternal _UsersetTree_Leaf_default_instance_;
class UsersetTree_Node;
struct UsersetTree_NodeDefaultTypeInternal;
extern UsersetTree_NodeDefaultTypeInternal _UsersetTree_Node_default_instance_;
class UsersetTree_Nodes;
struct UsersetTree_NodesDefaultTypeInternal;
extern UsersetTree_NodesDefaultTypeInternal _UsersetTree_Nodes_default_instance_;
class UsersetTree_TupleToUserset;
struct UsersetTree_TupleToUsersetDefaultTypeInternal;
extern UsersetTree_TupleToUsersetDefaultTypeInternal _UsersetTree_TupleToUserset_default_instance_;
class UsersetTree_Users;
struct UsersetTree_UsersDefaultTypeInternal;
extern UsersetTree_UsersDefaultTypeInternal _UsersetTree_Users_default_instance_;
class UsersetUser;
struct UsersetUserDefaultTypeInternal;
extern UsersetUserDefaultTypeInternal _UsersetUser_default_instance_;
}  // namespace v1
}  // namespace openfga
PROTOBUF_NAMESPACE_OPEN
template<> ::openfga::v1::ContextualTupleKeys* Arena::CreateMaybeMessage<::openfga::v1::ContextualTupleKeys>(Arena*);
template<> ::openfga::v1::Object* Arena::CreateMaybeMessage<::openfga::v1::Object>(Arena*);
template<> ::openfga::v1::RelationshipCondition* Arena::CreateMaybeMessage<::openfga::v1::RelationshipCondition>(Arena*);
template<> ::openfga::v1::Store* Arena::CreateMaybeMessage<::openfga::v1::Store>(Arena*);
template<> ::openfga::v1::Tuple* Arena::CreateMaybeMessage<::openfga::v1::Tuple>(Arena*);
template<> ::openfga::v1::TupleChange* Arena::CreateMaybeMessage<::openfga::v1::TupleChange>(Arena*);
template<> ::openfga::v1::TupleKey* Arena::CreateMaybeMessage<::openfga::v1::TupleKey>(Arena*);
template<> ::openfga::v1::TupleKeyWithoutCondition* Arena::CreateMaybeMessage<::openfga::v1::TupleKeyWithoutCondition>(Arena*);
template<> ::openfga::v1::TupleKeys* Arena::CreateMaybeMessage<::openfga::v1::TupleKeys>(Arena*);
template<> ::openfga::v1::TypedWildcard* Arena::CreateMaybeMessage<::openfga::v1::TypedWildcard>(Arena*);
template<> ::openfga::v1::User* Arena::CreateMaybeMessage<::openfga::v1::User>(Arena*);
template<> ::openfga::v1::UserTypeFilter* Arena::CreateMaybeMessage<::openfga::v1::UserTypeFilter>(Arena*);
template<> ::openfga::v1::UsersetTree* Arena::CreateMaybeMessage<::openfga::v1::UsersetTree>(Arena*);
template<> ::openfga::v1::UsersetTree_Computed* Arena::CreateMaybeMessage<::openfga::v1::UsersetTree_Computed>(Arena*);
template<> ::openfga::v1::UsersetTree_Difference* Arena::CreateMaybeMessage<::openfga::v1::UsersetTree_Difference>(Arena*);
template<> ::openfga::v1::UsersetTree_Leaf* Arena::CreateMaybeMessage<::openfga::v1::UsersetTree_Leaf>(Arena*);
template<> ::openfga::v1::UsersetTree_Node* Arena::CreateMaybeMessage<::openfga::v1::UsersetTree_Node>(Arena*);
template<> ::openfga::v1::UsersetTree_Nodes* Arena::CreateMaybeMessage<::openfga::v1::UsersetTree_Nodes>(Arena*);
template<> ::openfga::v1::UsersetTree_TupleToUserset* Arena::CreateMaybeMessage<::openfga::v1::UsersetTree_TupleToUserset>(Arena*);
template<> ::openfga::v1::UsersetTree_Users* Arena::CreateMaybeMessage<::openfga::v1::UsersetTree_Users>(Arena*);
template<> ::openfga::v1::UsersetUser* Arena::CreateMaybeMessage<::openfga::v1::UsersetUser>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace openfga {
namespace v1 {

enum TupleOperation : int {
  TUPLE_OPERATION_WRITE = 0,
  TUPLE_OPERATION_DELETE = 1,
  TupleOperation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TupleOperation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TupleOperation_IsValid(int value);
constexpr TupleOperation TupleOperation_MIN = TUPLE_OPERATION_WRITE;
constexpr TupleOperation TupleOperation_MAX = TUPLE_OPERATION_DELETE;
constexpr int TupleOperation_ARRAYSIZE = TupleOperation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TupleOperation_descriptor();
template<typename T>
inline const std::string& TupleOperation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TupleOperation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TupleOperation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TupleOperation_descriptor(), enum_t_value);
}
inline bool TupleOperation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TupleOperation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TupleOperation>(
    TupleOperation_descriptor(), name, value);
}
// ===================================================================

class Object final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.Object) */ {
 public:
  inline Object() : Object(nullptr) {}
  ~Object() override;
  explicit PROTOBUF_CONSTEXPR Object(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Object(const Object& from);
  Object(Object&& from) noexcept
    : Object() {
    *this = ::std::move(from);
  }

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }
  inline Object& operator=(Object&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Object& default_instance() {
    return *internal_default_instance();
  }
  static inline const Object* internal_default_instance() {
    return reinterpret_cast<const Object*>(
               &_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Object& a, Object& b) {
    a.Swap(&b);
  }
  inline void Swap(Object* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Object* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Object* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Object>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Object& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Object& from) {
    Object::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Object* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.Object";
  }
  protected:
  explicit Object(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // string type = 1 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string id = 2 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.Object)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_2eproto;
};
// -------------------------------------------------------------------

class User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  explicit PROTOBUF_CONSTEXPR User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  enum UserCase {
    kObject = 1,
    kUserset = 2,
    kWildcard = 3,
    USER_NOT_SET = 0,
  };

  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const User& from) {
    User::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
    kUsersetFieldNumber = 2,
    kWildcardFieldNumber = 3,
  };
  // .openfga.v1.Object object = 1 [json_name = "object"];
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::openfga::v1::Object& object() const;
  PROTOBUF_NODISCARD ::openfga::v1::Object* release_object();
  ::openfga::v1::Object* mutable_object();
  void set_allocated_object(::openfga::v1::Object* object);
  private:
  const ::openfga::v1::Object& _internal_object() const;
  ::openfga::v1::Object* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::openfga::v1::Object* object);
  ::openfga::v1::Object* unsafe_arena_release_object();

  // .openfga.v1.UsersetUser userset = 2 [json_name = "userset"];
  bool has_userset() const;
  private:
  bool _internal_has_userset() const;
  public:
  void clear_userset();
  const ::openfga::v1::UsersetUser& userset() const;
  PROTOBUF_NODISCARD ::openfga::v1::UsersetUser* release_userset();
  ::openfga::v1::UsersetUser* mutable_userset();
  void set_allocated_userset(::openfga::v1::UsersetUser* userset);
  private:
  const ::openfga::v1::UsersetUser& _internal_userset() const;
  ::openfga::v1::UsersetUser* _internal_mutable_userset();
  public:
  void unsafe_arena_set_allocated_userset(
      ::openfga::v1::UsersetUser* userset);
  ::openfga::v1::UsersetUser* unsafe_arena_release_userset();

  // .openfga.v1.TypedWildcard wildcard = 3 [json_name = "wildcard"];
  bool has_wildcard() const;
  private:
  bool _internal_has_wildcard() const;
  public:
  void clear_wildcard();
  const ::openfga::v1::TypedWildcard& wildcard() const;
  PROTOBUF_NODISCARD ::openfga::v1::TypedWildcard* release_wildcard();
  ::openfga::v1::TypedWildcard* mutable_wildcard();
  void set_allocated_wildcard(::openfga::v1::TypedWildcard* wildcard);
  private:
  const ::openfga::v1::TypedWildcard& _internal_wildcard() const;
  ::openfga::v1::TypedWildcard* _internal_mutable_wildcard();
  public:
  void unsafe_arena_set_allocated_wildcard(
      ::openfga::v1::TypedWildcard* wildcard);
  ::openfga::v1::TypedWildcard* unsafe_arena_release_wildcard();

  void clear_user();
  UserCase user_case() const;
  // @@protoc_insertion_point(class_scope:openfga.v1.User)
 private:
  class _Internal;
  void set_has_object();
  void set_has_userset();
  void set_has_wildcard();

  inline bool has_user() const;
  inline void clear_has_user();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union UserUnion {
      constexpr UserUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::openfga::v1::Object* object_;
      ::openfga::v1::UsersetUser* userset_;
      ::openfga::v1::TypedWildcard* wildcard_;
    } user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_2eproto;
};
// -------------------------------------------------------------------

class UsersetUser final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.UsersetUser) */ {
 public:
  inline UsersetUser() : UsersetUser(nullptr) {}
  ~UsersetUser() override;
  explicit PROTOBUF_CONSTEXPR UsersetUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UsersetUser(const UsersetUser& from);
  UsersetUser(UsersetUser&& from) noexcept
    : UsersetUser() {
    *this = ::std::move(from);
  }

  inline UsersetUser& operator=(const UsersetUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsersetUser& operator=(UsersetUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UsersetUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const UsersetUser* internal_default_instance() {
    return reinterpret_cast<const UsersetUser*>(
               &_UsersetUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UsersetUser& a, UsersetUser& b) {
    a.Swap(&b);
  }
  inline void Swap(UsersetUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UsersetUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UsersetUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UsersetUser>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UsersetUser& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UsersetUser& from) {
    UsersetUser::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsersetUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.UsersetUser";
  }
  protected:
  explicit UsersetUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kIdFieldNumber = 2,
    kRelationFieldNumber = 3,
  };
  // string type = 1 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string id = 2 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string relation = 3 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_relation();
  const std::string& relation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_relation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_relation();
  PROTOBUF_NODISCARD std::string* release_relation();
  void set_allocated_relation(std::string* relation);
  private:
  const std::string& _internal_relation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relation(const std::string& value);
  std::string* _internal_mutable_relation();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.UsersetUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_2eproto;
};
// -------------------------------------------------------------------

class RelationshipCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.RelationshipCondition) */ {
 public:
  inline RelationshipCondition() : RelationshipCondition(nullptr) {}
  ~RelationshipCondition() override;
  explicit PROTOBUF_CONSTEXPR RelationshipCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelationshipCondition(const RelationshipCondition& from);
  RelationshipCondition(RelationshipCondition&& from) noexcept
    : RelationshipCondition() {
    *this = ::std::move(from);
  }

  inline RelationshipCondition& operator=(const RelationshipCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelationshipCondition& operator=(RelationshipCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelationshipCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelationshipCondition* internal_default_instance() {
    return reinterpret_cast<const RelationshipCondition*>(
               &_RelationshipCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RelationshipCondition& a, RelationshipCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(RelationshipCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelationshipCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelationshipCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelationshipCondition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RelationshipCondition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RelationshipCondition& from) {
    RelationshipCondition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelationshipCondition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.RelationshipCondition";
  }
  protected:
  explicit RelationshipCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kContextFieldNumber = 2,
  };
  // string name = 1 [json_name = "name", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Struct context = 2 [json_name = "context"];
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::PROTOBUF_NAMESPACE_ID::Struct& context() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_context();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_context();
  void set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_context() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::PROTOBUF_NAMESPACE_ID::Struct* context);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_context();

  // @@protoc_insertion_point(class_scope:openfga.v1.RelationshipCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::Struct* context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_2eproto;
};
// -------------------------------------------------------------------

class TupleKeyWithoutCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.TupleKeyWithoutCondition) */ {
 public:
  inline TupleKeyWithoutCondition() : TupleKeyWithoutCondition(nullptr) {}
  ~TupleKeyWithoutCondition() override;
  explicit PROTOBUF_CONSTEXPR TupleKeyWithoutCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TupleKeyWithoutCondition(const TupleKeyWithoutCondition& from);
  TupleKeyWithoutCondition(TupleKeyWithoutCondition&& from) noexcept
    : TupleKeyWithoutCondition() {
    *this = ::std::move(from);
  }

  inline TupleKeyWithoutCondition& operator=(const TupleKeyWithoutCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline TupleKeyWithoutCondition& operator=(TupleKeyWithoutCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TupleKeyWithoutCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const TupleKeyWithoutCondition* internal_default_instance() {
    return reinterpret_cast<const TupleKeyWithoutCondition*>(
               &_TupleKeyWithoutCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TupleKeyWithoutCondition& a, TupleKeyWithoutCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(TupleKeyWithoutCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TupleKeyWithoutCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TupleKeyWithoutCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TupleKeyWithoutCondition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TupleKeyWithoutCondition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TupleKeyWithoutCondition& from) {
    TupleKeyWithoutCondition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TupleKeyWithoutCondition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.TupleKeyWithoutCondition";
  }
  protected:
  explicit TupleKeyWithoutCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kRelationFieldNumber = 2,
    kObjectFieldNumber = 3,
  };
  // string user = 1 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_relation();
  const std::string& relation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_relation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_relation();
  PROTOBUF_NODISCARD std::string* release_relation();
  void set_allocated_relation(std::string* relation);
  private:
  const std::string& _internal_relation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relation(const std::string& value);
  std::string* _internal_mutable_relation();
  public:

  // string object = 3 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_object();
  const std::string& object() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_object(ArgT0&& arg0, ArgT... args);
  std::string* mutable_object();
  PROTOBUF_NODISCARD std::string* release_object();
  void set_allocated_object(std::string* object);
  private:
  const std::string& _internal_object() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object(const std::string& value);
  std::string* _internal_mutable_object();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.TupleKeyWithoutCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr object_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_2eproto;
};
// -------------------------------------------------------------------

class TypedWildcard final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.TypedWildcard) */ {
 public:
  inline TypedWildcard() : TypedWildcard(nullptr) {}
  ~TypedWildcard() override;
  explicit PROTOBUF_CONSTEXPR TypedWildcard(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TypedWildcard(const TypedWildcard& from);
  TypedWildcard(TypedWildcard&& from) noexcept
    : TypedWildcard() {
    *this = ::std::move(from);
  }

  inline TypedWildcard& operator=(const TypedWildcard& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypedWildcard& operator=(TypedWildcard&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypedWildcard& default_instance() {
    return *internal_default_instance();
  }
  static inline const TypedWildcard* internal_default_instance() {
    return reinterpret_cast<const TypedWildcard*>(
               &_TypedWildcard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TypedWildcard& a, TypedWildcard& b) {
    a.Swap(&b);
  }
  inline void Swap(TypedWildcard* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypedWildcard* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypedWildcard* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TypedWildcard>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TypedWildcard& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TypedWildcard& from) {
    TypedWildcard::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TypedWildcard* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.TypedWildcard";
  }
  protected:
  explicit TypedWildcard(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // string type = 1 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.TypedWildcard)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_2eproto;
};
// -------------------------------------------------------------------

class TupleKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.TupleKey) */ {
 public:
  inline TupleKey() : TupleKey(nullptr) {}
  ~TupleKey() override;
  explicit PROTOBUF_CONSTEXPR TupleKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TupleKey(const TupleKey& from);
  TupleKey(TupleKey&& from) noexcept
    : TupleKey() {
    *this = ::std::move(from);
  }

  inline TupleKey& operator=(const TupleKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline TupleKey& operator=(TupleKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TupleKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const TupleKey* internal_default_instance() {
    return reinterpret_cast<const TupleKey*>(
               &_TupleKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TupleKey& a, TupleKey& b) {
    a.Swap(&b);
  }
  inline void Swap(TupleKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TupleKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TupleKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TupleKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TupleKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TupleKey& from) {
    TupleKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TupleKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.TupleKey";
  }
  protected:
  explicit TupleKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kRelationFieldNumber = 2,
    kObjectFieldNumber = 3,
    kConditionFieldNumber = 4,
  };
  // string user = 1 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_relation();
  const std::string& relation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_relation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_relation();
  PROTOBUF_NODISCARD std::string* release_relation();
  void set_allocated_relation(std::string* relation);
  private:
  const std::string& _internal_relation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relation(const std::string& value);
  std::string* _internal_mutable_relation();
  public:

  // string object = 3 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_object();
  const std::string& object() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_object(ArgT0&& arg0, ArgT... args);
  std::string* mutable_object();
  PROTOBUF_NODISCARD std::string* release_object();
  void set_allocated_object(std::string* object);
  private:
  const std::string& _internal_object() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object(const std::string& value);
  std::string* _internal_mutable_object();
  public:

  // .openfga.v1.RelationshipCondition condition = 4 [json_name = "condition"];
  bool has_condition() const;
  private:
  bool _internal_has_condition() const;
  public:
  void clear_condition();
  const ::openfga::v1::RelationshipCondition& condition() const;
  PROTOBUF_NODISCARD ::openfga::v1::RelationshipCondition* release_condition();
  ::openfga::v1::RelationshipCondition* mutable_condition();
  void set_allocated_condition(::openfga::v1::RelationshipCondition* condition);
  private:
  const ::openfga::v1::RelationshipCondition& _internal_condition() const;
  ::openfga::v1::RelationshipCondition* _internal_mutable_condition();
  public:
  void unsafe_arena_set_allocated_condition(
      ::openfga::v1::RelationshipCondition* condition);
  ::openfga::v1::RelationshipCondition* unsafe_arena_release_condition();

  // @@protoc_insertion_point(class_scope:openfga.v1.TupleKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr object_;
    ::openfga::v1::RelationshipCondition* condition_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_2eproto;
};
// -------------------------------------------------------------------

class Tuple final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.Tuple) */ {
 public:
  inline Tuple() : Tuple(nullptr) {}
  ~Tuple() override;
  explicit PROTOBUF_CONSTEXPR Tuple(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tuple(const Tuple& from);
  Tuple(Tuple&& from) noexcept
    : Tuple() {
    *this = ::std::move(from);
  }

  inline Tuple& operator=(const Tuple& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tuple& operator=(Tuple&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tuple& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tuple* internal_default_instance() {
    return reinterpret_cast<const Tuple*>(
               &_Tuple_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Tuple& a, Tuple& b) {
    a.Swap(&b);
  }
  inline void Swap(Tuple* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tuple* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tuple* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tuple>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tuple& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tuple& from) {
    Tuple::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tuple* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.Tuple";
  }
  protected:
  explicit Tuple(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // .openfga.v1.TupleKey key = 1 [json_name = "key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::openfga::v1::TupleKey& key() const;
  PROTOBUF_NODISCARD ::openfga::v1::TupleKey* release_key();
  ::openfga::v1::TupleKey* mutable_key();
  void set_allocated_key(::openfga::v1::TupleKey* key);
  private:
  const ::openfga::v1::TupleKey& _internal_key() const;
  ::openfga::v1::TupleKey* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::openfga::v1::TupleKey* key);
  ::openfga::v1::TupleKey* unsafe_arena_release_key();

  // .google.protobuf.Timestamp timestamp = 2 [json_name = "timestamp", (.google.api.field_behavior) = REQUIRED];
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // @@protoc_insertion_point(class_scope:openfga.v1.Tuple)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::openfga::v1::TupleKey* key_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_2eproto;
};
// -------------------------------------------------------------------

class TupleKeys final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.TupleKeys) */ {
 public:
  inline TupleKeys() : TupleKeys(nullptr) {}
  ~TupleKeys() override;
  explicit PROTOBUF_CONSTEXPR TupleKeys(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TupleKeys(const TupleKeys& from);
  TupleKeys(TupleKeys&& from) noexcept
    : TupleKeys() {
    *this = ::std::move(from);
  }

  inline TupleKeys& operator=(const TupleKeys& from) {
    CopyFrom(from);
    return *this;
  }
  inline TupleKeys& operator=(TupleKeys&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TupleKeys& default_instance() {
    return *internal_default_instance();
  }
  static inline const TupleKeys* internal_default_instance() {
    return reinterpret_cast<const TupleKeys*>(
               &_TupleKeys_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TupleKeys& a, TupleKeys& b) {
    a.Swap(&b);
  }
  inline void Swap(TupleKeys* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TupleKeys* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TupleKeys* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TupleKeys>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TupleKeys& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TupleKeys& from) {
    TupleKeys::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TupleKeys* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.TupleKeys";
  }
  protected:
  explicit TupleKeys(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTupleKeysFieldNumber = 1,
  };
  // repeated .openfga.v1.TupleKey tuple_keys = 1 [json_name = "tuple_keys", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int tuple_keys_size() const;
  private:
  int _internal_tuple_keys_size() const;
  public:
  void clear_tuple_keys();
  ::openfga::v1::TupleKey* mutable_tuple_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKey >*
      mutable_tuple_keys();
  private:
  const ::openfga::v1::TupleKey& _internal_tuple_keys(int index) const;
  ::openfga::v1::TupleKey* _internal_add_tuple_keys();
  public:
  const ::openfga::v1::TupleKey& tuple_keys(int index) const;
  ::openfga::v1::TupleKey* add_tuple_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKey >&
      tuple_keys() const;

  // @@protoc_insertion_point(class_scope:openfga.v1.TupleKeys)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKey > tuple_keys_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_2eproto;
};
// -------------------------------------------------------------------

class ContextualTupleKeys final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.ContextualTupleKeys) */ {
 public:
  inline ContextualTupleKeys() : ContextualTupleKeys(nullptr) {}
  ~ContextualTupleKeys() override;
  explicit PROTOBUF_CONSTEXPR ContextualTupleKeys(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContextualTupleKeys(const ContextualTupleKeys& from);
  ContextualTupleKeys(ContextualTupleKeys&& from) noexcept
    : ContextualTupleKeys() {
    *this = ::std::move(from);
  }

  inline ContextualTupleKeys& operator=(const ContextualTupleKeys& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContextualTupleKeys& operator=(ContextualTupleKeys&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContextualTupleKeys& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContextualTupleKeys* internal_default_instance() {
    return reinterpret_cast<const ContextualTupleKeys*>(
               &_ContextualTupleKeys_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ContextualTupleKeys& a, ContextualTupleKeys& b) {
    a.Swap(&b);
  }
  inline void Swap(ContextualTupleKeys* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContextualTupleKeys* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContextualTupleKeys* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContextualTupleKeys>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContextualTupleKeys& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContextualTupleKeys& from) {
    ContextualTupleKeys::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContextualTupleKeys* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.ContextualTupleKeys";
  }
  protected:
  explicit ContextualTupleKeys(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTupleKeysFieldNumber = 1,
  };
  // repeated .openfga.v1.TupleKey tuple_keys = 1 [json_name = "tuple_keys", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  int tuple_keys_size() const;
  private:
  int _internal_tuple_keys_size() const;
  public:
  void clear_tuple_keys();
  ::openfga::v1::TupleKey* mutable_tuple_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKey >*
      mutable_tuple_keys();
  private:
  const ::openfga::v1::TupleKey& _internal_tuple_keys(int index) const;
  ::openfga::v1::TupleKey* _internal_add_tuple_keys();
  public:
  const ::openfga::v1::TupleKey& tuple_keys(int index) const;
  ::openfga::v1::TupleKey* add_tuple_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKey >&
      tuple_keys() const;

  // @@protoc_insertion_point(class_scope:openfga.v1.ContextualTupleKeys)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKey > tuple_keys_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_2eproto;
};
// -------------------------------------------------------------------

class UsersetTree_Leaf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.UsersetTree.Leaf) */ {
 public:
  inline UsersetTree_Leaf() : UsersetTree_Leaf(nullptr) {}
  ~UsersetTree_Leaf() override;
  explicit PROTOBUF_CONSTEXPR UsersetTree_Leaf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UsersetTree_Leaf(const UsersetTree_Leaf& from);
  UsersetTree_Leaf(UsersetTree_Leaf&& from) noexcept
    : UsersetTree_Leaf() {
    *this = ::std::move(from);
  }

  inline UsersetTree_Leaf& operator=(const UsersetTree_Leaf& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsersetTree_Leaf& operator=(UsersetTree_Leaf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UsersetTree_Leaf& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kUsers = 1,
    kComputed = 2,
    kTupleToUserset = 3,
    VALUE_NOT_SET = 0,
  };

  static inline const UsersetTree_Leaf* internal_default_instance() {
    return reinterpret_cast<const UsersetTree_Leaf*>(
               &_UsersetTree_Leaf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UsersetTree_Leaf& a, UsersetTree_Leaf& b) {
    a.Swap(&b);
  }
  inline void Swap(UsersetTree_Leaf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UsersetTree_Leaf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UsersetTree_Leaf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UsersetTree_Leaf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UsersetTree_Leaf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UsersetTree_Leaf& from) {
    UsersetTree_Leaf::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsersetTree_Leaf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.UsersetTree.Leaf";
  }
  protected:
  explicit UsersetTree_Leaf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsersFieldNumber = 1,
    kComputedFieldNumber = 2,
    kTupleToUsersetFieldNumber = 3,
  };
  // .openfga.v1.UsersetTree.Users users = 1 [json_name = "users"];
  bool has_users() const;
  private:
  bool _internal_has_users() const;
  public:
  void clear_users();
  const ::openfga::v1::UsersetTree_Users& users() const;
  PROTOBUF_NODISCARD ::openfga::v1::UsersetTree_Users* release_users();
  ::openfga::v1::UsersetTree_Users* mutable_users();
  void set_allocated_users(::openfga::v1::UsersetTree_Users* users);
  private:
  const ::openfga::v1::UsersetTree_Users& _internal_users() const;
  ::openfga::v1::UsersetTree_Users* _internal_mutable_users();
  public:
  void unsafe_arena_set_allocated_users(
      ::openfga::v1::UsersetTree_Users* users);
  ::openfga::v1::UsersetTree_Users* unsafe_arena_release_users();

  // .openfga.v1.UsersetTree.Computed computed = 2 [json_name = "computed"];
  bool has_computed() const;
  private:
  bool _internal_has_computed() const;
  public:
  void clear_computed();
  const ::openfga::v1::UsersetTree_Computed& computed() const;
  PROTOBUF_NODISCARD ::openfga::v1::UsersetTree_Computed* release_computed();
  ::openfga::v1::UsersetTree_Computed* mutable_computed();
  void set_allocated_computed(::openfga::v1::UsersetTree_Computed* computed);
  private:
  const ::openfga::v1::UsersetTree_Computed& _internal_computed() const;
  ::openfga::v1::UsersetTree_Computed* _internal_mutable_computed();
  public:
  void unsafe_arena_set_allocated_computed(
      ::openfga::v1::UsersetTree_Computed* computed);
  ::openfga::v1::UsersetTree_Computed* unsafe_arena_release_computed();

  // .openfga.v1.UsersetTree.TupleToUserset tuple_to_userset = 3 [json_name = "tupleToUserset"];
  bool has_tuple_to_userset() const;
  private:
  bool _internal_has_tuple_to_userset() const;
  public:
  void clear_tuple_to_userset();
  const ::openfga::v1::UsersetTree_TupleToUserset& tuple_to_userset() const;
  PROTOBUF_NODISCARD ::openfga::v1::UsersetTree_TupleToUserset* release_tuple_to_userset();
  ::openfga::v1::UsersetTree_TupleToUserset* mutable_tuple_to_userset();
  void set_allocated_tuple_to_userset(::openfga::v1::UsersetTree_TupleToUserset* tuple_to_userset);
  private:
  const ::openfga::v1::UsersetTree_TupleToUserset& _internal_tuple_to_userset() const;
  ::openfga::v1::UsersetTree_TupleToUserset* _internal_mutable_tuple_to_userset();
  public:
  void unsafe_arena_set_allocated_tuple_to_userset(
      ::openfga::v1::UsersetTree_TupleToUserset* tuple_to_userset);
  ::openfga::v1::UsersetTree_TupleToUserset* unsafe_arena_release_tuple_to_userset();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:openfga.v1.UsersetTree.Leaf)
 private:
  class _Internal;
  void set_has_users();
  void set_has_computed();
  void set_has_tuple_to_userset();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::openfga::v1::UsersetTree_Users* users_;
      ::openfga::v1::UsersetTree_Computed* computed_;
      ::openfga::v1::UsersetTree_TupleToUserset* tuple_to_userset_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_2eproto;
};
// -------------------------------------------------------------------

class UsersetTree_Nodes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.UsersetTree.Nodes) */ {
 public:
  inline UsersetTree_Nodes() : UsersetTree_Nodes(nullptr) {}
  ~UsersetTree_Nodes() override;
  explicit PROTOBUF_CONSTEXPR UsersetTree_Nodes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UsersetTree_Nodes(const UsersetTree_Nodes& from);
  UsersetTree_Nodes(UsersetTree_Nodes&& from) noexcept
    : UsersetTree_Nodes() {
    *this = ::std::move(from);
  }

  inline UsersetTree_Nodes& operator=(const UsersetTree_Nodes& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsersetTree_Nodes& operator=(UsersetTree_Nodes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UsersetTree_Nodes& default_instance() {
    return *internal_default_instance();
  }
  static inline const UsersetTree_Nodes* internal_default_instance() {
    return reinterpret_cast<const UsersetTree_Nodes*>(
               &_UsersetTree_Nodes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UsersetTree_Nodes& a, UsersetTree_Nodes& b) {
    a.Swap(&b);
  }
  inline void Swap(UsersetTree_Nodes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UsersetTree_Nodes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UsersetTree_Nodes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UsersetTree_Nodes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UsersetTree_Nodes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UsersetTree_Nodes& from) {
    UsersetTree_Nodes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsersetTree_Nodes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.UsersetTree.Nodes";
  }
  protected:
  explicit UsersetTree_Nodes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
  };
  // repeated .openfga.v1.UsersetTree.Node nodes = 1 [json_name = "nodes", (.google.api.field_behavior) = REQUIRED];
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::openfga::v1::UsersetTree_Node* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::UsersetTree_Node >*
      mutable_nodes();
  private:
  const ::openfga::v1::UsersetTree_Node& _internal_nodes(int index) const;
  ::openfga::v1::UsersetTree_Node* _internal_add_nodes();
  public:
  const ::openfga::v1::UsersetTree_Node& nodes(int index) const;
  ::openfga::v1::UsersetTree_Node* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::UsersetTree_Node >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:openfga.v1.UsersetTree.Nodes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::UsersetTree_Node > nodes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_2eproto;
};
// -------------------------------------------------------------------

class UsersetTree_Users final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.UsersetTree.Users) */ {
 public:
  inline UsersetTree_Users() : UsersetTree_Users(nullptr) {}
  ~UsersetTree_Users() override;
  explicit PROTOBUF_CONSTEXPR UsersetTree_Users(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UsersetTree_Users(const UsersetTree_Users& from);
  UsersetTree_Users(UsersetTree_Users&& from) noexcept
    : UsersetTree_Users() {
    *this = ::std::move(from);
  }

  inline UsersetTree_Users& operator=(const UsersetTree_Users& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsersetTree_Users& operator=(UsersetTree_Users&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UsersetTree_Users& default_instance() {
    return *internal_default_instance();
  }
  static inline const UsersetTree_Users* internal_default_instance() {
    return reinterpret_cast<const UsersetTree_Users*>(
               &_UsersetTree_Users_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UsersetTree_Users& a, UsersetTree_Users& b) {
    a.Swap(&b);
  }
  inline void Swap(UsersetTree_Users* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UsersetTree_Users* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UsersetTree_Users* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UsersetTree_Users>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UsersetTree_Users& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UsersetTree_Users& from) {
    UsersetTree_Users::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsersetTree_Users* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.UsersetTree.Users";
  }
  protected:
  explicit UsersetTree_Users(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsersFieldNumber = 1,
  };
  // repeated string users = 1 [json_name = "users", (.google.api.field_behavior) = REQUIRED];
  int users_size() const;
  private:
  int _internal_users_size() const;
  public:
  void clear_users();
  const std::string& users(int index) const;
  std::string* mutable_users(int index);
  void set_users(int index, const std::string& value);
  void set_users(int index, std::string&& value);
  void set_users(int index, const char* value);
  void set_users(int index, const char* value, size_t size);
  std::string* add_users();
  void add_users(const std::string& value);
  void add_users(std::string&& value);
  void add_users(const char* value);
  void add_users(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& users() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_users();
  private:
  const std::string& _internal_users(int index) const;
  std::string* _internal_add_users();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.UsersetTree.Users)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> users_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_2eproto;
};
// -------------------------------------------------------------------

class UsersetTree_Computed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.UsersetTree.Computed) */ {
 public:
  inline UsersetTree_Computed() : UsersetTree_Computed(nullptr) {}
  ~UsersetTree_Computed() override;
  explicit PROTOBUF_CONSTEXPR UsersetTree_Computed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UsersetTree_Computed(const UsersetTree_Computed& from);
  UsersetTree_Computed(UsersetTree_Computed&& from) noexcept
    : UsersetTree_Computed() {
    *this = ::std::move(from);
  }

  inline UsersetTree_Computed& operator=(const UsersetTree_Computed& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsersetTree_Computed& operator=(UsersetTree_Computed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UsersetTree_Computed& default_instance() {
    return *internal_default_instance();
  }
  static inline const UsersetTree_Computed* internal_default_instance() {
    return reinterpret_cast<const UsersetTree_Computed*>(
               &_UsersetTree_Computed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UsersetTree_Computed& a, UsersetTree_Computed& b) {
    a.Swap(&b);
  }
  inline void Swap(UsersetTree_Computed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UsersetTree_Computed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UsersetTree_Computed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UsersetTree_Computed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UsersetTree_Computed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UsersetTree_Computed& from) {
    UsersetTree_Computed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsersetTree_Computed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.UsersetTree.Computed";
  }
  protected:
  explicit UsersetTree_Computed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsersetFieldNumber = 1,
  };
  // string userset = 1 [json_name = "userset", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_userset();
  const std::string& userset() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userset(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userset();
  PROTOBUF_NODISCARD std::string* release_userset();
  void set_allocated_userset(std::string* userset);
  private:
  const std::string& _internal_userset() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userset(const std::string& value);
  std::string* _internal_mutable_userset();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.UsersetTree.Computed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userset_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_2eproto;
};
// -------------------------------------------------------------------

class UsersetTree_TupleToUserset final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.UsersetTree.TupleToUserset) */ {
 public:
  inline UsersetTree_TupleToUserset() : UsersetTree_TupleToUserset(nullptr) {}
  ~UsersetTree_TupleToUserset() override;
  explicit PROTOBUF_CONSTEXPR UsersetTree_TupleToUserset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UsersetTree_TupleToUserset(const UsersetTree_TupleToUserset& from);
  UsersetTree_TupleToUserset(UsersetTree_TupleToUserset&& from) noexcept
    : UsersetTree_TupleToUserset() {
    *this = ::std::move(from);
  }

  inline UsersetTree_TupleToUserset& operator=(const UsersetTree_TupleToUserset& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsersetTree_TupleToUserset& operator=(UsersetTree_TupleToUserset&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UsersetTree_TupleToUserset& default_instance() {
    return *internal_default_instance();
  }
  static inline const UsersetTree_TupleToUserset* internal_default_instance() {
    return reinterpret_cast<const UsersetTree_TupleToUserset*>(
               &_UsersetTree_TupleToUserset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UsersetTree_TupleToUserset& a, UsersetTree_TupleToUserset& b) {
    a.Swap(&b);
  }
  inline void Swap(UsersetTree_TupleToUserset* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UsersetTree_TupleToUserset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UsersetTree_TupleToUserset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UsersetTree_TupleToUserset>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UsersetTree_TupleToUserset& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UsersetTree_TupleToUserset& from) {
    UsersetTree_TupleToUserset::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsersetTree_TupleToUserset* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.UsersetTree.TupleToUserset";
  }
  protected:
  explicit UsersetTree_TupleToUserset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComputedFieldNumber = 2,
    kTuplesetFieldNumber = 1,
  };
  // repeated .openfga.v1.UsersetTree.Computed computed = 2 [json_name = "computed", (.google.api.field_behavior) = REQUIRED];
  int computed_size() const;
  private:
  int _internal_computed_size() const;
  public:
  void clear_computed();
  ::openfga::v1::UsersetTree_Computed* mutable_computed(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::UsersetTree_Computed >*
      mutable_computed();
  private:
  const ::openfga::v1::UsersetTree_Computed& _internal_computed(int index) const;
  ::openfga::v1::UsersetTree_Computed* _internal_add_computed();
  public:
  const ::openfga::v1::UsersetTree_Computed& computed(int index) const;
  ::openfga::v1::UsersetTree_Computed* add_computed();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::UsersetTree_Computed >&
      computed() const;

  // string tupleset = 1 [json_name = "tupleset", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_tupleset();
  const std::string& tupleset() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tupleset(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tupleset();
  PROTOBUF_NODISCARD std::string* release_tupleset();
  void set_allocated_tupleset(std::string* tupleset);
  private:
  const std::string& _internal_tupleset() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tupleset(const std::string& value);
  std::string* _internal_mutable_tupleset();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.UsersetTree.TupleToUserset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::UsersetTree_Computed > computed_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tupleset_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_2eproto;
};
// -------------------------------------------------------------------

class UsersetTree_Difference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.UsersetTree.Difference) */ {
 public:
  inline UsersetTree_Difference() : UsersetTree_Difference(nullptr) {}
  ~UsersetTree_Difference() override;
  explicit PROTOBUF_CONSTEXPR UsersetTree_Difference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UsersetTree_Difference(const UsersetTree_Difference& from);
  UsersetTree_Difference(UsersetTree_Difference&& from) noexcept
    : UsersetTree_Difference() {
    *this = ::std::move(from);
  }

  inline UsersetTree_Difference& operator=(const UsersetTree_Difference& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsersetTree_Difference& operator=(UsersetTree_Difference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UsersetTree_Difference& default_instance() {
    return *internal_default_instance();
  }
  static inline const UsersetTree_Difference* internal_default_instance() {
    return reinterpret_cast<const UsersetTree_Difference*>(
               &_UsersetTree_Difference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UsersetTree_Difference& a, UsersetTree_Difference& b) {
    a.Swap(&b);
  }
  inline void Swap(UsersetTree_Difference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UsersetTree_Difference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UsersetTree_Difference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UsersetTree_Difference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UsersetTree_Difference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UsersetTree_Difference& from) {
    UsersetTree_Difference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsersetTree_Difference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.UsersetTree.Difference";
  }
  protected:
  explicit UsersetTree_Difference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseFieldNumber = 1,
    kSubtractFieldNumber = 2,
  };
  // .openfga.v1.UsersetTree.Node base = 1 [json_name = "base", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::openfga::v1::UsersetTree_Node& base() const;
  PROTOBUF_NODISCARD ::openfga::v1::UsersetTree_Node* release_base();
  ::openfga::v1::UsersetTree_Node* mutable_base();
  void set_allocated_base(::openfga::v1::UsersetTree_Node* base);
  private:
  const ::openfga::v1::UsersetTree_Node& _internal_base() const;
  ::openfga::v1::UsersetTree_Node* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::openfga::v1::UsersetTree_Node* base);
  ::openfga::v1::UsersetTree_Node* unsafe_arena_release_base();

  // .openfga.v1.UsersetTree.Node subtract = 2 [json_name = "subtract", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_subtract() const;
  private:
  bool _internal_has_subtract() const;
  public:
  void clear_subtract();
  const ::openfga::v1::UsersetTree_Node& subtract() const;
  PROTOBUF_NODISCARD ::openfga::v1::UsersetTree_Node* release_subtract();
  ::openfga::v1::UsersetTree_Node* mutable_subtract();
  void set_allocated_subtract(::openfga::v1::UsersetTree_Node* subtract);
  private:
  const ::openfga::v1::UsersetTree_Node& _internal_subtract() const;
  ::openfga::v1::UsersetTree_Node* _internal_mutable_subtract();
  public:
  void unsafe_arena_set_allocated_subtract(
      ::openfga::v1::UsersetTree_Node* subtract);
  ::openfga::v1::UsersetTree_Node* unsafe_arena_release_subtract();

  // @@protoc_insertion_point(class_scope:openfga.v1.UsersetTree.Difference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::openfga::v1::UsersetTree_Node* base_;
    ::openfga::v1::UsersetTree_Node* subtract_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_2eproto;
};
// -------------------------------------------------------------------

class UsersetTree_Node final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.UsersetTree.Node) */ {
 public:
  inline UsersetTree_Node() : UsersetTree_Node(nullptr) {}
  ~UsersetTree_Node() override;
  explicit PROTOBUF_CONSTEXPR UsersetTree_Node(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UsersetTree_Node(const UsersetTree_Node& from);
  UsersetTree_Node(UsersetTree_Node&& from) noexcept
    : UsersetTree_Node() {
    *this = ::std::move(from);
  }

  inline UsersetTree_Node& operator=(const UsersetTree_Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsersetTree_Node& operator=(UsersetTree_Node&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UsersetTree_Node& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kLeaf = 2,
    kDifference = 5,
    kUnion = 6,
    kIntersection = 7,
    VALUE_NOT_SET = 0,
  };

  static inline const UsersetTree_Node* internal_default_instance() {
    return reinterpret_cast<const UsersetTree_Node*>(
               &_UsersetTree_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UsersetTree_Node& a, UsersetTree_Node& b) {
    a.Swap(&b);
  }
  inline void Swap(UsersetTree_Node* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UsersetTree_Node* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UsersetTree_Node* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UsersetTree_Node>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UsersetTree_Node& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UsersetTree_Node& from) {
    UsersetTree_Node::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsersetTree_Node* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.UsersetTree.Node";
  }
  protected:
  explicit UsersetTree_Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLeafFieldNumber = 2,
    kDifferenceFieldNumber = 5,
    kUnionFieldNumber = 6,
    kIntersectionFieldNumber = 7,
  };
  // string name = 1 [json_name = "name", (.google.api.field_behavior) = REQUIRED];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .openfga.v1.UsersetTree.Leaf leaf = 2 [json_name = "leaf"];
  bool has_leaf() const;
  private:
  bool _internal_has_leaf() const;
  public:
  void clear_leaf();
  const ::openfga::v1::UsersetTree_Leaf& leaf() const;
  PROTOBUF_NODISCARD ::openfga::v1::UsersetTree_Leaf* release_leaf();
  ::openfga::v1::UsersetTree_Leaf* mutable_leaf();
  void set_allocated_leaf(::openfga::v1::UsersetTree_Leaf* leaf);
  private:
  const ::openfga::v1::UsersetTree_Leaf& _internal_leaf() const;
  ::openfga::v1::UsersetTree_Leaf* _internal_mutable_leaf();
  public:
  void unsafe_arena_set_allocated_leaf(
      ::openfga::v1::UsersetTree_Leaf* leaf);
  ::openfga::v1::UsersetTree_Leaf* unsafe_arena_release_leaf();

  // .openfga.v1.UsersetTree.Difference difference = 5 [json_name = "difference"];
  bool has_difference() const;
  private:
  bool _internal_has_difference() const;
  public:
  void clear_difference();
  const ::openfga::v1::UsersetTree_Difference& difference() const;
  PROTOBUF_NODISCARD ::openfga::v1::UsersetTree_Difference* release_difference();
  ::openfga::v1::UsersetTree_Difference* mutable_difference();
  void set_allocated_difference(::openfga::v1::UsersetTree_Difference* difference);
  private:
  const ::openfga::v1::UsersetTree_Difference& _internal_difference() const;
  ::openfga::v1::UsersetTree_Difference* _internal_mutable_difference();
  public:
  void unsafe_arena_set_allocated_difference(
      ::openfga::v1::UsersetTree_Difference* difference);
  ::openfga::v1::UsersetTree_Difference* unsafe_arena_release_difference();

  // .openfga.v1.UsersetTree.Nodes union = 6 [json_name = "union"];
  bool has_union_() const;
  private:
  bool _internal_has_union_() const;
  public:
  void clear_union_();
  const ::openfga::v1::UsersetTree_Nodes& union_() const;
  PROTOBUF_NODISCARD ::openfga::v1::UsersetTree_Nodes* release_union_();
  ::openfga::v1::UsersetTree_Nodes* mutable_union_();
  void set_allocated_union_(::openfga::v1::UsersetTree_Nodes* union_);
  private:
  const ::openfga::v1::UsersetTree_Nodes& _internal_union_() const;
  ::openfga::v1::UsersetTree_Nodes* _internal_mutable_union_();
  public:
  void unsafe_arena_set_allocated_union_(
      ::openfga::v1::UsersetTree_Nodes* union_);
  ::openfga::v1::UsersetTree_Nodes* unsafe_arena_release_union_();

  // .openfga.v1.UsersetTree.Nodes intersection = 7 [json_name = "intersection"];
  bool has_intersection() const;
  private:
  bool _internal_has_intersection() const;
  public:
  void clear_intersection();
  const ::openfga::v1::UsersetTree_Nodes& intersection() const;
  PROTOBUF_NODISCARD ::openfga::v1::UsersetTree_Nodes* release_intersection();
  ::openfga::v1::UsersetTree_Nodes* mutable_intersection();
  void set_allocated_intersection(::openfga::v1::UsersetTree_Nodes* intersection);
  private:
  const ::openfga::v1::UsersetTree_Nodes& _internal_intersection() const;
  ::openfga::v1::UsersetTree_Nodes* _internal_mutable_intersection();
  public:
  void unsafe_arena_set_allocated_intersection(
      ::openfga::v1::UsersetTree_Nodes* intersection);
  ::openfga::v1::UsersetTree_Nodes* unsafe_arena_release_intersection();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:openfga.v1.UsersetTree.Node)
 private:
  class _Internal;
  void set_has_leaf();
  void set_has_difference();
  void set_has_union_();
  void set_has_intersection();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::openfga::v1::UsersetTree_Leaf* leaf_;
      ::openfga::v1::UsersetTree_Difference* difference_;
      ::openfga::v1::UsersetTree_Nodes* union__;
      ::openfga::v1::UsersetTree_Nodes* intersection_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_2eproto;
};
// -------------------------------------------------------------------

class UsersetTree final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.UsersetTree) */ {
 public:
  inline UsersetTree() : UsersetTree(nullptr) {}
  ~UsersetTree() override;
  explicit PROTOBUF_CONSTEXPR UsersetTree(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UsersetTree(const UsersetTree& from);
  UsersetTree(UsersetTree&& from) noexcept
    : UsersetTree() {
    *this = ::std::move(from);
  }

  inline UsersetTree& operator=(const UsersetTree& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsersetTree& operator=(UsersetTree&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UsersetTree& default_instance() {
    return *internal_default_instance();
  }
  static inline const UsersetTree* internal_default_instance() {
    return reinterpret_cast<const UsersetTree*>(
               &_UsersetTree_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(UsersetTree& a, UsersetTree& b) {
    a.Swap(&b);
  }
  inline void Swap(UsersetTree* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UsersetTree* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UsersetTree* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UsersetTree>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UsersetTree& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UsersetTree& from) {
    UsersetTree::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsersetTree* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.UsersetTree";
  }
  protected:
  explicit UsersetTree(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UsersetTree_Leaf Leaf;
  typedef UsersetTree_Nodes Nodes;
  typedef UsersetTree_Users Users;
  typedef UsersetTree_Computed Computed;
  typedef UsersetTree_TupleToUserset TupleToUserset;
  typedef UsersetTree_Difference Difference;
  typedef UsersetTree_Node Node;

  // accessors -------------------------------------------------------

  enum : int {
    kRootFieldNumber = 1,
  };
  // .openfga.v1.UsersetTree.Node root = 1 [json_name = "root"];
  bool has_root() const;
  private:
  bool _internal_has_root() const;
  public:
  void clear_root();
  const ::openfga::v1::UsersetTree_Node& root() const;
  PROTOBUF_NODISCARD ::openfga::v1::UsersetTree_Node* release_root();
  ::openfga::v1::UsersetTree_Node* mutable_root();
  void set_allocated_root(::openfga::v1::UsersetTree_Node* root);
  private:
  const ::openfga::v1::UsersetTree_Node& _internal_root() const;
  ::openfga::v1::UsersetTree_Node* _internal_mutable_root();
  public:
  void unsafe_arena_set_allocated_root(
      ::openfga::v1::UsersetTree_Node* root);
  ::openfga::v1::UsersetTree_Node* unsafe_arena_release_root();

  // @@protoc_insertion_point(class_scope:openfga.v1.UsersetTree)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::openfga::v1::UsersetTree_Node* root_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_2eproto;
};
// -------------------------------------------------------------------

class TupleChange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.TupleChange) */ {
 public:
  inline TupleChange() : TupleChange(nullptr) {}
  ~TupleChange() override;
  explicit PROTOBUF_CONSTEXPR TupleChange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TupleChange(const TupleChange& from);
  TupleChange(TupleChange&& from) noexcept
    : TupleChange() {
    *this = ::std::move(from);
  }

  inline TupleChange& operator=(const TupleChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline TupleChange& operator=(TupleChange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TupleChange& default_instance() {
    return *internal_default_instance();
  }
  static inline const TupleChange* internal_default_instance() {
    return reinterpret_cast<const TupleChange*>(
               &_TupleChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(TupleChange& a, TupleChange& b) {
    a.Swap(&b);
  }
  inline void Swap(TupleChange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TupleChange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TupleChange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TupleChange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TupleChange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TupleChange& from) {
    TupleChange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TupleChange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.TupleChange";
  }
  protected:
  explicit TupleChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTupleKeyFieldNumber = 1,
    kTimestampFieldNumber = 3,
    kOperationFieldNumber = 2,
  };
  // .openfga.v1.TupleKey tuple_key = 1 [json_name = "tuple_key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_tuple_key() const;
  private:
  bool _internal_has_tuple_key() const;
  public:
  void clear_tuple_key();
  const ::openfga::v1::TupleKey& tuple_key() const;
  PROTOBUF_NODISCARD ::openfga::v1::TupleKey* release_tuple_key();
  ::openfga::v1::TupleKey* mutable_tuple_key();
  void set_allocated_tuple_key(::openfga::v1::TupleKey* tuple_key);
  private:
  const ::openfga::v1::TupleKey& _internal_tuple_key() const;
  ::openfga::v1::TupleKey* _internal_mutable_tuple_key();
  public:
  void unsafe_arena_set_allocated_tuple_key(
      ::openfga::v1::TupleKey* tuple_key);
  ::openfga::v1::TupleKey* unsafe_arena_release_tuple_key();

  // .google.protobuf.Timestamp timestamp = 3 [json_name = "timestamp", (.google.api.field_behavior) = REQUIRED];
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .openfga.v1.TupleOperation operation = 2 [json_name = "operation", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_operation();
  ::openfga::v1::TupleOperation operation() const;
  void set_operation(::openfga::v1::TupleOperation value);
  private:
  ::openfga::v1::TupleOperation _internal_operation() const;
  void _internal_set_operation(::openfga::v1::TupleOperation value);
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.TupleChange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::openfga::v1::TupleKey* tuple_key_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    int operation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_2eproto;
};
// -------------------------------------------------------------------

class Store final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.Store) */ {
 public:
  inline Store() : Store(nullptr) {}
  ~Store() override;
  explicit PROTOBUF_CONSTEXPR Store(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Store(const Store& from);
  Store(Store&& from) noexcept
    : Store() {
    *this = ::std::move(from);
  }

  inline Store& operator=(const Store& from) {
    CopyFrom(from);
    return *this;
  }
  inline Store& operator=(Store&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Store& default_instance() {
    return *internal_default_instance();
  }
  static inline const Store* internal_default_instance() {
    return reinterpret_cast<const Store*>(
               &_Store_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Store& a, Store& b) {
    a.Swap(&b);
  }
  inline void Swap(Store* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Store* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Store* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Store>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Store& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Store& from) {
    Store::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Store* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.Store";
  }
  protected:
  explicit Store(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kCreatedAtFieldNumber = 3,
    kUpdatedAtFieldNumber = 4,
    kDeletedAtFieldNumber = 5,
  };
  // string id = 1 [json_name = "id", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Timestamp created_at = 3 [json_name = "created_at", (.google.api.field_behavior) = REQUIRED];
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp updated_at = 4 [json_name = "updated_at", (.google.api.field_behavior) = REQUIRED];
  bool has_updated_at() const;
  private:
  bool _internal_has_updated_at() const;
  public:
  void clear_updated_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_updated_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_updated_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_updated_at();
  public:
  void unsafe_arena_set_allocated_updated_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_updated_at();

  // .google.protobuf.Timestamp deleted_at = 5 [json_name = "deleted_at"];
  bool has_deleted_at() const;
  private:
  bool _internal_has_deleted_at() const;
  public:
  void clear_deleted_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& deleted_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_deleted_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_deleted_at();
  void set_allocated_deleted_at(::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_deleted_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_deleted_at();
  public:
  void unsafe_arena_set_allocated_deleted_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_deleted_at();

  // @@protoc_insertion_point(class_scope:openfga.v1.Store)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_2eproto;
};
// -------------------------------------------------------------------

class UserTypeFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openfga.v1.UserTypeFilter) */ {
 public:
  inline UserTypeFilter() : UserTypeFilter(nullptr) {}
  ~UserTypeFilter() override;
  explicit PROTOBUF_CONSTEXPR UserTypeFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserTypeFilter(const UserTypeFilter& from);
  UserTypeFilter(UserTypeFilter&& from) noexcept
    : UserTypeFilter() {
    *this = ::std::move(from);
  }

  inline UserTypeFilter& operator=(const UserTypeFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserTypeFilter& operator=(UserTypeFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserTypeFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserTypeFilter* internal_default_instance() {
    return reinterpret_cast<const UserTypeFilter*>(
               &_UserTypeFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(UserTypeFilter& a, UserTypeFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(UserTypeFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserTypeFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserTypeFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserTypeFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserTypeFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserTypeFilter& from) {
    UserTypeFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserTypeFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openfga.v1.UserTypeFilter";
  }
  protected:
  explicit UserTypeFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kRelationFieldNumber = 2,
  };
  // string type = 1 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
  void clear_relation();
  const std::string& relation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_relation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_relation();
  PROTOBUF_NODISCARD std::string* release_relation();
  void set_allocated_relation(std::string* relation);
  private:
  const std::string& _internal_relation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relation(const std::string& value);
  std::string* _internal_mutable_relation();
  public:

  // @@protoc_insertion_point(class_scope:openfga.v1.UserTypeFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_openfga_2fv1_2fopenfga_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Object

// string type = 1 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void Object::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Object::type() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Object.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Object::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.Object.type)
}
inline std::string* Object::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Object.type)
  return _s;
}
inline const std::string& Object::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Object::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Object::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Object::release_type() {
  // @@protoc_insertion_point(field_release:openfga.v1.Object.type)
  return _impl_.type_.Release();
}
inline void Object::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.Object.type)
}

// string id = 2 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void Object::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Object::id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Object.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Object::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.Object.id)
}
inline std::string* Object::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Object.id)
  return _s;
}
inline const std::string& Object::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Object::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Object::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Object::release_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.Object.id)
  return _impl_.id_.Release();
}
inline void Object::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.Object.id)
}

// -------------------------------------------------------------------

// User

// .openfga.v1.Object object = 1 [json_name = "object"];
inline bool User::_internal_has_object() const {
  return user_case() == kObject;
}
inline bool User::has_object() const {
  return _internal_has_object();
}
inline void User::set_has_object() {
  _impl_._oneof_case_[0] = kObject;
}
inline void User::clear_object() {
  if (_internal_has_object()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.user_.object_;
    }
    clear_has_user();
  }
}
inline ::openfga::v1::Object* User::release_object() {
  // @@protoc_insertion_point(field_release:openfga.v1.User.object)
  if (_internal_has_object()) {
    clear_has_user();
    ::openfga::v1::Object* temp = _impl_.user_.object_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.user_.object_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openfga::v1::Object& User::_internal_object() const {
  return _internal_has_object()
      ? *_impl_.user_.object_
      : reinterpret_cast< ::openfga::v1::Object&>(::openfga::v1::_Object_default_instance_);
}
inline const ::openfga::v1::Object& User::object() const {
  // @@protoc_insertion_point(field_get:openfga.v1.User.object)
  return _internal_object();
}
inline ::openfga::v1::Object* User::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openfga.v1.User.object)
  if (_internal_has_object()) {
    clear_has_user();
    ::openfga::v1::Object* temp = _impl_.user_.object_;
    _impl_.user_.object_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void User::unsafe_arena_set_allocated_object(::openfga::v1::Object* object) {
  clear_user();
  if (object) {
    set_has_object();
    _impl_.user_.object_ = object;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.User.object)
}
inline ::openfga::v1::Object* User::_internal_mutable_object() {
  if (!_internal_has_object()) {
    clear_user();
    set_has_object();
    _impl_.user_.object_ = CreateMaybeMessage< ::openfga::v1::Object >(GetArenaForAllocation());
  }
  return _impl_.user_.object_;
}
inline ::openfga::v1::Object* User::mutable_object() {
  ::openfga::v1::Object* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:openfga.v1.User.object)
  return _msg;
}

// .openfga.v1.UsersetUser userset = 2 [json_name = "userset"];
inline bool User::_internal_has_userset() const {
  return user_case() == kUserset;
}
inline bool User::has_userset() const {
  return _internal_has_userset();
}
inline void User::set_has_userset() {
  _impl_._oneof_case_[0] = kUserset;
}
inline void User::clear_userset() {
  if (_internal_has_userset()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.user_.userset_;
    }
    clear_has_user();
  }
}
inline ::openfga::v1::UsersetUser* User::release_userset() {
  // @@protoc_insertion_point(field_release:openfga.v1.User.userset)
  if (_internal_has_userset()) {
    clear_has_user();
    ::openfga::v1::UsersetUser* temp = _impl_.user_.userset_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.user_.userset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openfga::v1::UsersetUser& User::_internal_userset() const {
  return _internal_has_userset()
      ? *_impl_.user_.userset_
      : reinterpret_cast< ::openfga::v1::UsersetUser&>(::openfga::v1::_UsersetUser_default_instance_);
}
inline const ::openfga::v1::UsersetUser& User::userset() const {
  // @@protoc_insertion_point(field_get:openfga.v1.User.userset)
  return _internal_userset();
}
inline ::openfga::v1::UsersetUser* User::unsafe_arena_release_userset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openfga.v1.User.userset)
  if (_internal_has_userset()) {
    clear_has_user();
    ::openfga::v1::UsersetUser* temp = _impl_.user_.userset_;
    _impl_.user_.userset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void User::unsafe_arena_set_allocated_userset(::openfga::v1::UsersetUser* userset) {
  clear_user();
  if (userset) {
    set_has_userset();
    _impl_.user_.userset_ = userset;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.User.userset)
}
inline ::openfga::v1::UsersetUser* User::_internal_mutable_userset() {
  if (!_internal_has_userset()) {
    clear_user();
    set_has_userset();
    _impl_.user_.userset_ = CreateMaybeMessage< ::openfga::v1::UsersetUser >(GetArenaForAllocation());
  }
  return _impl_.user_.userset_;
}
inline ::openfga::v1::UsersetUser* User::mutable_userset() {
  ::openfga::v1::UsersetUser* _msg = _internal_mutable_userset();
  // @@protoc_insertion_point(field_mutable:openfga.v1.User.userset)
  return _msg;
}

// .openfga.v1.TypedWildcard wildcard = 3 [json_name = "wildcard"];
inline bool User::_internal_has_wildcard() const {
  return user_case() == kWildcard;
}
inline bool User::has_wildcard() const {
  return _internal_has_wildcard();
}
inline void User::set_has_wildcard() {
  _impl_._oneof_case_[0] = kWildcard;
}
inline void User::clear_wildcard() {
  if (_internal_has_wildcard()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.user_.wildcard_;
    }
    clear_has_user();
  }
}
inline ::openfga::v1::TypedWildcard* User::release_wildcard() {
  // @@protoc_insertion_point(field_release:openfga.v1.User.wildcard)
  if (_internal_has_wildcard()) {
    clear_has_user();
    ::openfga::v1::TypedWildcard* temp = _impl_.user_.wildcard_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.user_.wildcard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openfga::v1::TypedWildcard& User::_internal_wildcard() const {
  return _internal_has_wildcard()
      ? *_impl_.user_.wildcard_
      : reinterpret_cast< ::openfga::v1::TypedWildcard&>(::openfga::v1::_TypedWildcard_default_instance_);
}
inline const ::openfga::v1::TypedWildcard& User::wildcard() const {
  // @@protoc_insertion_point(field_get:openfga.v1.User.wildcard)
  return _internal_wildcard();
}
inline ::openfga::v1::TypedWildcard* User::unsafe_arena_release_wildcard() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openfga.v1.User.wildcard)
  if (_internal_has_wildcard()) {
    clear_has_user();
    ::openfga::v1::TypedWildcard* temp = _impl_.user_.wildcard_;
    _impl_.user_.wildcard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void User::unsafe_arena_set_allocated_wildcard(::openfga::v1::TypedWildcard* wildcard) {
  clear_user();
  if (wildcard) {
    set_has_wildcard();
    _impl_.user_.wildcard_ = wildcard;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.User.wildcard)
}
inline ::openfga::v1::TypedWildcard* User::_internal_mutable_wildcard() {
  if (!_internal_has_wildcard()) {
    clear_user();
    set_has_wildcard();
    _impl_.user_.wildcard_ = CreateMaybeMessage< ::openfga::v1::TypedWildcard >(GetArenaForAllocation());
  }
  return _impl_.user_.wildcard_;
}
inline ::openfga::v1::TypedWildcard* User::mutable_wildcard() {
  ::openfga::v1::TypedWildcard* _msg = _internal_mutable_wildcard();
  // @@protoc_insertion_point(field_mutable:openfga.v1.User.wildcard)
  return _msg;
}

inline bool User::has_user() const {
  return user_case() != USER_NOT_SET;
}
inline void User::clear_has_user() {
  _impl_._oneof_case_[0] = USER_NOT_SET;
}
inline User::UserCase User::user_case() const {
  return User::UserCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// UsersetUser

// string type = 1 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void UsersetUser::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& UsersetUser::type() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UsersetUser.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UsersetUser::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.UsersetUser.type)
}
inline std::string* UsersetUser::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:openfga.v1.UsersetUser.type)
  return _s;
}
inline const std::string& UsersetUser::_internal_type() const {
  return _impl_.type_.Get();
}
inline void UsersetUser::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* UsersetUser::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* UsersetUser::release_type() {
  // @@protoc_insertion_point(field_release:openfga.v1.UsersetUser.type)
  return _impl_.type_.Release();
}
inline void UsersetUser::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.UsersetUser.type)
}

// string id = 2 [json_name = "id", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void UsersetUser::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& UsersetUser::id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UsersetUser.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UsersetUser::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.UsersetUser.id)
}
inline std::string* UsersetUser::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.UsersetUser.id)
  return _s;
}
inline const std::string& UsersetUser::_internal_id() const {
  return _impl_.id_.Get();
}
inline void UsersetUser::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* UsersetUser::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* UsersetUser::release_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.UsersetUser.id)
  return _impl_.id_.Release();
}
inline void UsersetUser::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.UsersetUser.id)
}

// string relation = 3 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void UsersetUser::clear_relation() {
  _impl_.relation_.ClearToEmpty();
}
inline const std::string& UsersetUser::relation() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UsersetUser.relation)
  return _internal_relation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UsersetUser::set_relation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.relation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.UsersetUser.relation)
}
inline std::string* UsersetUser::mutable_relation() {
  std::string* _s = _internal_mutable_relation();
  // @@protoc_insertion_point(field_mutable:openfga.v1.UsersetUser.relation)
  return _s;
}
inline const std::string& UsersetUser::_internal_relation() const {
  return _impl_.relation_.Get();
}
inline void UsersetUser::_internal_set_relation(const std::string& value) {
  
  _impl_.relation_.Set(value, GetArenaForAllocation());
}
inline std::string* UsersetUser::_internal_mutable_relation() {
  
  return _impl_.relation_.Mutable(GetArenaForAllocation());
}
inline std::string* UsersetUser::release_relation() {
  // @@protoc_insertion_point(field_release:openfga.v1.UsersetUser.relation)
  return _impl_.relation_.Release();
}
inline void UsersetUser::set_allocated_relation(std::string* relation) {
  if (relation != nullptr) {
    
  } else {
    
  }
  _impl_.relation_.SetAllocated(relation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.relation_.IsDefault()) {
    _impl_.relation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.UsersetUser.relation)
}

// -------------------------------------------------------------------

// RelationshipCondition

// string name = 1 [json_name = "name", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void RelationshipCondition::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RelationshipCondition::name() const {
  // @@protoc_insertion_point(field_get:openfga.v1.RelationshipCondition.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RelationshipCondition::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.RelationshipCondition.name)
}
inline std::string* RelationshipCondition::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:openfga.v1.RelationshipCondition.name)
  return _s;
}
inline const std::string& RelationshipCondition::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RelationshipCondition::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RelationshipCondition::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RelationshipCondition::release_name() {
  // @@protoc_insertion_point(field_release:openfga.v1.RelationshipCondition.name)
  return _impl_.name_.Release();
}
inline void RelationshipCondition::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.RelationshipCondition.name)
}

// .google.protobuf.Struct context = 2 [json_name = "context"];
inline bool RelationshipCondition::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool RelationshipCondition::has_context() const {
  return _internal_has_context();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& RelationshipCondition::_internal_context() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& RelationshipCondition::context() const {
  // @@protoc_insertion_point(field_get:openfga.v1.RelationshipCondition.context)
  return _internal_context();
}
inline void RelationshipCondition::unsafe_arena_set_allocated_context(
    ::PROTOBUF_NAMESPACE_ID::Struct* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.RelationshipCondition.context)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RelationshipCondition::release_context() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RelationshipCondition::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:openfga.v1.RelationshipCondition.context)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RelationshipCondition::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RelationshipCondition::mutable_context() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:openfga.v1.RelationshipCondition.context)
  return _msg;
}
inline void RelationshipCondition::set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(context));
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.RelationshipCondition.context)
}

// -------------------------------------------------------------------

// TupleKeyWithoutCondition

// string user = 1 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void TupleKeyWithoutCondition::clear_user() {
  _impl_.user_.ClearToEmpty();
}
inline const std::string& TupleKeyWithoutCondition::user() const {
  // @@protoc_insertion_point(field_get:openfga.v1.TupleKeyWithoutCondition.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TupleKeyWithoutCondition::set_user(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.TupleKeyWithoutCondition.user)
}
inline std::string* TupleKeyWithoutCondition::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:openfga.v1.TupleKeyWithoutCondition.user)
  return _s;
}
inline const std::string& TupleKeyWithoutCondition::_internal_user() const {
  return _impl_.user_.Get();
}
inline void TupleKeyWithoutCondition::_internal_set_user(const std::string& value) {
  
  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* TupleKeyWithoutCondition::_internal_mutable_user() {
  
  return _impl_.user_.Mutable(GetArenaForAllocation());
}
inline std::string* TupleKeyWithoutCondition::release_user() {
  // @@protoc_insertion_point(field_release:openfga.v1.TupleKeyWithoutCondition.user)
  return _impl_.user_.Release();
}
inline void TupleKeyWithoutCondition::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  _impl_.user_.SetAllocated(user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.TupleKeyWithoutCondition.user)
}

// string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void TupleKeyWithoutCondition::clear_relation() {
  _impl_.relation_.ClearToEmpty();
}
inline const std::string& TupleKeyWithoutCondition::relation() const {
  // @@protoc_insertion_point(field_get:openfga.v1.TupleKeyWithoutCondition.relation)
  return _internal_relation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TupleKeyWithoutCondition::set_relation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.relation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.TupleKeyWithoutCondition.relation)
}
inline std::string* TupleKeyWithoutCondition::mutable_relation() {
  std::string* _s = _internal_mutable_relation();
  // @@protoc_insertion_point(field_mutable:openfga.v1.TupleKeyWithoutCondition.relation)
  return _s;
}
inline const std::string& TupleKeyWithoutCondition::_internal_relation() const {
  return _impl_.relation_.Get();
}
inline void TupleKeyWithoutCondition::_internal_set_relation(const std::string& value) {
  
  _impl_.relation_.Set(value, GetArenaForAllocation());
}
inline std::string* TupleKeyWithoutCondition::_internal_mutable_relation() {
  
  return _impl_.relation_.Mutable(GetArenaForAllocation());
}
inline std::string* TupleKeyWithoutCondition::release_relation() {
  // @@protoc_insertion_point(field_release:openfga.v1.TupleKeyWithoutCondition.relation)
  return _impl_.relation_.Release();
}
inline void TupleKeyWithoutCondition::set_allocated_relation(std::string* relation) {
  if (relation != nullptr) {
    
  } else {
    
  }
  _impl_.relation_.SetAllocated(relation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.relation_.IsDefault()) {
    _impl_.relation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.TupleKeyWithoutCondition.relation)
}

// string object = 3 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void TupleKeyWithoutCondition::clear_object() {
  _impl_.object_.ClearToEmpty();
}
inline const std::string& TupleKeyWithoutCondition::object() const {
  // @@protoc_insertion_point(field_get:openfga.v1.TupleKeyWithoutCondition.object)
  return _internal_object();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TupleKeyWithoutCondition::set_object(ArgT0&& arg0, ArgT... args) {
 
 _impl_.object_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.TupleKeyWithoutCondition.object)
}
inline std::string* TupleKeyWithoutCondition::mutable_object() {
  std::string* _s = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:openfga.v1.TupleKeyWithoutCondition.object)
  return _s;
}
inline const std::string& TupleKeyWithoutCondition::_internal_object() const {
  return _impl_.object_.Get();
}
inline void TupleKeyWithoutCondition::_internal_set_object(const std::string& value) {
  
  _impl_.object_.Set(value, GetArenaForAllocation());
}
inline std::string* TupleKeyWithoutCondition::_internal_mutable_object() {
  
  return _impl_.object_.Mutable(GetArenaForAllocation());
}
inline std::string* TupleKeyWithoutCondition::release_object() {
  // @@protoc_insertion_point(field_release:openfga.v1.TupleKeyWithoutCondition.object)
  return _impl_.object_.Release();
}
inline void TupleKeyWithoutCondition::set_allocated_object(std::string* object) {
  if (object != nullptr) {
    
  } else {
    
  }
  _impl_.object_.SetAllocated(object, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.object_.IsDefault()) {
    _impl_.object_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.TupleKeyWithoutCondition.object)
}

// -------------------------------------------------------------------

// TypedWildcard

// string type = 1 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void TypedWildcard::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& TypedWildcard::type() const {
  // @@protoc_insertion_point(field_get:openfga.v1.TypedWildcard.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TypedWildcard::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.TypedWildcard.type)
}
inline std::string* TypedWildcard::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:openfga.v1.TypedWildcard.type)
  return _s;
}
inline const std::string& TypedWildcard::_internal_type() const {
  return _impl_.type_.Get();
}
inline void TypedWildcard::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* TypedWildcard::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* TypedWildcard::release_type() {
  // @@protoc_insertion_point(field_release:openfga.v1.TypedWildcard.type)
  return _impl_.type_.Release();
}
inline void TypedWildcard::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.TypedWildcard.type)
}

// -------------------------------------------------------------------

// TupleKey

// string user = 1 [json_name = "user", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void TupleKey::clear_user() {
  _impl_.user_.ClearToEmpty();
}
inline const std::string& TupleKey::user() const {
  // @@protoc_insertion_point(field_get:openfga.v1.TupleKey.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TupleKey::set_user(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.TupleKey.user)
}
inline std::string* TupleKey::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:openfga.v1.TupleKey.user)
  return _s;
}
inline const std::string& TupleKey::_internal_user() const {
  return _impl_.user_.Get();
}
inline void TupleKey::_internal_set_user(const std::string& value) {
  
  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* TupleKey::_internal_mutable_user() {
  
  return _impl_.user_.Mutable(GetArenaForAllocation());
}
inline std::string* TupleKey::release_user() {
  // @@protoc_insertion_point(field_release:openfga.v1.TupleKey.user)
  return _impl_.user_.Release();
}
inline void TupleKey::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  _impl_.user_.SetAllocated(user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.TupleKey.user)
}

// string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void TupleKey::clear_relation() {
  _impl_.relation_.ClearToEmpty();
}
inline const std::string& TupleKey::relation() const {
  // @@protoc_insertion_point(field_get:openfga.v1.TupleKey.relation)
  return _internal_relation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TupleKey::set_relation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.relation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.TupleKey.relation)
}
inline std::string* TupleKey::mutable_relation() {
  std::string* _s = _internal_mutable_relation();
  // @@protoc_insertion_point(field_mutable:openfga.v1.TupleKey.relation)
  return _s;
}
inline const std::string& TupleKey::_internal_relation() const {
  return _impl_.relation_.Get();
}
inline void TupleKey::_internal_set_relation(const std::string& value) {
  
  _impl_.relation_.Set(value, GetArenaForAllocation());
}
inline std::string* TupleKey::_internal_mutable_relation() {
  
  return _impl_.relation_.Mutable(GetArenaForAllocation());
}
inline std::string* TupleKey::release_relation() {
  // @@protoc_insertion_point(field_release:openfga.v1.TupleKey.relation)
  return _impl_.relation_.Release();
}
inline void TupleKey::set_allocated_relation(std::string* relation) {
  if (relation != nullptr) {
    
  } else {
    
  }
  _impl_.relation_.SetAllocated(relation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.relation_.IsDefault()) {
    _impl_.relation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.TupleKey.relation)
}

// string object = 3 [json_name = "object", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void TupleKey::clear_object() {
  _impl_.object_.ClearToEmpty();
}
inline const std::string& TupleKey::object() const {
  // @@protoc_insertion_point(field_get:openfga.v1.TupleKey.object)
  return _internal_object();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TupleKey::set_object(ArgT0&& arg0, ArgT... args) {
 
 _impl_.object_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.TupleKey.object)
}
inline std::string* TupleKey::mutable_object() {
  std::string* _s = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:openfga.v1.TupleKey.object)
  return _s;
}
inline const std::string& TupleKey::_internal_object() const {
  return _impl_.object_.Get();
}
inline void TupleKey::_internal_set_object(const std::string& value) {
  
  _impl_.object_.Set(value, GetArenaForAllocation());
}
inline std::string* TupleKey::_internal_mutable_object() {
  
  return _impl_.object_.Mutable(GetArenaForAllocation());
}
inline std::string* TupleKey::release_object() {
  // @@protoc_insertion_point(field_release:openfga.v1.TupleKey.object)
  return _impl_.object_.Release();
}
inline void TupleKey::set_allocated_object(std::string* object) {
  if (object != nullptr) {
    
  } else {
    
  }
  _impl_.object_.SetAllocated(object, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.object_.IsDefault()) {
    _impl_.object_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.TupleKey.object)
}

// .openfga.v1.RelationshipCondition condition = 4 [json_name = "condition"];
inline bool TupleKey::_internal_has_condition() const {
  return this != internal_default_instance() && _impl_.condition_ != nullptr;
}
inline bool TupleKey::has_condition() const {
  return _internal_has_condition();
}
inline void TupleKey::clear_condition() {
  if (GetArenaForAllocation() == nullptr && _impl_.condition_ != nullptr) {
    delete _impl_.condition_;
  }
  _impl_.condition_ = nullptr;
}
inline const ::openfga::v1::RelationshipCondition& TupleKey::_internal_condition() const {
  const ::openfga::v1::RelationshipCondition* p = _impl_.condition_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::RelationshipCondition&>(
      ::openfga::v1::_RelationshipCondition_default_instance_);
}
inline const ::openfga::v1::RelationshipCondition& TupleKey::condition() const {
  // @@protoc_insertion_point(field_get:openfga.v1.TupleKey.condition)
  return _internal_condition();
}
inline void TupleKey::unsafe_arena_set_allocated_condition(
    ::openfga::v1::RelationshipCondition* condition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.condition_);
  }
  _impl_.condition_ = condition;
  if (condition) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.TupleKey.condition)
}
inline ::openfga::v1::RelationshipCondition* TupleKey::release_condition() {
  
  ::openfga::v1::RelationshipCondition* temp = _impl_.condition_;
  _impl_.condition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::RelationshipCondition* TupleKey::unsafe_arena_release_condition() {
  // @@protoc_insertion_point(field_release:openfga.v1.TupleKey.condition)
  
  ::openfga::v1::RelationshipCondition* temp = _impl_.condition_;
  _impl_.condition_ = nullptr;
  return temp;
}
inline ::openfga::v1::RelationshipCondition* TupleKey::_internal_mutable_condition() {
  
  if (_impl_.condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::RelationshipCondition>(GetArenaForAllocation());
    _impl_.condition_ = p;
  }
  return _impl_.condition_;
}
inline ::openfga::v1::RelationshipCondition* TupleKey::mutable_condition() {
  ::openfga::v1::RelationshipCondition* _msg = _internal_mutable_condition();
  // @@protoc_insertion_point(field_mutable:openfga.v1.TupleKey.condition)
  return _msg;
}
inline void TupleKey::set_allocated_condition(::openfga::v1::RelationshipCondition* condition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.condition_;
  }
  if (condition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(condition);
    if (message_arena != submessage_arena) {
      condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, condition, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.condition_ = condition;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.TupleKey.condition)
}

// -------------------------------------------------------------------

// Tuple

// .openfga.v1.TupleKey key = 1 [json_name = "key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool Tuple::_internal_has_key() const {
  return this != internal_default_instance() && _impl_.key_ != nullptr;
}
inline bool Tuple::has_key() const {
  return _internal_has_key();
}
inline void Tuple::clear_key() {
  if (GetArenaForAllocation() == nullptr && _impl_.key_ != nullptr) {
    delete _impl_.key_;
  }
  _impl_.key_ = nullptr;
}
inline const ::openfga::v1::TupleKey& Tuple::_internal_key() const {
  const ::openfga::v1::TupleKey* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::TupleKey&>(
      ::openfga::v1::_TupleKey_default_instance_);
}
inline const ::openfga::v1::TupleKey& Tuple::key() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Tuple.key)
  return _internal_key();
}
inline void Tuple::unsafe_arena_set_allocated_key(
    ::openfga::v1::TupleKey* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.Tuple.key)
}
inline ::openfga::v1::TupleKey* Tuple::release_key() {
  
  ::openfga::v1::TupleKey* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::TupleKey* Tuple::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:openfga.v1.Tuple.key)
  
  ::openfga::v1::TupleKey* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::openfga::v1::TupleKey* Tuple::_internal_mutable_key() {
  
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::TupleKey>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::openfga::v1::TupleKey* Tuple::mutable_key() {
  ::openfga::v1::TupleKey* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Tuple.key)
  return _msg;
}
inline void Tuple::set_allocated_key(::openfga::v1::TupleKey* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.Tuple.key)
}

// .google.protobuf.Timestamp timestamp = 2 [json_name = "timestamp", (.google.api.field_behavior) = REQUIRED];
inline bool Tuple::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool Tuple::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Tuple::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Tuple::timestamp() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Tuple.timestamp)
  return _internal_timestamp();
}
inline void Tuple::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.Tuple.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Tuple::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Tuple::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:openfga.v1.Tuple.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Tuple::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Tuple::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Tuple.timestamp)
  return _msg;
}
inline void Tuple::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.Tuple.timestamp)
}

// -------------------------------------------------------------------

// TupleKeys

// repeated .openfga.v1.TupleKey tuple_keys = 1 [json_name = "tuple_keys", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int TupleKeys::_internal_tuple_keys_size() const {
  return _impl_.tuple_keys_.size();
}
inline int TupleKeys::tuple_keys_size() const {
  return _internal_tuple_keys_size();
}
inline void TupleKeys::clear_tuple_keys() {
  _impl_.tuple_keys_.Clear();
}
inline ::openfga::v1::TupleKey* TupleKeys::mutable_tuple_keys(int index) {
  // @@protoc_insertion_point(field_mutable:openfga.v1.TupleKeys.tuple_keys)
  return _impl_.tuple_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKey >*
TupleKeys::mutable_tuple_keys() {
  // @@protoc_insertion_point(field_mutable_list:openfga.v1.TupleKeys.tuple_keys)
  return &_impl_.tuple_keys_;
}
inline const ::openfga::v1::TupleKey& TupleKeys::_internal_tuple_keys(int index) const {
  return _impl_.tuple_keys_.Get(index);
}
inline const ::openfga::v1::TupleKey& TupleKeys::tuple_keys(int index) const {
  // @@protoc_insertion_point(field_get:openfga.v1.TupleKeys.tuple_keys)
  return _internal_tuple_keys(index);
}
inline ::openfga::v1::TupleKey* TupleKeys::_internal_add_tuple_keys() {
  return _impl_.tuple_keys_.Add();
}
inline ::openfga::v1::TupleKey* TupleKeys::add_tuple_keys() {
  ::openfga::v1::TupleKey* _add = _internal_add_tuple_keys();
  // @@protoc_insertion_point(field_add:openfga.v1.TupleKeys.tuple_keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKey >&
TupleKeys::tuple_keys() const {
  // @@protoc_insertion_point(field_list:openfga.v1.TupleKeys.tuple_keys)
  return _impl_.tuple_keys_;
}

// -------------------------------------------------------------------

// ContextualTupleKeys

// repeated .openfga.v1.TupleKey tuple_keys = 1 [json_name = "tuple_keys", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline int ContextualTupleKeys::_internal_tuple_keys_size() const {
  return _impl_.tuple_keys_.size();
}
inline int ContextualTupleKeys::tuple_keys_size() const {
  return _internal_tuple_keys_size();
}
inline void ContextualTupleKeys::clear_tuple_keys() {
  _impl_.tuple_keys_.Clear();
}
inline ::openfga::v1::TupleKey* ContextualTupleKeys::mutable_tuple_keys(int index) {
  // @@protoc_insertion_point(field_mutable:openfga.v1.ContextualTupleKeys.tuple_keys)
  return _impl_.tuple_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKey >*
ContextualTupleKeys::mutable_tuple_keys() {
  // @@protoc_insertion_point(field_mutable_list:openfga.v1.ContextualTupleKeys.tuple_keys)
  return &_impl_.tuple_keys_;
}
inline const ::openfga::v1::TupleKey& ContextualTupleKeys::_internal_tuple_keys(int index) const {
  return _impl_.tuple_keys_.Get(index);
}
inline const ::openfga::v1::TupleKey& ContextualTupleKeys::tuple_keys(int index) const {
  // @@protoc_insertion_point(field_get:openfga.v1.ContextualTupleKeys.tuple_keys)
  return _internal_tuple_keys(index);
}
inline ::openfga::v1::TupleKey* ContextualTupleKeys::_internal_add_tuple_keys() {
  return _impl_.tuple_keys_.Add();
}
inline ::openfga::v1::TupleKey* ContextualTupleKeys::add_tuple_keys() {
  ::openfga::v1::TupleKey* _add = _internal_add_tuple_keys();
  // @@protoc_insertion_point(field_add:openfga.v1.ContextualTupleKeys.tuple_keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::TupleKey >&
ContextualTupleKeys::tuple_keys() const {
  // @@protoc_insertion_point(field_list:openfga.v1.ContextualTupleKeys.tuple_keys)
  return _impl_.tuple_keys_;
}

// -------------------------------------------------------------------

// UsersetTree_Leaf

// .openfga.v1.UsersetTree.Users users = 1 [json_name = "users"];
inline bool UsersetTree_Leaf::_internal_has_users() const {
  return value_case() == kUsers;
}
inline bool UsersetTree_Leaf::has_users() const {
  return _internal_has_users();
}
inline void UsersetTree_Leaf::set_has_users() {
  _impl_._oneof_case_[0] = kUsers;
}
inline void UsersetTree_Leaf::clear_users() {
  if (_internal_has_users()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.users_;
    }
    clear_has_value();
  }
}
inline ::openfga::v1::UsersetTree_Users* UsersetTree_Leaf::release_users() {
  // @@protoc_insertion_point(field_release:openfga.v1.UsersetTree.Leaf.users)
  if (_internal_has_users()) {
    clear_has_value();
    ::openfga::v1::UsersetTree_Users* temp = _impl_.value_.users_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.users_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openfga::v1::UsersetTree_Users& UsersetTree_Leaf::_internal_users() const {
  return _internal_has_users()
      ? *_impl_.value_.users_
      : reinterpret_cast< ::openfga::v1::UsersetTree_Users&>(::openfga::v1::_UsersetTree_Users_default_instance_);
}
inline const ::openfga::v1::UsersetTree_Users& UsersetTree_Leaf::users() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UsersetTree.Leaf.users)
  return _internal_users();
}
inline ::openfga::v1::UsersetTree_Users* UsersetTree_Leaf::unsafe_arena_release_users() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openfga.v1.UsersetTree.Leaf.users)
  if (_internal_has_users()) {
    clear_has_value();
    ::openfga::v1::UsersetTree_Users* temp = _impl_.value_.users_;
    _impl_.value_.users_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UsersetTree_Leaf::unsafe_arena_set_allocated_users(::openfga::v1::UsersetTree_Users* users) {
  clear_value();
  if (users) {
    set_has_users();
    _impl_.value_.users_ = users;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.UsersetTree.Leaf.users)
}
inline ::openfga::v1::UsersetTree_Users* UsersetTree_Leaf::_internal_mutable_users() {
  if (!_internal_has_users()) {
    clear_value();
    set_has_users();
    _impl_.value_.users_ = CreateMaybeMessage< ::openfga::v1::UsersetTree_Users >(GetArenaForAllocation());
  }
  return _impl_.value_.users_;
}
inline ::openfga::v1::UsersetTree_Users* UsersetTree_Leaf::mutable_users() {
  ::openfga::v1::UsersetTree_Users* _msg = _internal_mutable_users();
  // @@protoc_insertion_point(field_mutable:openfga.v1.UsersetTree.Leaf.users)
  return _msg;
}

// .openfga.v1.UsersetTree.Computed computed = 2 [json_name = "computed"];
inline bool UsersetTree_Leaf::_internal_has_computed() const {
  return value_case() == kComputed;
}
inline bool UsersetTree_Leaf::has_computed() const {
  return _internal_has_computed();
}
inline void UsersetTree_Leaf::set_has_computed() {
  _impl_._oneof_case_[0] = kComputed;
}
inline void UsersetTree_Leaf::clear_computed() {
  if (_internal_has_computed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.computed_;
    }
    clear_has_value();
  }
}
inline ::openfga::v1::UsersetTree_Computed* UsersetTree_Leaf::release_computed() {
  // @@protoc_insertion_point(field_release:openfga.v1.UsersetTree.Leaf.computed)
  if (_internal_has_computed()) {
    clear_has_value();
    ::openfga::v1::UsersetTree_Computed* temp = _impl_.value_.computed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.computed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openfga::v1::UsersetTree_Computed& UsersetTree_Leaf::_internal_computed() const {
  return _internal_has_computed()
      ? *_impl_.value_.computed_
      : reinterpret_cast< ::openfga::v1::UsersetTree_Computed&>(::openfga::v1::_UsersetTree_Computed_default_instance_);
}
inline const ::openfga::v1::UsersetTree_Computed& UsersetTree_Leaf::computed() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UsersetTree.Leaf.computed)
  return _internal_computed();
}
inline ::openfga::v1::UsersetTree_Computed* UsersetTree_Leaf::unsafe_arena_release_computed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openfga.v1.UsersetTree.Leaf.computed)
  if (_internal_has_computed()) {
    clear_has_value();
    ::openfga::v1::UsersetTree_Computed* temp = _impl_.value_.computed_;
    _impl_.value_.computed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UsersetTree_Leaf::unsafe_arena_set_allocated_computed(::openfga::v1::UsersetTree_Computed* computed) {
  clear_value();
  if (computed) {
    set_has_computed();
    _impl_.value_.computed_ = computed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.UsersetTree.Leaf.computed)
}
inline ::openfga::v1::UsersetTree_Computed* UsersetTree_Leaf::_internal_mutable_computed() {
  if (!_internal_has_computed()) {
    clear_value();
    set_has_computed();
    _impl_.value_.computed_ = CreateMaybeMessage< ::openfga::v1::UsersetTree_Computed >(GetArenaForAllocation());
  }
  return _impl_.value_.computed_;
}
inline ::openfga::v1::UsersetTree_Computed* UsersetTree_Leaf::mutable_computed() {
  ::openfga::v1::UsersetTree_Computed* _msg = _internal_mutable_computed();
  // @@protoc_insertion_point(field_mutable:openfga.v1.UsersetTree.Leaf.computed)
  return _msg;
}

// .openfga.v1.UsersetTree.TupleToUserset tuple_to_userset = 3 [json_name = "tupleToUserset"];
inline bool UsersetTree_Leaf::_internal_has_tuple_to_userset() const {
  return value_case() == kTupleToUserset;
}
inline bool UsersetTree_Leaf::has_tuple_to_userset() const {
  return _internal_has_tuple_to_userset();
}
inline void UsersetTree_Leaf::set_has_tuple_to_userset() {
  _impl_._oneof_case_[0] = kTupleToUserset;
}
inline void UsersetTree_Leaf::clear_tuple_to_userset() {
  if (_internal_has_tuple_to_userset()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.tuple_to_userset_;
    }
    clear_has_value();
  }
}
inline ::openfga::v1::UsersetTree_TupleToUserset* UsersetTree_Leaf::release_tuple_to_userset() {
  // @@protoc_insertion_point(field_release:openfga.v1.UsersetTree.Leaf.tuple_to_userset)
  if (_internal_has_tuple_to_userset()) {
    clear_has_value();
    ::openfga::v1::UsersetTree_TupleToUserset* temp = _impl_.value_.tuple_to_userset_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.tuple_to_userset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openfga::v1::UsersetTree_TupleToUserset& UsersetTree_Leaf::_internal_tuple_to_userset() const {
  return _internal_has_tuple_to_userset()
      ? *_impl_.value_.tuple_to_userset_
      : reinterpret_cast< ::openfga::v1::UsersetTree_TupleToUserset&>(::openfga::v1::_UsersetTree_TupleToUserset_default_instance_);
}
inline const ::openfga::v1::UsersetTree_TupleToUserset& UsersetTree_Leaf::tuple_to_userset() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UsersetTree.Leaf.tuple_to_userset)
  return _internal_tuple_to_userset();
}
inline ::openfga::v1::UsersetTree_TupleToUserset* UsersetTree_Leaf::unsafe_arena_release_tuple_to_userset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openfga.v1.UsersetTree.Leaf.tuple_to_userset)
  if (_internal_has_tuple_to_userset()) {
    clear_has_value();
    ::openfga::v1::UsersetTree_TupleToUserset* temp = _impl_.value_.tuple_to_userset_;
    _impl_.value_.tuple_to_userset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UsersetTree_Leaf::unsafe_arena_set_allocated_tuple_to_userset(::openfga::v1::UsersetTree_TupleToUserset* tuple_to_userset) {
  clear_value();
  if (tuple_to_userset) {
    set_has_tuple_to_userset();
    _impl_.value_.tuple_to_userset_ = tuple_to_userset;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.UsersetTree.Leaf.tuple_to_userset)
}
inline ::openfga::v1::UsersetTree_TupleToUserset* UsersetTree_Leaf::_internal_mutable_tuple_to_userset() {
  if (!_internal_has_tuple_to_userset()) {
    clear_value();
    set_has_tuple_to_userset();
    _impl_.value_.tuple_to_userset_ = CreateMaybeMessage< ::openfga::v1::UsersetTree_TupleToUserset >(GetArenaForAllocation());
  }
  return _impl_.value_.tuple_to_userset_;
}
inline ::openfga::v1::UsersetTree_TupleToUserset* UsersetTree_Leaf::mutable_tuple_to_userset() {
  ::openfga::v1::UsersetTree_TupleToUserset* _msg = _internal_mutable_tuple_to_userset();
  // @@protoc_insertion_point(field_mutable:openfga.v1.UsersetTree.Leaf.tuple_to_userset)
  return _msg;
}

inline bool UsersetTree_Leaf::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void UsersetTree_Leaf::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline UsersetTree_Leaf::ValueCase UsersetTree_Leaf::value_case() const {
  return UsersetTree_Leaf::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// UsersetTree_Nodes

// repeated .openfga.v1.UsersetTree.Node nodes = 1 [json_name = "nodes", (.google.api.field_behavior) = REQUIRED];
inline int UsersetTree_Nodes::_internal_nodes_size() const {
  return _impl_.nodes_.size();
}
inline int UsersetTree_Nodes::nodes_size() const {
  return _internal_nodes_size();
}
inline void UsersetTree_Nodes::clear_nodes() {
  _impl_.nodes_.Clear();
}
inline ::openfga::v1::UsersetTree_Node* UsersetTree_Nodes::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:openfga.v1.UsersetTree.Nodes.nodes)
  return _impl_.nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::UsersetTree_Node >*
UsersetTree_Nodes::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:openfga.v1.UsersetTree.Nodes.nodes)
  return &_impl_.nodes_;
}
inline const ::openfga::v1::UsersetTree_Node& UsersetTree_Nodes::_internal_nodes(int index) const {
  return _impl_.nodes_.Get(index);
}
inline const ::openfga::v1::UsersetTree_Node& UsersetTree_Nodes::nodes(int index) const {
  // @@protoc_insertion_point(field_get:openfga.v1.UsersetTree.Nodes.nodes)
  return _internal_nodes(index);
}
inline ::openfga::v1::UsersetTree_Node* UsersetTree_Nodes::_internal_add_nodes() {
  return _impl_.nodes_.Add();
}
inline ::openfga::v1::UsersetTree_Node* UsersetTree_Nodes::add_nodes() {
  ::openfga::v1::UsersetTree_Node* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:openfga.v1.UsersetTree.Nodes.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::UsersetTree_Node >&
UsersetTree_Nodes::nodes() const {
  // @@protoc_insertion_point(field_list:openfga.v1.UsersetTree.Nodes.nodes)
  return _impl_.nodes_;
}

// -------------------------------------------------------------------

// UsersetTree_Users

// repeated string users = 1 [json_name = "users", (.google.api.field_behavior) = REQUIRED];
inline int UsersetTree_Users::_internal_users_size() const {
  return _impl_.users_.size();
}
inline int UsersetTree_Users::users_size() const {
  return _internal_users_size();
}
inline void UsersetTree_Users::clear_users() {
  _impl_.users_.Clear();
}
inline std::string* UsersetTree_Users::add_users() {
  std::string* _s = _internal_add_users();
  // @@protoc_insertion_point(field_add_mutable:openfga.v1.UsersetTree.Users.users)
  return _s;
}
inline const std::string& UsersetTree_Users::_internal_users(int index) const {
  return _impl_.users_.Get(index);
}
inline const std::string& UsersetTree_Users::users(int index) const {
  // @@protoc_insertion_point(field_get:openfga.v1.UsersetTree.Users.users)
  return _internal_users(index);
}
inline std::string* UsersetTree_Users::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:openfga.v1.UsersetTree.Users.users)
  return _impl_.users_.Mutable(index);
}
inline void UsersetTree_Users::set_users(int index, const std::string& value) {
  _impl_.users_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:openfga.v1.UsersetTree.Users.users)
}
inline void UsersetTree_Users::set_users(int index, std::string&& value) {
  _impl_.users_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:openfga.v1.UsersetTree.Users.users)
}
inline void UsersetTree_Users::set_users(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.users_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:openfga.v1.UsersetTree.Users.users)
}
inline void UsersetTree_Users::set_users(int index, const char* value, size_t size) {
  _impl_.users_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:openfga.v1.UsersetTree.Users.users)
}
inline std::string* UsersetTree_Users::_internal_add_users() {
  return _impl_.users_.Add();
}
inline void UsersetTree_Users::add_users(const std::string& value) {
  _impl_.users_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:openfga.v1.UsersetTree.Users.users)
}
inline void UsersetTree_Users::add_users(std::string&& value) {
  _impl_.users_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:openfga.v1.UsersetTree.Users.users)
}
inline void UsersetTree_Users::add_users(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.users_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:openfga.v1.UsersetTree.Users.users)
}
inline void UsersetTree_Users::add_users(const char* value, size_t size) {
  _impl_.users_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:openfga.v1.UsersetTree.Users.users)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UsersetTree_Users::users() const {
  // @@protoc_insertion_point(field_list:openfga.v1.UsersetTree.Users.users)
  return _impl_.users_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UsersetTree_Users::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:openfga.v1.UsersetTree.Users.users)
  return &_impl_.users_;
}

// -------------------------------------------------------------------

// UsersetTree_Computed

// string userset = 1 [json_name = "userset", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void UsersetTree_Computed::clear_userset() {
  _impl_.userset_.ClearToEmpty();
}
inline const std::string& UsersetTree_Computed::userset() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UsersetTree.Computed.userset)
  return _internal_userset();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UsersetTree_Computed::set_userset(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userset_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.UsersetTree.Computed.userset)
}
inline std::string* UsersetTree_Computed::mutable_userset() {
  std::string* _s = _internal_mutable_userset();
  // @@protoc_insertion_point(field_mutable:openfga.v1.UsersetTree.Computed.userset)
  return _s;
}
inline const std::string& UsersetTree_Computed::_internal_userset() const {
  return _impl_.userset_.Get();
}
inline void UsersetTree_Computed::_internal_set_userset(const std::string& value) {
  
  _impl_.userset_.Set(value, GetArenaForAllocation());
}
inline std::string* UsersetTree_Computed::_internal_mutable_userset() {
  
  return _impl_.userset_.Mutable(GetArenaForAllocation());
}
inline std::string* UsersetTree_Computed::release_userset() {
  // @@protoc_insertion_point(field_release:openfga.v1.UsersetTree.Computed.userset)
  return _impl_.userset_.Release();
}
inline void UsersetTree_Computed::set_allocated_userset(std::string* userset) {
  if (userset != nullptr) {
    
  } else {
    
  }
  _impl_.userset_.SetAllocated(userset, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userset_.IsDefault()) {
    _impl_.userset_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.UsersetTree.Computed.userset)
}

// -------------------------------------------------------------------

// UsersetTree_TupleToUserset

// string tupleset = 1 [json_name = "tupleset", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void UsersetTree_TupleToUserset::clear_tupleset() {
  _impl_.tupleset_.ClearToEmpty();
}
inline const std::string& UsersetTree_TupleToUserset::tupleset() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UsersetTree.TupleToUserset.tupleset)
  return _internal_tupleset();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UsersetTree_TupleToUserset::set_tupleset(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tupleset_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.UsersetTree.TupleToUserset.tupleset)
}
inline std::string* UsersetTree_TupleToUserset::mutable_tupleset() {
  std::string* _s = _internal_mutable_tupleset();
  // @@protoc_insertion_point(field_mutable:openfga.v1.UsersetTree.TupleToUserset.tupleset)
  return _s;
}
inline const std::string& UsersetTree_TupleToUserset::_internal_tupleset() const {
  return _impl_.tupleset_.Get();
}
inline void UsersetTree_TupleToUserset::_internal_set_tupleset(const std::string& value) {
  
  _impl_.tupleset_.Set(value, GetArenaForAllocation());
}
inline std::string* UsersetTree_TupleToUserset::_internal_mutable_tupleset() {
  
  return _impl_.tupleset_.Mutable(GetArenaForAllocation());
}
inline std::string* UsersetTree_TupleToUserset::release_tupleset() {
  // @@protoc_insertion_point(field_release:openfga.v1.UsersetTree.TupleToUserset.tupleset)
  return _impl_.tupleset_.Release();
}
inline void UsersetTree_TupleToUserset::set_allocated_tupleset(std::string* tupleset) {
  if (tupleset != nullptr) {
    
  } else {
    
  }
  _impl_.tupleset_.SetAllocated(tupleset, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tupleset_.IsDefault()) {
    _impl_.tupleset_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.UsersetTree.TupleToUserset.tupleset)
}

// repeated .openfga.v1.UsersetTree.Computed computed = 2 [json_name = "computed", (.google.api.field_behavior) = REQUIRED];
inline int UsersetTree_TupleToUserset::_internal_computed_size() const {
  return _impl_.computed_.size();
}
inline int UsersetTree_TupleToUserset::computed_size() const {
  return _internal_computed_size();
}
inline void UsersetTree_TupleToUserset::clear_computed() {
  _impl_.computed_.Clear();
}
inline ::openfga::v1::UsersetTree_Computed* UsersetTree_TupleToUserset::mutable_computed(int index) {
  // @@protoc_insertion_point(field_mutable:openfga.v1.UsersetTree.TupleToUserset.computed)
  return _impl_.computed_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::UsersetTree_Computed >*
UsersetTree_TupleToUserset::mutable_computed() {
  // @@protoc_insertion_point(field_mutable_list:openfga.v1.UsersetTree.TupleToUserset.computed)
  return &_impl_.computed_;
}
inline const ::openfga::v1::UsersetTree_Computed& UsersetTree_TupleToUserset::_internal_computed(int index) const {
  return _impl_.computed_.Get(index);
}
inline const ::openfga::v1::UsersetTree_Computed& UsersetTree_TupleToUserset::computed(int index) const {
  // @@protoc_insertion_point(field_get:openfga.v1.UsersetTree.TupleToUserset.computed)
  return _internal_computed(index);
}
inline ::openfga::v1::UsersetTree_Computed* UsersetTree_TupleToUserset::_internal_add_computed() {
  return _impl_.computed_.Add();
}
inline ::openfga::v1::UsersetTree_Computed* UsersetTree_TupleToUserset::add_computed() {
  ::openfga::v1::UsersetTree_Computed* _add = _internal_add_computed();
  // @@protoc_insertion_point(field_add:openfga.v1.UsersetTree.TupleToUserset.computed)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openfga::v1::UsersetTree_Computed >&
UsersetTree_TupleToUserset::computed() const {
  // @@protoc_insertion_point(field_list:openfga.v1.UsersetTree.TupleToUserset.computed)
  return _impl_.computed_;
}

// -------------------------------------------------------------------

// UsersetTree_Difference

// .openfga.v1.UsersetTree.Node base = 1 [json_name = "base", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool UsersetTree_Difference::_internal_has_base() const {
  return this != internal_default_instance() && _impl_.base_ != nullptr;
}
inline bool UsersetTree_Difference::has_base() const {
  return _internal_has_base();
}
inline void UsersetTree_Difference::clear_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.base_ != nullptr) {
    delete _impl_.base_;
  }
  _impl_.base_ = nullptr;
}
inline const ::openfga::v1::UsersetTree_Node& UsersetTree_Difference::_internal_base() const {
  const ::openfga::v1::UsersetTree_Node* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::UsersetTree_Node&>(
      ::openfga::v1::_UsersetTree_Node_default_instance_);
}
inline const ::openfga::v1::UsersetTree_Node& UsersetTree_Difference::base() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UsersetTree.Difference.base)
  return _internal_base();
}
inline void UsersetTree_Difference::unsafe_arena_set_allocated_base(
    ::openfga::v1::UsersetTree_Node* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.UsersetTree.Difference.base)
}
inline ::openfga::v1::UsersetTree_Node* UsersetTree_Difference::release_base() {
  
  ::openfga::v1::UsersetTree_Node* temp = _impl_.base_;
  _impl_.base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::UsersetTree_Node* UsersetTree_Difference::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:openfga.v1.UsersetTree.Difference.base)
  
  ::openfga::v1::UsersetTree_Node* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::openfga::v1::UsersetTree_Node* UsersetTree_Difference::_internal_mutable_base() {
  
  if (_impl_.base_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::UsersetTree_Node>(GetArenaForAllocation());
    _impl_.base_ = p;
  }
  return _impl_.base_;
}
inline ::openfga::v1::UsersetTree_Node* UsersetTree_Difference::mutable_base() {
  ::openfga::v1::UsersetTree_Node* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:openfga.v1.UsersetTree.Difference.base)
  return _msg;
}
inline void UsersetTree_Difference::set_allocated_base(::openfga::v1::UsersetTree_Node* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.base_ = base;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.UsersetTree.Difference.base)
}

// .openfga.v1.UsersetTree.Node subtract = 2 [json_name = "subtract", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool UsersetTree_Difference::_internal_has_subtract() const {
  return this != internal_default_instance() && _impl_.subtract_ != nullptr;
}
inline bool UsersetTree_Difference::has_subtract() const {
  return _internal_has_subtract();
}
inline void UsersetTree_Difference::clear_subtract() {
  if (GetArenaForAllocation() == nullptr && _impl_.subtract_ != nullptr) {
    delete _impl_.subtract_;
  }
  _impl_.subtract_ = nullptr;
}
inline const ::openfga::v1::UsersetTree_Node& UsersetTree_Difference::_internal_subtract() const {
  const ::openfga::v1::UsersetTree_Node* p = _impl_.subtract_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::UsersetTree_Node&>(
      ::openfga::v1::_UsersetTree_Node_default_instance_);
}
inline const ::openfga::v1::UsersetTree_Node& UsersetTree_Difference::subtract() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UsersetTree.Difference.subtract)
  return _internal_subtract();
}
inline void UsersetTree_Difference::unsafe_arena_set_allocated_subtract(
    ::openfga::v1::UsersetTree_Node* subtract) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subtract_);
  }
  _impl_.subtract_ = subtract;
  if (subtract) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.UsersetTree.Difference.subtract)
}
inline ::openfga::v1::UsersetTree_Node* UsersetTree_Difference::release_subtract() {
  
  ::openfga::v1::UsersetTree_Node* temp = _impl_.subtract_;
  _impl_.subtract_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::UsersetTree_Node* UsersetTree_Difference::unsafe_arena_release_subtract() {
  // @@protoc_insertion_point(field_release:openfga.v1.UsersetTree.Difference.subtract)
  
  ::openfga::v1::UsersetTree_Node* temp = _impl_.subtract_;
  _impl_.subtract_ = nullptr;
  return temp;
}
inline ::openfga::v1::UsersetTree_Node* UsersetTree_Difference::_internal_mutable_subtract() {
  
  if (_impl_.subtract_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::UsersetTree_Node>(GetArenaForAllocation());
    _impl_.subtract_ = p;
  }
  return _impl_.subtract_;
}
inline ::openfga::v1::UsersetTree_Node* UsersetTree_Difference::mutable_subtract() {
  ::openfga::v1::UsersetTree_Node* _msg = _internal_mutable_subtract();
  // @@protoc_insertion_point(field_mutable:openfga.v1.UsersetTree.Difference.subtract)
  return _msg;
}
inline void UsersetTree_Difference::set_allocated_subtract(::openfga::v1::UsersetTree_Node* subtract) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.subtract_;
  }
  if (subtract) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(subtract);
    if (message_arena != submessage_arena) {
      subtract = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subtract, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.subtract_ = subtract;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.UsersetTree.Difference.subtract)
}

// -------------------------------------------------------------------

// UsersetTree_Node

// string name = 1 [json_name = "name", (.google.api.field_behavior) = REQUIRED];
inline void UsersetTree_Node::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UsersetTree_Node::name() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UsersetTree.Node.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UsersetTree_Node::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.UsersetTree.Node.name)
}
inline std::string* UsersetTree_Node::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:openfga.v1.UsersetTree.Node.name)
  return _s;
}
inline const std::string& UsersetTree_Node::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UsersetTree_Node::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UsersetTree_Node::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UsersetTree_Node::release_name() {
  // @@protoc_insertion_point(field_release:openfga.v1.UsersetTree.Node.name)
  return _impl_.name_.Release();
}
inline void UsersetTree_Node::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.UsersetTree.Node.name)
}

// .openfga.v1.UsersetTree.Leaf leaf = 2 [json_name = "leaf"];
inline bool UsersetTree_Node::_internal_has_leaf() const {
  return value_case() == kLeaf;
}
inline bool UsersetTree_Node::has_leaf() const {
  return _internal_has_leaf();
}
inline void UsersetTree_Node::set_has_leaf() {
  _impl_._oneof_case_[0] = kLeaf;
}
inline void UsersetTree_Node::clear_leaf() {
  if (_internal_has_leaf()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.leaf_;
    }
    clear_has_value();
  }
}
inline ::openfga::v1::UsersetTree_Leaf* UsersetTree_Node::release_leaf() {
  // @@protoc_insertion_point(field_release:openfga.v1.UsersetTree.Node.leaf)
  if (_internal_has_leaf()) {
    clear_has_value();
    ::openfga::v1::UsersetTree_Leaf* temp = _impl_.value_.leaf_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.leaf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openfga::v1::UsersetTree_Leaf& UsersetTree_Node::_internal_leaf() const {
  return _internal_has_leaf()
      ? *_impl_.value_.leaf_
      : reinterpret_cast< ::openfga::v1::UsersetTree_Leaf&>(::openfga::v1::_UsersetTree_Leaf_default_instance_);
}
inline const ::openfga::v1::UsersetTree_Leaf& UsersetTree_Node::leaf() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UsersetTree.Node.leaf)
  return _internal_leaf();
}
inline ::openfga::v1::UsersetTree_Leaf* UsersetTree_Node::unsafe_arena_release_leaf() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openfga.v1.UsersetTree.Node.leaf)
  if (_internal_has_leaf()) {
    clear_has_value();
    ::openfga::v1::UsersetTree_Leaf* temp = _impl_.value_.leaf_;
    _impl_.value_.leaf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UsersetTree_Node::unsafe_arena_set_allocated_leaf(::openfga::v1::UsersetTree_Leaf* leaf) {
  clear_value();
  if (leaf) {
    set_has_leaf();
    _impl_.value_.leaf_ = leaf;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.UsersetTree.Node.leaf)
}
inline ::openfga::v1::UsersetTree_Leaf* UsersetTree_Node::_internal_mutable_leaf() {
  if (!_internal_has_leaf()) {
    clear_value();
    set_has_leaf();
    _impl_.value_.leaf_ = CreateMaybeMessage< ::openfga::v1::UsersetTree_Leaf >(GetArenaForAllocation());
  }
  return _impl_.value_.leaf_;
}
inline ::openfga::v1::UsersetTree_Leaf* UsersetTree_Node::mutable_leaf() {
  ::openfga::v1::UsersetTree_Leaf* _msg = _internal_mutable_leaf();
  // @@protoc_insertion_point(field_mutable:openfga.v1.UsersetTree.Node.leaf)
  return _msg;
}

// .openfga.v1.UsersetTree.Difference difference = 5 [json_name = "difference"];
inline bool UsersetTree_Node::_internal_has_difference() const {
  return value_case() == kDifference;
}
inline bool UsersetTree_Node::has_difference() const {
  return _internal_has_difference();
}
inline void UsersetTree_Node::set_has_difference() {
  _impl_._oneof_case_[0] = kDifference;
}
inline void UsersetTree_Node::clear_difference() {
  if (_internal_has_difference()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.difference_;
    }
    clear_has_value();
  }
}
inline ::openfga::v1::UsersetTree_Difference* UsersetTree_Node::release_difference() {
  // @@protoc_insertion_point(field_release:openfga.v1.UsersetTree.Node.difference)
  if (_internal_has_difference()) {
    clear_has_value();
    ::openfga::v1::UsersetTree_Difference* temp = _impl_.value_.difference_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.difference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openfga::v1::UsersetTree_Difference& UsersetTree_Node::_internal_difference() const {
  return _internal_has_difference()
      ? *_impl_.value_.difference_
      : reinterpret_cast< ::openfga::v1::UsersetTree_Difference&>(::openfga::v1::_UsersetTree_Difference_default_instance_);
}
inline const ::openfga::v1::UsersetTree_Difference& UsersetTree_Node::difference() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UsersetTree.Node.difference)
  return _internal_difference();
}
inline ::openfga::v1::UsersetTree_Difference* UsersetTree_Node::unsafe_arena_release_difference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openfga.v1.UsersetTree.Node.difference)
  if (_internal_has_difference()) {
    clear_has_value();
    ::openfga::v1::UsersetTree_Difference* temp = _impl_.value_.difference_;
    _impl_.value_.difference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UsersetTree_Node::unsafe_arena_set_allocated_difference(::openfga::v1::UsersetTree_Difference* difference) {
  clear_value();
  if (difference) {
    set_has_difference();
    _impl_.value_.difference_ = difference;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.UsersetTree.Node.difference)
}
inline ::openfga::v1::UsersetTree_Difference* UsersetTree_Node::_internal_mutable_difference() {
  if (!_internal_has_difference()) {
    clear_value();
    set_has_difference();
    _impl_.value_.difference_ = CreateMaybeMessage< ::openfga::v1::UsersetTree_Difference >(GetArenaForAllocation());
  }
  return _impl_.value_.difference_;
}
inline ::openfga::v1::UsersetTree_Difference* UsersetTree_Node::mutable_difference() {
  ::openfga::v1::UsersetTree_Difference* _msg = _internal_mutable_difference();
  // @@protoc_insertion_point(field_mutable:openfga.v1.UsersetTree.Node.difference)
  return _msg;
}

// .openfga.v1.UsersetTree.Nodes union = 6 [json_name = "union"];
inline bool UsersetTree_Node::_internal_has_union_() const {
  return value_case() == kUnion;
}
inline bool UsersetTree_Node::has_union_() const {
  return _internal_has_union_();
}
inline void UsersetTree_Node::set_has_union_() {
  _impl_._oneof_case_[0] = kUnion;
}
inline void UsersetTree_Node::clear_union_() {
  if (_internal_has_union_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.union__;
    }
    clear_has_value();
  }
}
inline ::openfga::v1::UsersetTree_Nodes* UsersetTree_Node::release_union_() {
  // @@protoc_insertion_point(field_release:openfga.v1.UsersetTree.Node.union)
  if (_internal_has_union_()) {
    clear_has_value();
    ::openfga::v1::UsersetTree_Nodes* temp = _impl_.value_.union__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.union__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openfga::v1::UsersetTree_Nodes& UsersetTree_Node::_internal_union_() const {
  return _internal_has_union_()
      ? *_impl_.value_.union__
      : reinterpret_cast< ::openfga::v1::UsersetTree_Nodes&>(::openfga::v1::_UsersetTree_Nodes_default_instance_);
}
inline const ::openfga::v1::UsersetTree_Nodes& UsersetTree_Node::union_() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UsersetTree.Node.union)
  return _internal_union_();
}
inline ::openfga::v1::UsersetTree_Nodes* UsersetTree_Node::unsafe_arena_release_union_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openfga.v1.UsersetTree.Node.union)
  if (_internal_has_union_()) {
    clear_has_value();
    ::openfga::v1::UsersetTree_Nodes* temp = _impl_.value_.union__;
    _impl_.value_.union__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UsersetTree_Node::unsafe_arena_set_allocated_union_(::openfga::v1::UsersetTree_Nodes* union_) {
  clear_value();
  if (union_) {
    set_has_union_();
    _impl_.value_.union__ = union_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.UsersetTree.Node.union)
}
inline ::openfga::v1::UsersetTree_Nodes* UsersetTree_Node::_internal_mutable_union_() {
  if (!_internal_has_union_()) {
    clear_value();
    set_has_union_();
    _impl_.value_.union__ = CreateMaybeMessage< ::openfga::v1::UsersetTree_Nodes >(GetArenaForAllocation());
  }
  return _impl_.value_.union__;
}
inline ::openfga::v1::UsersetTree_Nodes* UsersetTree_Node::mutable_union_() {
  ::openfga::v1::UsersetTree_Nodes* _msg = _internal_mutable_union_();
  // @@protoc_insertion_point(field_mutable:openfga.v1.UsersetTree.Node.union)
  return _msg;
}

// .openfga.v1.UsersetTree.Nodes intersection = 7 [json_name = "intersection"];
inline bool UsersetTree_Node::_internal_has_intersection() const {
  return value_case() == kIntersection;
}
inline bool UsersetTree_Node::has_intersection() const {
  return _internal_has_intersection();
}
inline void UsersetTree_Node::set_has_intersection() {
  _impl_._oneof_case_[0] = kIntersection;
}
inline void UsersetTree_Node::clear_intersection() {
  if (_internal_has_intersection()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.intersection_;
    }
    clear_has_value();
  }
}
inline ::openfga::v1::UsersetTree_Nodes* UsersetTree_Node::release_intersection() {
  // @@protoc_insertion_point(field_release:openfga.v1.UsersetTree.Node.intersection)
  if (_internal_has_intersection()) {
    clear_has_value();
    ::openfga::v1::UsersetTree_Nodes* temp = _impl_.value_.intersection_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.intersection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openfga::v1::UsersetTree_Nodes& UsersetTree_Node::_internal_intersection() const {
  return _internal_has_intersection()
      ? *_impl_.value_.intersection_
      : reinterpret_cast< ::openfga::v1::UsersetTree_Nodes&>(::openfga::v1::_UsersetTree_Nodes_default_instance_);
}
inline const ::openfga::v1::UsersetTree_Nodes& UsersetTree_Node::intersection() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UsersetTree.Node.intersection)
  return _internal_intersection();
}
inline ::openfga::v1::UsersetTree_Nodes* UsersetTree_Node::unsafe_arena_release_intersection() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openfga.v1.UsersetTree.Node.intersection)
  if (_internal_has_intersection()) {
    clear_has_value();
    ::openfga::v1::UsersetTree_Nodes* temp = _impl_.value_.intersection_;
    _impl_.value_.intersection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UsersetTree_Node::unsafe_arena_set_allocated_intersection(::openfga::v1::UsersetTree_Nodes* intersection) {
  clear_value();
  if (intersection) {
    set_has_intersection();
    _impl_.value_.intersection_ = intersection;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.UsersetTree.Node.intersection)
}
inline ::openfga::v1::UsersetTree_Nodes* UsersetTree_Node::_internal_mutable_intersection() {
  if (!_internal_has_intersection()) {
    clear_value();
    set_has_intersection();
    _impl_.value_.intersection_ = CreateMaybeMessage< ::openfga::v1::UsersetTree_Nodes >(GetArenaForAllocation());
  }
  return _impl_.value_.intersection_;
}
inline ::openfga::v1::UsersetTree_Nodes* UsersetTree_Node::mutable_intersection() {
  ::openfga::v1::UsersetTree_Nodes* _msg = _internal_mutable_intersection();
  // @@protoc_insertion_point(field_mutable:openfga.v1.UsersetTree.Node.intersection)
  return _msg;
}

inline bool UsersetTree_Node::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void UsersetTree_Node::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline UsersetTree_Node::ValueCase UsersetTree_Node::value_case() const {
  return UsersetTree_Node::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// UsersetTree

// .openfga.v1.UsersetTree.Node root = 1 [json_name = "root"];
inline bool UsersetTree::_internal_has_root() const {
  return this != internal_default_instance() && _impl_.root_ != nullptr;
}
inline bool UsersetTree::has_root() const {
  return _internal_has_root();
}
inline void UsersetTree::clear_root() {
  if (GetArenaForAllocation() == nullptr && _impl_.root_ != nullptr) {
    delete _impl_.root_;
  }
  _impl_.root_ = nullptr;
}
inline const ::openfga::v1::UsersetTree_Node& UsersetTree::_internal_root() const {
  const ::openfga::v1::UsersetTree_Node* p = _impl_.root_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::UsersetTree_Node&>(
      ::openfga::v1::_UsersetTree_Node_default_instance_);
}
inline const ::openfga::v1::UsersetTree_Node& UsersetTree::root() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UsersetTree.root)
  return _internal_root();
}
inline void UsersetTree::unsafe_arena_set_allocated_root(
    ::openfga::v1::UsersetTree_Node* root) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.root_);
  }
  _impl_.root_ = root;
  if (root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.UsersetTree.root)
}
inline ::openfga::v1::UsersetTree_Node* UsersetTree::release_root() {
  
  ::openfga::v1::UsersetTree_Node* temp = _impl_.root_;
  _impl_.root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::UsersetTree_Node* UsersetTree::unsafe_arena_release_root() {
  // @@protoc_insertion_point(field_release:openfga.v1.UsersetTree.root)
  
  ::openfga::v1::UsersetTree_Node* temp = _impl_.root_;
  _impl_.root_ = nullptr;
  return temp;
}
inline ::openfga::v1::UsersetTree_Node* UsersetTree::_internal_mutable_root() {
  
  if (_impl_.root_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::UsersetTree_Node>(GetArenaForAllocation());
    _impl_.root_ = p;
  }
  return _impl_.root_;
}
inline ::openfga::v1::UsersetTree_Node* UsersetTree::mutable_root() {
  ::openfga::v1::UsersetTree_Node* _msg = _internal_mutable_root();
  // @@protoc_insertion_point(field_mutable:openfga.v1.UsersetTree.root)
  return _msg;
}
inline void UsersetTree::set_allocated_root(::openfga::v1::UsersetTree_Node* root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.root_;
  }
  if (root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(root);
    if (message_arena != submessage_arena) {
      root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, root, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.root_ = root;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.UsersetTree.root)
}

// -------------------------------------------------------------------

// TupleChange

// .openfga.v1.TupleKey tuple_key = 1 [json_name = "tuple_key", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool TupleChange::_internal_has_tuple_key() const {
  return this != internal_default_instance() && _impl_.tuple_key_ != nullptr;
}
inline bool TupleChange::has_tuple_key() const {
  return _internal_has_tuple_key();
}
inline void TupleChange::clear_tuple_key() {
  if (GetArenaForAllocation() == nullptr && _impl_.tuple_key_ != nullptr) {
    delete _impl_.tuple_key_;
  }
  _impl_.tuple_key_ = nullptr;
}
inline const ::openfga::v1::TupleKey& TupleChange::_internal_tuple_key() const {
  const ::openfga::v1::TupleKey* p = _impl_.tuple_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::openfga::v1::TupleKey&>(
      ::openfga::v1::_TupleKey_default_instance_);
}
inline const ::openfga::v1::TupleKey& TupleChange::tuple_key() const {
  // @@protoc_insertion_point(field_get:openfga.v1.TupleChange.tuple_key)
  return _internal_tuple_key();
}
inline void TupleChange::unsafe_arena_set_allocated_tuple_key(
    ::openfga::v1::TupleKey* tuple_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tuple_key_);
  }
  _impl_.tuple_key_ = tuple_key;
  if (tuple_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.TupleChange.tuple_key)
}
inline ::openfga::v1::TupleKey* TupleChange::release_tuple_key() {
  
  ::openfga::v1::TupleKey* temp = _impl_.tuple_key_;
  _impl_.tuple_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openfga::v1::TupleKey* TupleChange::unsafe_arena_release_tuple_key() {
  // @@protoc_insertion_point(field_release:openfga.v1.TupleChange.tuple_key)
  
  ::openfga::v1::TupleKey* temp = _impl_.tuple_key_;
  _impl_.tuple_key_ = nullptr;
  return temp;
}
inline ::openfga::v1::TupleKey* TupleChange::_internal_mutable_tuple_key() {
  
  if (_impl_.tuple_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::openfga::v1::TupleKey>(GetArenaForAllocation());
    _impl_.tuple_key_ = p;
  }
  return _impl_.tuple_key_;
}
inline ::openfga::v1::TupleKey* TupleChange::mutable_tuple_key() {
  ::openfga::v1::TupleKey* _msg = _internal_mutable_tuple_key();
  // @@protoc_insertion_point(field_mutable:openfga.v1.TupleChange.tuple_key)
  return _msg;
}
inline void TupleChange::set_allocated_tuple_key(::openfga::v1::TupleKey* tuple_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tuple_key_;
  }
  if (tuple_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tuple_key);
    if (message_arena != submessage_arena) {
      tuple_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tuple_key, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tuple_key_ = tuple_key;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.TupleChange.tuple_key)
}

// .openfga.v1.TupleOperation operation = 2 [json_name = "operation", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void TupleChange::clear_operation() {
  _impl_.operation_ = 0;
}
inline ::openfga::v1::TupleOperation TupleChange::_internal_operation() const {
  return static_cast< ::openfga::v1::TupleOperation >(_impl_.operation_);
}
inline ::openfga::v1::TupleOperation TupleChange::operation() const {
  // @@protoc_insertion_point(field_get:openfga.v1.TupleChange.operation)
  return _internal_operation();
}
inline void TupleChange::_internal_set_operation(::openfga::v1::TupleOperation value) {
  
  _impl_.operation_ = value;
}
inline void TupleChange::set_operation(::openfga::v1::TupleOperation value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:openfga.v1.TupleChange.operation)
}

// .google.protobuf.Timestamp timestamp = 3 [json_name = "timestamp", (.google.api.field_behavior) = REQUIRED];
inline bool TupleChange::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool TupleChange::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TupleChange::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TupleChange::timestamp() const {
  // @@protoc_insertion_point(field_get:openfga.v1.TupleChange.timestamp)
  return _internal_timestamp();
}
inline void TupleChange::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.TupleChange.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TupleChange::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TupleChange::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:openfga.v1.TupleChange.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TupleChange::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TupleChange::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:openfga.v1.TupleChange.timestamp)
  return _msg;
}
inline void TupleChange::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.TupleChange.timestamp)
}

// -------------------------------------------------------------------

// Store

// string id = 1 [json_name = "id", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void Store::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Store::id() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Store.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Store::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.Store.id)
}
inline std::string* Store::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Store.id)
  return _s;
}
inline const std::string& Store::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Store::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Store::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Store::release_id() {
  // @@protoc_insertion_point(field_release:openfga.v1.Store.id)
  return _impl_.id_.Release();
}
inline void Store::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.Store.id)
}

// string name = 2 [json_name = "name", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void Store::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Store::name() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Store.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Store::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.Store.name)
}
inline std::string* Store::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Store.name)
  return _s;
}
inline const std::string& Store::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Store::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Store::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Store::release_name() {
  // @@protoc_insertion_point(field_release:openfga.v1.Store.name)
  return _impl_.name_.Release();
}
inline void Store::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.Store.name)
}

// .google.protobuf.Timestamp created_at = 3 [json_name = "created_at", (.google.api.field_behavior) = REQUIRED];
inline bool Store::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool Store::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Store::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Store::created_at() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Store.created_at)
  return _internal_created_at();
}
inline void Store::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.Store.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Store::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Store::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:openfga.v1.Store.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Store::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Store::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Store.created_at)
  return _msg;
}
inline void Store::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.Store.created_at)
}

// .google.protobuf.Timestamp updated_at = 4 [json_name = "updated_at", (.google.api.field_behavior) = REQUIRED];
inline bool Store::_internal_has_updated_at() const {
  return this != internal_default_instance() && _impl_.updated_at_ != nullptr;
}
inline bool Store::has_updated_at() const {
  return _internal_has_updated_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Store::_internal_updated_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Store::updated_at() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Store.updated_at)
  return _internal_updated_at();
}
inline void Store::unsafe_arena_set_allocated_updated_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  _impl_.updated_at_ = updated_at;
  if (updated_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.Store.updated_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Store::release_updated_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Store::unsafe_arena_release_updated_at() {
  // @@protoc_insertion_point(field_release:openfga.v1.Store.updated_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Store::_internal_mutable_updated_at() {
  
  if (_impl_.updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.updated_at_ = p;
  }
  return _impl_.updated_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Store::mutable_updated_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Store.updated_at)
  return _msg;
}
inline void Store::set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  if (updated_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at));
    if (message_arena != submessage_arena) {
      updated_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.updated_at_ = updated_at;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.Store.updated_at)
}

// .google.protobuf.Timestamp deleted_at = 5 [json_name = "deleted_at"];
inline bool Store::_internal_has_deleted_at() const {
  return this != internal_default_instance() && _impl_.deleted_at_ != nullptr;
}
inline bool Store::has_deleted_at() const {
  return _internal_has_deleted_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Store::_internal_deleted_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.deleted_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Store::deleted_at() const {
  // @@protoc_insertion_point(field_get:openfga.v1.Store.deleted_at)
  return _internal_deleted_at();
}
inline void Store::unsafe_arena_set_allocated_deleted_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deleted_at_);
  }
  _impl_.deleted_at_ = deleted_at;
  if (deleted_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openfga.v1.Store.deleted_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Store::release_deleted_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.deleted_at_;
  _impl_.deleted_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Store::unsafe_arena_release_deleted_at() {
  // @@protoc_insertion_point(field_release:openfga.v1.Store.deleted_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.deleted_at_;
  _impl_.deleted_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Store::_internal_mutable_deleted_at() {
  
  if (_impl_.deleted_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.deleted_at_ = p;
  }
  return _impl_.deleted_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Store::mutable_deleted_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_deleted_at();
  // @@protoc_insertion_point(field_mutable:openfga.v1.Store.deleted_at)
  return _msg;
}
inline void Store::set_allocated_deleted_at(::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deleted_at_);
  }
  if (deleted_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deleted_at));
    if (message_arena != submessage_arena) {
      deleted_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deleted_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.deleted_at_ = deleted_at;
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.Store.deleted_at)
}

// -------------------------------------------------------------------

// UserTypeFilter

// string type = 1 [json_name = "type", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void UserTypeFilter::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& UserTypeFilter::type() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UserTypeFilter.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserTypeFilter::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.UserTypeFilter.type)
}
inline std::string* UserTypeFilter::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:openfga.v1.UserTypeFilter.type)
  return _s;
}
inline const std::string& UserTypeFilter::_internal_type() const {
  return _impl_.type_.Get();
}
inline void UserTypeFilter::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* UserTypeFilter::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* UserTypeFilter::release_type() {
  // @@protoc_insertion_point(field_release:openfga.v1.UserTypeFilter.type)
  return _impl_.type_.Release();
}
inline void UserTypeFilter::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.UserTypeFilter.type)
}

// string relation = 2 [json_name = "relation", (.grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
inline void UserTypeFilter::clear_relation() {
  _impl_.relation_.ClearToEmpty();
}
inline const std::string& UserTypeFilter::relation() const {
  // @@protoc_insertion_point(field_get:openfga.v1.UserTypeFilter.relation)
  return _internal_relation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserTypeFilter::set_relation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.relation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openfga.v1.UserTypeFilter.relation)
}
inline std::string* UserTypeFilter::mutable_relation() {
  std::string* _s = _internal_mutable_relation();
  // @@protoc_insertion_point(field_mutable:openfga.v1.UserTypeFilter.relation)
  return _s;
}
inline const std::string& UserTypeFilter::_internal_relation() const {
  return _impl_.relation_.Get();
}
inline void UserTypeFilter::_internal_set_relation(const std::string& value) {
  
  _impl_.relation_.Set(value, GetArenaForAllocation());
}
inline std::string* UserTypeFilter::_internal_mutable_relation() {
  
  return _impl_.relation_.Mutable(GetArenaForAllocation());
}
inline std::string* UserTypeFilter::release_relation() {
  // @@protoc_insertion_point(field_release:openfga.v1.UserTypeFilter.relation)
  return _impl_.relation_.Release();
}
inline void UserTypeFilter::set_allocated_relation(std::string* relation) {
  if (relation != nullptr) {
    
  } else {
    
  }
  _impl_.relation_.SetAllocated(relation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.relation_.IsDefault()) {
    _impl_.relation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openfga.v1.UserTypeFilter.relation)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace openfga

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::openfga::v1::TupleOperation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::openfga::v1::TupleOperation>() {
  return ::openfga::v1::TupleOperation_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_openfga_2fv1_2fopenfga_2eproto
